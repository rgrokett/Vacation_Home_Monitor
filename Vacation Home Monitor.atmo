{
  "name": "Vacation Home Monitor",
  "createVersion": "2017-08-12",
  "description": "Demonstrates remotely monitoring the environment inside a remote vacation or elderly parent's home reporting indoor temperature, humidity, air quality and security.",
  "lastModified": "2018-02-13T00:39:19.386Z",
  "created": "2018-02-13T00:39:19.386Z",
  "meta": {
    "projectTypeName": "NXP Rapid IoT",
    "projectTypeId": "NxpRpk"
  },
  "planes": {
    "NXP Rapid IoT": {
      "type": "mcuxpresso",
      "compilerVersion": "latest",
      "variants": [
        "NxpRpk"
      ],
      "meta": {},
      "elements": [
        {
          "name": "AirQualityCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), ATMO_PROPERTY(AirQualityCharacteristic, readDataType), ATMO_PROPERTY(AirQualityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AirQualityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AirQualityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e75-a4ff-6f0cd50005f4",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 297.50006103515625,
            "editorY": 511,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "TemperatureCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), ATMO_PROPERTY(TemperatureCharacteristic, readDataType), ATMO_PROPERTY(TemperatureCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(TemperatureCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(TemperatureCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e76-a4ff-6f0cd50005f1",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 406.50006103515625,
            "editorY": 0,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "HumidityCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(HumidityCharacteristic, writeDataType), ATMO_PROPERTY(HumidityCharacteristic, readDataType), ATMO_PROPERTY(HumidityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(HumidityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(HumidityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(HumidityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e77-a4ff-6f0cd50005f2",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 406.50006103515625,
            "editorY": 192,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "AmbientLightCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AmbientLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AmbientLightCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AmbientLightCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AmbientLightCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AmbientLightCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AmbientLightCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AmbientLightCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AmbientLightCharacteristic, writeDataType), ATMO_PROPERTY(AmbientLightCharacteristic, readDataType), ATMO_PROPERTY(AmbientLightCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AmbientLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AmbientLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AmbientLightCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\tATMO_VARIABLE(AmbientLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AmbientLightCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AmbientLightCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\tATMO_VARIABLE(AmbientLightCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AmbientLightCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e79-a4ff-6f0cd50005f3",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 301.50006103515625,
            "editorY": 360,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "SX9500Touch",
          "type": "EmbeddedSX9500",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(SX9500Touch, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(SX9500Touch, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(SX9500Touch, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(SX9500Touch, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(SX9500Touch, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(SX9500Touch, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(SX9500Touch, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(SX9500Touch, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(SX9500Touch, pressRight));\n\treturn ATMO_Status_Success;",
              "getTouchData": "",
              "pressUp": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressDown": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressLeft": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressRight": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "getTouchData": false,
              "pressUp": false,
              "pressDown": false,
              "pressLeft": false,
              "pressRight": false
            },
            "i2cInstance": 1,
            "gpioInstance": 0,
            "interruptEnabled": true,
            "interruptGpio": "PTA9",
            "i2cAddress": "0x28"
          },
          "meta": {
            "editorX": 1079.33349609375,
            "editorY": 33,
            "lastTrigger": "rightPressed"
          },
          "triggers": {
            "triggered": [],
            "touchDataRead": [],
            "upPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateUp"
              }
            ],
            "downPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateDown"
              }
            ],
            "leftPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateLeft"
              }
            ],
            "rightPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateRight"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "getTouchData": false,
            "pressUp": false,
            "pressDown": false,
            "pressLeft": false,
            "pressRight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "getTouchData",
              "triggers": [
                "touchDataRead"
              ]
            },
            {
              "name": "pressUp",
              "triggers": [
                "upPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressDown",
              "triggers": [
                "downPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressLeft",
              "triggers": [
                "leftPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressRight",
              "triggers": [
                "rightPressed",
                "touchDataRead"
              ]
            }
          ]
        },
        {
          "name": "Temperature_P",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(Temperature_P, x), ATMO_PROPERTY(Temperature_P, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(Temperature_P, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(Temperature_P, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(Temperature_P, topRightButtonEnabled),\n    ATMO_PROPERTY(Temperature_P,bottomRightButtonEnabled), ATMO_PROPERTY(Temperature_P, topLeftButtonEnabled), ATMO_PROPERTY(Temperature_P, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(Temperature_P, x);\n    config.x = ATMO_PROPERTY(Temperature_P, x);\n    config.y = ATMO_PROPERTY(Temperature_P, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(Temperature_P, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(Temperature_P, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(Temperature_P, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(Temperature_P, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(Temperature_P, spanX);\n\tconfig.spanY = ATMO_PROPERTY(Temperature_P, spanY);\n    config.title = ATMO_PROPERTY(Temperature_P, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(Temperature_P, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(Temperature_P, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(Temperature_P, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(Temperature_P, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), ATMO_ABILITY(Temperature_P, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 1, ATMO_ABILITY(Temperature_P, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 2, ATMO_ABILITY(Temperature_P, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 3, ATMO_ABILITY(Temperature_P, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 4, ATMO_ABILITY(Temperature_P, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(Temperature_P, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(Temperature_P,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Temperature",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": 0,
            "y": 0,
            "spanX": 1,
            "spanY": 1,
            "icon": "icon_applications_thermostat",
            "label": "N/A"
          },
          "meta": {
            "editorX": 663.33349609375,
            "editorY": 137,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "EmbeddedPageController",
          "type": "EmbeddedPageController",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_UI_PAGE_CONTROLLER_Config_t config;\n\tconfig.enableUpDownNavLabels = ATMO_PROPERTY(EmbeddedPageController, upDownNavigationLabelsEnabled);\n\tconfig.enableLeftRightNavLabels = ATMO_PROPERTY(EmbeddedPageController, leftRightNavigationLabelsEnabled);\n\tATMO_UI_Page_SetConfiguration(&config);\n    return ATMO_Status_Success;\n\t",
              "displayRootPage": "\n\t\n\tATMO_UI_Page_DisplayRootPage();\n\treturn ATMO_Status_Success;\n\t",
              "navigateUp": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_UP);\n\treturn ATMO_Status_Success;\n\t",
              "navigateDown": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_DOWN);\n\treturn ATMO_Status_Success;\n\t",
              "navigateLeft": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_LEFT);\n\treturn ATMO_Status_Success;\n\t",
              "navigateRight": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_RIGHT);\n\treturn ATMO_Status_Success;\n\t",
              "processTopRightButton": "\n\tATMO_UI_Page_ProcessUserButton(1);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomRightButton": "\n\tATMO_UI_Page_ProcessUserButton(2);\n\treturn ATMO_Status_Success;\n\t",
              "processTopLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(3);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(4);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "displayRootPage": false,
              "navigateUp": false,
              "navigateDown": false,
              "navigateLeft": false,
              "navigateRight": false,
              "processTopRightButton": false,
              "processBottomRightButton": false,
              "processTopLeftButton": false,
              "processBottomLeftButton": false
            },
            "upDownNavigationLabelsEnabled": true,
            "leftRightNavigationLabelsEnabled": true
          },
          "meta": {
            "editorX": 1222.33349609375,
            "editorY": 29,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "navigateUp": [],
            "navigateDown": [],
            "navigateLeft": [],
            "navigateRight": [],
            "processTopRightButton": [],
            "processBottomRightButton": [],
            "processTopLeftButton": [],
            "processBottomLeftButton": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "displayRootPage": false,
            "navigateUp": false,
            "navigateDown": false,
            "navigateLeft": false,
            "navigateRight": false,
            "processTopRightButton": false,
            "processBottomRightButton": false,
            "processTopLeftButton": false,
            "processBottomLeftButton": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "displayRootPage",
              "triggers": []
            },
            {
              "name": "navigateUp",
              "triggers": [
                "navigateUp"
              ]
            },
            {
              "name": "navigateDown",
              "triggers": [
                "navigateDown"
              ]
            },
            {
              "name": "navigateLeft",
              "triggers": [
                "navigateLeft"
              ]
            },
            {
              "name": "navigateRight",
              "triggers": [
                "navigateRight"
              ]
            },
            {
              "name": "processTopRightButton",
              "triggers": [
                "processTopRightButton"
              ]
            },
            {
              "name": "processBottomRightButton",
              "triggers": [
                "processBottomRightButton"
              ]
            },
            {
              "name": "processTopLeftButton",
              "triggers": [
                "processTopLeftButton"
              ]
            },
            {
              "name": "processBottomLeftButton",
              "triggers": [
                "processBottomLeftButton"
              ]
            }
          ]
        },
        {
          "name": "Humidity_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(Humidity_Pag, x), ATMO_PROPERTY(Humidity_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(Humidity_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(Humidity_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(Humidity_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(Humidity_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(Humidity_Pag, topLeftButtonEnabled), ATMO_PROPERTY(Humidity_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(Humidity_Pag, x);\n    config.x = ATMO_PROPERTY(Humidity_Pag, x);\n    config.y = ATMO_PROPERTY(Humidity_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(Humidity_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(Humidity_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(Humidity_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(Humidity_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(Humidity_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(Humidity_Pag, spanY);\n    config.title = ATMO_PROPERTY(Humidity_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(Humidity_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(Humidity_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(Humidity_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(Humidity_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), ATMO_ABILITY(Humidity_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 1, ATMO_ABILITY(Humidity_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 2, ATMO_ABILITY(Humidity_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 3, ATMO_ABILITY(Humidity_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 4, ATMO_ABILITY(Humidity_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(Humidity_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(Humidity_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Humidity",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "1",
            "y": 0,
            "spanX": 1,
            "spanY": 1,
            "icon": "icon_applications_humidity",
            "label": "N/A"
          },
          "meta": {
            "editorX": 667.33349609375,
            "editorY": 220,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "AmientLight_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(AmientLight_Pag, x), ATMO_PROPERTY(AmientLight_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(AmientLight_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(AmientLight_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(AmientLight_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(AmientLight_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(AmientLight_Pag, topLeftButtonEnabled), ATMO_PROPERTY(AmientLight_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(AmientLight_Pag, x);\n    config.x = ATMO_PROPERTY(AmientLight_Pag, x);\n    config.y = ATMO_PROPERTY(AmientLight_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(AmientLight_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(AmientLight_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(AmientLight_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(AmientLight_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(AmientLight_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(AmientLight_Pag, spanY);\n    config.title = ATMO_PROPERTY(AmientLight_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(AmientLight_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(AmientLight_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(AmientLight_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(AmientLight_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(AmientLight_Pag,pageHandle), ATMO_ABILITY(AmientLight_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AmientLight_Pag,pageHandle), 1, ATMO_ABILITY(AmientLight_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AmientLight_Pag,pageHandle), 2, ATMO_ABILITY(AmientLight_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AmientLight_Pag,pageHandle), 3, ATMO_ABILITY(AmientLight_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AmientLight_Pag,pageHandle), 4, ATMO_ABILITY(AmientLight_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(AmientLight_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(AmientLight_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Ambient Light",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "3",
            "y": 0,
            "spanX": 1,
            "spanY": 1,
            "icon": "icon_applications_light",
            "label": "N/A"
          },
          "meta": {
            "editorX": 665.3333740234375,
            "editorY": 385,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "AirQuality_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(AirQuality_Pag, x), ATMO_PROPERTY(AirQuality_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(AirQuality_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(AirQuality_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(AirQuality_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(AirQuality_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(AirQuality_Pag, topLeftButtonEnabled), ATMO_PROPERTY(AirQuality_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(AirQuality_Pag, x);\n    config.x = ATMO_PROPERTY(AirQuality_Pag, x);\n    config.y = ATMO_PROPERTY(AirQuality_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(AirQuality_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(AirQuality_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(AirQuality_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(AirQuality_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(AirQuality_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(AirQuality_Pag, spanY);\n    config.title = ATMO_PROPERTY(AirQuality_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(AirQuality_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(AirQuality_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(AirQuality_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(AirQuality_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), ATMO_ABILITY(AirQuality_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 1, ATMO_ABILITY(AirQuality_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 2, ATMO_ABILITY(AirQuality_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 3, ATMO_ABILITY(AirQuality_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 4, ATMO_ABILITY(AirQuality_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(AirQuality_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(AirQuality_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Air TVOC",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "5",
            "y": 0,
            "spanX": "4",
            "spanY": 1,
            "icon": "icon_applications_airq",
            "label": ""
          },
          "meta": {
            "editorX": 667.1666870117188,
            "editorY": 471,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "Interval",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval, instance), \n\t\tATMO_ABILITY(Interval, interval), \n\t\tATMO_PROPERTY(Interval, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": 0,
            "time": "60000"
          },
          "meta": {
            "editorX": 34.16668701171875,
            "editorY": 230,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TSL2572AmbientLight",
                "targetAbility": "readAmbientLight"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "ENS210TemperatureHumidity",
                "targetAbility": "readTemperature"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "ENS210TemperatureHumidity",
                "targetAbility": "readHumidity"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CCS811AirQuality",
                "targetAbility": "readTVOC"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "TSL2572AmbientLight",
          "type": "EmbeddedTSL2572",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(TSL2572AmbientLight, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(TSL2572AmbientLight, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readAmbientLight": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readAmbientLight": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x39"
          },
          "meta": {
            "editorX": 182.16668701171875,
            "editorY": 294,
            "lastTrigger": "ambientLightRead"
          },
          "triggers": {
            "triggered": [],
            "ambientLightRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AmbientLightCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetLightStr",
                "targetAbility": "trigger"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readAmbientLight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readAmbientLight",
              "triggers": [
                "ambientLightRead"
              ]
            }
          ]
        },
        {
          "name": "GetTempStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat temp = 0;\n\tATMO_GetFloat(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%.1f C\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 558.3333740234375,
            "editorY": 101,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Temperature_P",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "GetHumidityStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat temp = 0;\n\tATMO_GetFloat(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%.1f %%rh\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 572.3333740234375,
            "editorY": 188,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Humidity_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "GetLightStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tint temp = 0;\n\tATMO_GetInt(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%d lx\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 534.3333740234375,
            "editorY": 392,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AmientLight_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "GetAirQualityStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tint temp = 0;\n\tATMO_GetInt(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%d ppb\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 533.3333740234375,
            "editorY": 467,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQuality_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "ENS210TemperatureHumidity",
          "type": "EmbeddedENS210",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(ENS210TemperatureHumidity, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(ENS210TemperatureHumidity, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(ENS210TemperatureHumidity, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTemperature": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readHumidity": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTemperature": false,
              "readHumidity": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x43",
            "tempCalibrationOffset": -7
          },
          "meta": {
            "editorX": 184.3333740234375,
            "editorY": 9,
            "lastTrigger": "temperatureRead"
          },
          "triggers": {
            "triggered": [],
            "temperatureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetTempStr",
                "targetAbility": "trigger"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TemperatureCharacteristic",
                "targetAbility": "setValue"
              }
            ],
            "humidityRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "HumidityCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetHumidityStr",
                "targetAbility": "trigger"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTemperature": false,
            "readHumidity": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTemperature",
              "triggers": [
                "temperatureRead"
              ]
            },
            {
              "name": "readHumidity",
              "triggers": [
                "humidityRead"
              ]
            }
          ]
        },
        {
          "name": "CCS811AirQuality",
          "type": "EmbeddedCCS811",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(CCS811AirQuality, operatingMode);\n\tconfig.address = ATMO_PROPERTY(CCS811AirQuality, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(CCS811AirQuality, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTVOC": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readCO2": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTVOC": false,
              "readCO2": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x5A",
            "operatingMode": "1"
          },
          "meta": {
            "editorX": 164.3333740234375,
            "editorY": 455,
            "lastTrigger": "TVOCRead"
          },
          "triggers": {
            "triggered": [],
            "TVOCRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQualityCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetAirQualityStr",
                "targetAbility": "trigger"
              }
            ],
            "CO2Read": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTVOC": false,
            "readCO2": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTVOC",
              "triggers": [
                "TVOCRead"
              ]
            },
            {
              "name": "readCO2",
              "triggers": [
                "CO2Read"
              ]
            }
          ]
        },
        {
          "name": "SX9500Touch1",
          "type": "EmbeddedSX9500",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(SX9500Touch1, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(SX9500Touch1, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(SX9500Touch1, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(SX9500Touch1, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(SX9500Touch1, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(SX9500Touch1, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(SX9500Touch1, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(SX9500Touch1, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(SX9500Touch1, pressRight));\n\treturn ATMO_Status_Success;",
              "getTouchData": "",
              "pressUp": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressDown": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressLeft": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressRight": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "getTouchData": false,
              "pressUp": false,
              "pressDown": false,
              "pressLeft": false,
              "pressRight": false
            },
            "i2cInstance": 1,
            "gpioInstance": 0,
            "interruptEnabled": true,
            "interruptGpio": "PTA9",
            "i2cAddress": "0x28"
          },
          "meta": {
            "editorX": 101.3333740234375,
            "editorY": 758,
            "lastTrigger": "rightPressed"
          },
          "triggers": {
            "triggered": [],
            "touchDataRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightHigh"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController1",
                "targetAbility": "navigateRight"
              }
            ],
            "upPressed": [],
            "downPressed": [],
            "leftPressed": [],
            "rightPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController1",
                "targetAbility": "navigateRight"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightHigh"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "getTouchData": false,
            "pressUp": false,
            "pressDown": false,
            "pressLeft": false,
            "pressRight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "getTouchData",
              "triggers": [
                "touchDataRead"
              ]
            },
            {
              "name": "pressUp",
              "triggers": [
                "upPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressDown",
              "triggers": [
                "downPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressLeft",
              "triggers": [
                "leftPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressRight",
              "triggers": [
                "rightPressed",
                "touchDataRead"
              ]
            }
          ]
        },
        {
          "name": "Interval1",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval1, instance), \n\t\tATMO_ABILITY(Interval1, interval), \n\t\tATMO_PROPERTY(Interval1, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": 0,
            "time": "15000"
          },
          "meta": {
            "editorX": 98.3333740234375,
            "editorY": 839,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightOff"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkBacklight",
          "type": "EmbeddedNxpRpkBacklight",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    Backlight_SetLevel(ATMO_PROPERTY(EmbeddedNxpRpkBacklight, initialSetting));\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightOff": "\n    Backlight_SetLevel(BLIGHT_LEVEL_OFF);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightLow": "\n    Backlight_SetLevel(BLIGHT_LEVEL_LOW);\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightMedium": "\n    Backlight_SetLevel(BLIGHT_LEVEL_MEDIUM);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightHigh": "\n    Backlight_SetLevel(BLIGHT_LEVEL_HIGH);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setBacklightOff": false,
              "setBacklightLow": false,
              "setBacklightMedium": false,
              "setBacklightHigh": false
            },
            "initialSetting": "BLIGHT_LEVEL_LOW"
          },
          "meta": {
            "editorX": 300.3333740234375,
            "editorY": 835,
            "lastTrigger": "backlightSet"
          },
          "triggers": {
            "triggered": [],
            "backlightSet": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setBacklightOff": false,
            "setBacklightLow": false,
            "setBacklightMedium": false,
            "setBacklightHigh": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setBacklightOff",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightLow",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightMedium",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightHigh",
              "triggers": [
                "backlightSet"
              ]
            }
          ]
        },
        {
          "name": "BLEConnection",
          "type": "EmbeddedBLEConnection",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_PairingCfg_t pairingCfg;\n\tpairingCfg.pairingKey = ATMO_PROPERTY(BLEConnection, pairingKey);\n\tpairingCfg.type = ATMO_PROPERTY(BLEConnection, pairingType);\n\tATMO_BLE_GAPPairingCfg(ATMO_PROPERTY(BLEConnection, instance), &pairingCfg);\n\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_Connected, ATMO_ABILITY(BLEConnection, connected));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_Disconnected, ATMO_ABILITY(BLEConnection, disconnected));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_PairingRequested, ATMO_ABILITY(BLEConnection, pairingRequested));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_PairingSuccess, ATMO_ABILITY(BLEConnection, pairingSucceeded));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_PairingFailed, ATMO_ABILITY(BLEConnection, pairingFailed));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "disconnect": "\n\tATMO_BLE_GAPDisconnect(ATMO_PROPERTY(BLEConnection, instance));\n\treturn ATMO_Status_Success;\n\t",
              "connected": "\n\treturn ATMO_Status_Success;\n\t",
              "disconnected": "\n\treturn ATMO_Status_Success;\n\t",
              "pairingRequested": "\n\tATMO_CreateValueCopy(out, in);\n\treturn ATMO_Status_Success;\n\t",
              "pairingSucceeded": "\n\treturn ATMO_Status_Success;\n\t",
              "pairingFailed": "\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "disconnect": false,
              "connected": false,
              "disconnected": false,
              "pairingRequested": false,
              "pairingSucceeded": false,
              "pairingFailed": false
            },
            "instance": 0,
            "pairingType": "ATMO_BLE_PairingType_RandomKey",
            "pairingKey": "123456"
          },
          "meta": {
            "editorX": 47.3333740234375,
            "editorY": 967,
            "lastTrigger": "pairingRequested"
          },
          "triggers": {
            "triggered": [],
            "connected": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PairingCode",
                "targetAbility": "setLabel"
              }
            ],
            "disconnected": [],
            "pairingRequested": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PairingCode",
                "targetAbility": "setLabel"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PairingCode",
                "targetAbility": "displayPage"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PairingSuccess",
                "targetAbility": "setLabel"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "PairingFail",
                "targetAbility": "setLabel"
              }
            ],
            "pairingSucceeded": [],
            "pairingFailed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "disconnect": false,
            "connected": false,
            "disconnected": false,
            "pairingRequested": false,
            "pairingSucceeded": false,
            "pairingFailed": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "disconnect",
              "triggers": []
            },
            {
              "name": "connected",
              "triggers": [
                "connected"
              ]
            },
            {
              "name": "disconnected",
              "triggers": [
                "disconnected"
              ]
            },
            {
              "name": "pairingRequested",
              "triggers": [
                "pairingRequested"
              ]
            },
            {
              "name": "pairingSucceeded",
              "triggers": [
                "pairingSucceeded"
              ]
            },
            {
              "name": "pairingFailed",
              "triggers": [
                "pairingFailed"
              ]
            }
          ]
        },
        {
          "name": "PairingCode",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(PairingCode, x), ATMO_PROPERTY(PairingCode, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(PairingCode, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(PairingCode, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(PairingCode, topRightButtonEnabled),\n    ATMO_PROPERTY(PairingCode,bottomRightButtonEnabled), ATMO_PROPERTY(PairingCode, topLeftButtonEnabled), ATMO_PROPERTY(PairingCode, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(PairingCode, x);\n    config.x = ATMO_PROPERTY(PairingCode, x);\n    config.y = ATMO_PROPERTY(PairingCode, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(PairingCode, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(PairingCode, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(PairingCode, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(PairingCode, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(PairingCode, spanX);\n\tconfig.spanY = ATMO_PROPERTY(PairingCode, spanY);\n    config.title = ATMO_PROPERTY(PairingCode, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(PairingCode, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(PairingCode, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(PairingCode, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(PairingCode, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(PairingCode,pageHandle), ATMO_ABILITY(PairingCode, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingCode,pageHandle), 1, ATMO_ABILITY(PairingCode, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingCode,pageHandle), 2, ATMO_ABILITY(PairingCode, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingCode,pageHandle), 3, ATMO_ABILITY(PairingCode, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingCode,pageHandle), 4, ATMO_ABILITY(PairingCode, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(PairingCode, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(PairingCode,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "displayPage": false,
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Pairing Code",
            "titleHidden": false,
            "pageHidden": true,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "-20",
            "y": "-1",
            "spanX": "1",
            "spanY": "1",
            "icon": "icon_settings_bluetooth",
            "label": "N/A"
          },
          "meta": {
            "editorX": 228.3333740234375,
            "editorY": 913,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "PairingFail",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(PairingFail, x), ATMO_PROPERTY(PairingFail, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(PairingFail, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(PairingFail, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(PairingFail, topRightButtonEnabled),\n    ATMO_PROPERTY(PairingFail,bottomRightButtonEnabled), ATMO_PROPERTY(PairingFail, topLeftButtonEnabled), ATMO_PROPERTY(PairingFail, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(PairingFail, x);\n    config.x = ATMO_PROPERTY(PairingFail, x);\n    config.y = ATMO_PROPERTY(PairingFail, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(PairingFail, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(PairingFail, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(PairingFail, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(PairingFail, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(PairingFail, spanX);\n\tconfig.spanY = ATMO_PROPERTY(PairingFail, spanY);\n    config.title = ATMO_PROPERTY(PairingFail, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(PairingFail, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(PairingFail, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(PairingFail, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(PairingFail, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(PairingFail,pageHandle), ATMO_ABILITY(PairingFail, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingFail,pageHandle), 1, ATMO_ABILITY(PairingFail, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingFail,pageHandle), 2, ATMO_ABILITY(PairingFail, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingFail,pageHandle), 3, ATMO_ABILITY(PairingFail, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingFail,pageHandle), 4, ATMO_ABILITY(PairingFail, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(PairingFail, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(PairingFail,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "displayPage": false,
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "",
            "titleHidden": true,
            "pageHidden": true,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "-18",
            "y": "-1",
            "spanX": "1",
            "spanY": "1",
            "icon": "icon_settings_bluetooth",
            "label": "Pairing Failed!"
          },
          "meta": {
            "editorX": 229.3333740234375,
            "editorY": 1089,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "PairingSuccess",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(PairingSuccess, x), ATMO_PROPERTY(PairingSuccess, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(PairingSuccess, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(PairingSuccess, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(PairingSuccess, topRightButtonEnabled),\n    ATMO_PROPERTY(PairingSuccess,bottomRightButtonEnabled), ATMO_PROPERTY(PairingSuccess, topLeftButtonEnabled), ATMO_PROPERTY(PairingSuccess, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(PairingSuccess, x);\n    config.x = ATMO_PROPERTY(PairingSuccess, x);\n    config.y = ATMO_PROPERTY(PairingSuccess, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(PairingSuccess, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(PairingSuccess, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(PairingSuccess, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(PairingSuccess, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(PairingSuccess, spanX);\n\tconfig.spanY = ATMO_PROPERTY(PairingSuccess, spanY);\n    config.title = ATMO_PROPERTY(PairingSuccess, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(PairingSuccess, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(PairingSuccess, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(PairingSuccess, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(PairingSuccess, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(PairingSuccess,pageHandle), ATMO_ABILITY(PairingSuccess, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingSuccess,pageHandle), 1, ATMO_ABILITY(PairingSuccess, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingSuccess,pageHandle), 2, ATMO_ABILITY(PairingSuccess, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingSuccess,pageHandle), 3, ATMO_ABILITY(PairingSuccess, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(PairingSuccess,pageHandle), 4, ATMO_ABILITY(PairingSuccess, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(PairingSuccess, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(PairingSuccess,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "displayPage": false,
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "",
            "titleHidden": true,
            "pageHidden": true,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "-19",
            "y": "-1",
            "spanX": "1",
            "spanY": "1",
            "icon": "icon_settings_bluetooth",
            "label": "Pairing Successful!"
          },
          "meta": {
            "editorX": 229.3333740234375,
            "editorY": 997,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "EmbeddedPageController1",
          "type": "EmbeddedPageController",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_UI_PAGE_CONTROLLER_Config_t config;\n\tconfig.enableUpDownNavLabels = ATMO_PROPERTY(EmbeddedPageController1, upDownNavigationLabelsEnabled);\n\tconfig.enableLeftRightNavLabels = ATMO_PROPERTY(EmbeddedPageController1, leftRightNavigationLabelsEnabled);\n\tATMO_UI_Page_SetConfiguration(&config);\n    return ATMO_Status_Success;\n\t",
              "displayRootPage": "\n\t\n\tATMO_UI_Page_DisplayRootPage();\n\treturn ATMO_Status_Success;\n\t",
              "navigateUp": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_UP);\n\treturn ATMO_Status_Success;\n\t",
              "navigateDown": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_DOWN);\n\treturn ATMO_Status_Success;\n\t",
              "navigateLeft": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_LEFT);\n\treturn ATMO_Status_Success;\n\t",
              "navigateRight": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_RIGHT);\n\treturn ATMO_Status_Success;\n\t",
              "processTopRightButton": "\n\tATMO_UI_Page_ProcessUserButton(1);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomRightButton": "\n\tATMO_UI_Page_ProcessUserButton(2);\n\treturn ATMO_Status_Success;\n\t",
              "processTopLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(3);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(4);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "displayRootPage": false,
              "navigateUp": false,
              "navigateDown": false,
              "navigateLeft": false,
              "navigateRight": false,
              "processTopRightButton": false,
              "processBottomRightButton": false,
              "processTopLeftButton": false,
              "processBottomLeftButton": false
            },
            "upDownNavigationLabelsEnabled": true,
            "leftRightNavigationLabelsEnabled": false
          },
          "meta": {
            "editorX": 303.3333740234375,
            "editorY": 736,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "navigateUp": [],
            "navigateDown": [],
            "navigateLeft": [],
            "navigateRight": [],
            "processTopRightButton": [],
            "processBottomRightButton": [],
            "processTopLeftButton": [],
            "processBottomLeftButton": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "displayRootPage": false,
            "navigateUp": false,
            "navigateDown": false,
            "navigateLeft": false,
            "navigateRight": false,
            "processTopRightButton": false,
            "processBottomRightButton": false,
            "processTopLeftButton": false,
            "processBottomLeftButton": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "displayRootPage",
              "triggers": []
            },
            {
              "name": "navigateUp",
              "triggers": [
                "navigateUp"
              ]
            },
            {
              "name": "navigateDown",
              "triggers": [
                "navigateDown"
              ]
            },
            {
              "name": "navigateLeft",
              "triggers": [
                "navigateLeft"
              ]
            },
            {
              "name": "navigateRight",
              "triggers": [
                "navigateRight"
              ]
            },
            {
              "name": "processTopRightButton",
              "triggers": [
                "processTopRightButton"
              ]
            },
            {
              "name": "processBottomRightButton",
              "triggers": [
                "processBottomRightButton"
              ]
            },
            {
              "name": "processTopLeftButton",
              "triggers": [
                "processTopLeftButton"
              ]
            },
            {
              "name": "processBottomLeftButton",
              "triggers": [
                "processBottomLeftButton"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedSystemStatusDisplay",
          "type": "EmbeddedSystemStatusDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(EmbeddedSystemStatusDisplay, x), ATMO_PROPERTY(EmbeddedSystemStatusDisplay, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n    config.hidden = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, pageHidden);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(EmbeddedSystemStatusDisplay, topRightButtonEnabled),\n    ATMO_PROPERTY(EmbeddedSystemStatusDisplay,bottomRightButtonEnabled), ATMO_PROPERTY(EmbeddedSystemStatusDisplay, topLeftButtonEnabled), ATMO_PROPERTY(EmbeddedSystemStatusDisplay, bottomLeftButtonEnabled));\n    config.x = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, x);\n    config.y = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(EmbeddedSystemStatusDisplay, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(EmbeddedSystemStatusDisplay, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(EmbeddedSystemStatusDisplay, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(EmbeddedSystemStatusDisplay, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, spanX);\n\tconfig.spanY = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, spanY);\n    config.title = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(EmbeddedSystemStatusDisplay, titleHidden);\n    ATMO_UI_SYSTEMSTATUS_Init(&config);\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string"
            },
            "codeUserChanged": {
              "displayPage": false,
              "onDisplayed": false,
              "setup": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Remote Monitor",
            "titleHidden": true,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "-20",
            "y": 0,
            "spanX": "200",
            "spanY": 1
          },
          "meta": {
            "editorX": 450.16668701171875,
            "editorY": 742,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "setup": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            }
          ]
        },
        {
          "name": "Settings",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(Settings, x), ATMO_PROPERTY(Settings, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(Settings, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(Settings, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(Settings, topRightButtonEnabled),\n    ATMO_PROPERTY(Settings,bottomRightButtonEnabled), ATMO_PROPERTY(Settings, topLeftButtonEnabled), ATMO_PROPERTY(Settings, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(Settings, x);\n    config.x = ATMO_PROPERTY(Settings, x);\n    config.y = ATMO_PROPERTY(Settings, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(Settings, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(Settings, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(Settings, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(Settings, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(Settings, spanX);\n\tconfig.spanY = ATMO_PROPERTY(Settings, spanY);\n    config.title = ATMO_PROPERTY(Settings, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(Settings, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(Settings, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(Settings, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(Settings, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(Settings,pageHandle), ATMO_ABILITY(Settings, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Settings,pageHandle), 1, ATMO_ABILITY(Settings, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Settings,pageHandle), 2, ATMO_ABILITY(Settings, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Settings,pageHandle), 3, ATMO_ABILITY(Settings, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Settings,pageHandle), 4, ATMO_ABILITY(Settings, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(Settings, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(Settings,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "displayPage": false,
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_RED",
            "pageTitle": "Settings",
            "titleHidden": true,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": 0,
            "y": "1",
            "spanX": "20",
            "spanY": 1,
            "icon": "icon_settings",
            "label": "Settings"
          },
          "meta": {
            "editorX": 447.16668701171875,
            "editorY": 846,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "FXOS8700AccelerometerMagnetometer",
          "type": "EmbeddedFXOS8700",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_FXOS8700_Config_t config;\n\tconfig.address = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, gpioInstance);\n\tconfig.int1En = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, interrupt1Enabled);\n    config.int2En = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, interrupt2Enabled);\n    config.int1Pin = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, interrupt1Gpio);\n    config.int2Pin = ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, interrupt2Gpio);\n\n    switch(ATMO_PROPERTY(FXOS8700AccelerometerMagnetometer, motionDetectType))\n    {\n        case FXOS8700_NoDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_FreefallDetect:\n        {\n            config.freefallEnabled = true;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_MotionDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = true;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_TapDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = true;\n            break; \n        }\n        default:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;  \n            config.tapDetectionEnabled = false;\n            break;\n        }\n    }\n\n    ATMO_FXOS8700_SetMotionDetectedAbilityHandle(ATMO_ABILITY(FXOS8700AccelerometerMagnetometer, detectMotion));\n    ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(ATMO_ABILITY(FXOS8700AccelerometerMagnetometer, detectFreefall));\n    ATMO_FXOS8700_SetTapDetectedAbilityHandle(ATMO_ABILITY(FXOS8700AccelerometerMagnetometer, detectTap));\n\tATMO_FXOS8700_Init(&config);\n\n    return ATMO_Status_Success;\n\t",
              "setEnabled": "ATMO_FXOS8700_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_FXOS8700_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_FXOS8700_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "getAccelData": "    ATMO_3dFloatVector_t data;\r\n\r\n    if( ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success )\r\n    {\r\n        ATMO_CreateValueVoid(out);\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &data);\r\n\r\n    return ATMO_Status_Success;",
              "getAccelX": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.x);\n\treturn ATMO_Status_Success;\n",
              "getAccelY": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.y);\n\treturn ATMO_Status_Success;\n",
              "getAccelZ": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.z);\n\treturn ATMO_Status_Success;\n",
              "getMagData": "    ATMO_3dFloatVector_t data;\r\n\r\n    if( ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success )\r\n    {\r\n        ATMO_CreateValueVoid(out);\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &data);\r\n\r\n    return ATMO_Status_Success;",
              "getMagX": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.x);\n\treturn ATMO_Status_Success;\n",
              "getMagY": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.y);\n\treturn ATMO_Status_Success;\n",
              "getMagZ": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.z);\n\treturn ATMO_Status_Success;\n",
              "detectTap": "\treturn ATMO_Status_Success;\n",
              "detectMotion": "\treturn ATMO_Status_Success;\n",
              "detectFreefall": "\treturn ATMO_Status_Success;\n",
              "enableFreefallDetection": "if(ATMO_FXOS8700_EnableFreefallDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;",
              "enableMotionDetection": "if(ATMO_FXOS8700_EnableMotionDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;",
              "enableTapDetection": "if(ATMO_FXOS8700_EnableTapDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;",
              "disableDetection": "if(ATMO_FXOS8700_DisableAllDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "getAccelData": false,
              "getAccelX": false,
              "getAccelY": false,
              "getAccelZ": false,
              "getMagData": false,
              "getMagX": false,
              "getMagY": false,
              "getMagZ": false,
              "detectTap": false,
              "detectMotion": false,
              "detectFreefall": false,
              "enableFreefallDetection": false,
              "enableMotionDetection": false,
              "enableTapDetection": false,
              "disableDetection": false
            },
            "i2cInstance": 1,
            "gpioInstance": 0,
            "interrupt1Enabled": false,
            "interrupt2Enabled": true,
            "interrupt1Gpio": "ATMO_DEFAULT_GPIO",
            "interrupt2Gpio": "PTD13",
            "motionDetectType": "FXOS8700_NoDetect",
            "i2cAddress": "0x1E"
          },
          "meta": {
            "editorX": 165.16668701171875,
            "editorY": 595,
            "lastTrigger": "accelDataRead"
          },
          "triggers": {
            "triggered": [],
            "accelDataRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "VibrationCharacteristic",
                "targetAbility": "setValue"
              }
            ],
            "accelXRead": [],
            "accelYRead": [],
            "accelZRead": [],
            "magDataRead": [],
            "magXRead": [],
            "magYRead": [],
            "magZRead": [],
            "tapDetected": [],
            "motionDetected": [],
            "freefallDetected": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "getAccelData": false,
            "getAccelX": false,
            "getAccelY": false,
            "getAccelZ": false,
            "getMagData": false,
            "getMagX": false,
            "getMagY": false,
            "getMagZ": false,
            "detectTap": false,
            "detectMotion": false,
            "detectFreefall": false,
            "enableFreefallDetection": false,
            "enableMotionDetection": false,
            "enableTapDetection": false,
            "disableDetection": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "getAccelData",
              "triggers": [
                "accelDataRead"
              ]
            },
            {
              "name": "getAccelX",
              "triggers": [
                "accelXRead"
              ]
            },
            {
              "name": "getAccelY",
              "triggers": [
                "accelYRead"
              ]
            },
            {
              "name": "getAccelZ",
              "triggers": [
                "accelZRead"
              ]
            },
            {
              "name": "getMagData",
              "triggers": [
                "magDataRead"
              ]
            },
            {
              "name": "getMagX",
              "triggers": [
                "magXRead"
              ]
            },
            {
              "name": "getMagY",
              "triggers": [
                "magYRead"
              ]
            },
            {
              "name": "getMagZ",
              "triggers": [
                "magZRead"
              ]
            },
            {
              "name": "detectTap",
              "triggers": [
                "tapDetected"
              ]
            },
            {
              "name": "detectMotion",
              "triggers": [
                "motionDetected"
              ]
            },
            {
              "name": "detectFreefall",
              "triggers": [
                "freefallDetected"
              ]
            },
            {
              "name": "enableFreefallDetection",
              "triggers": []
            },
            {
              "name": "enableMotionDetection",
              "triggers": []
            },
            {
              "name": "enableTapDetection",
              "triggers": []
            },
            {
              "name": "disableDetection",
              "triggers": []
            }
          ]
        },
        {
          "name": "VibrationCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\t&ATMO_VARIABLE(VibrationCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(VibrationCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(VibrationCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(VibrationCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(VibrationCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(VibrationCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(VibrationCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(VibrationCharacteristic, writeDataType), ATMO_PROPERTY(VibrationCharacteristic, readDataType), ATMO_PROPERTY(VibrationCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\t&ATMO_VARIABLE(VibrationCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(VibrationCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(VibrationCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\tATMO_VARIABLE(VibrationCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(VibrationCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(VibrationCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\tATMO_VARIABLE(VibrationCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(VibrationCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "0",
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f5",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 353.16668701171875,
            "editorY": 597,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkUserButtons",
          "type": "EmbeddedNxpRpkUserButtons",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    ATMO_MK64F_GPIO_EnableResetCombo(ATMO_PROPERTY(EmbeddedNxpRpkUserButtons, enableResetCombo));\n    ATMO_MK64F_GPIO_EnableDisplayToggleCombo(ATMO_PROPERTY(EmbeddedNxpRpkUserButtons, enableDisplayToggleCombo));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW1_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, topRightPushed));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW2_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, bottomRightPushed));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW3_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, topLeftPushed));\n    ATMO_MK64F_UserButton_RegisterAbilityHandle(ATMO_MK64F_SW4_Pushed, ATMO_ABILITY(EmbeddedNxpRpkUserButtons, bottomLeftPushed));\n\treturn ATMO_Status_Success;\n\t",
              "topRightPushed": "\n\treturn ATMO_Status_Success;\n    ",
              "bottomRightPushed": "\n\treturn ATMO_Status_Success;\n    ",
              "topLeftPushed": "\n\treturn ATMO_Status_Success;\n    ",
              "bottomLeftPushed": "\n\treturn ATMO_Status_Success;\n    "
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "topRightPushed": false,
              "bottomRightPushed": false,
              "topLeftPushed": false,
              "bottomLeftPushed": false
            },
            "enableResetCombo": true,
            "enableDisplayToggleCombo": true
          },
          "meta": {
            "editorX": 102.3333740234375,
            "editorY": 683,
            "lastTrigger": "bottomLeftPushed"
          },
          "triggers": {
            "triggered": [],
            "topRightPushed": [],
            "bottomRightPushed": [],
            "topLeftPushed": [],
            "bottomLeftPushed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController1",
                "targetAbility": "processBottomLeftButton"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "topRightPushed": false,
            "bottomRightPushed": false,
            "topLeftPushed": false,
            "bottomLeftPushed": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "topRightPushed",
              "triggers": [
                "topRightPushed"
              ]
            },
            {
              "name": "bottomRightPushed",
              "triggers": [
                "bottomRightPushed"
              ]
            },
            {
              "name": "topLeftPushed",
              "triggers": [
                "topLeftPushed"
              ]
            },
            {
              "name": "bottomLeftPushed",
              "triggers": [
                "bottomLeftPushed"
              ]
            }
          ]
        }
      ],
      "libraries": {
        "sx9500": {
          "libName": "sx9500",
          "manufacturer": "Semtech",
          "description": "SX9500 Capacitive Touch Sensor",
          "type": "Touch Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "gpio"
          ],
          "elements": [
            {
              "name": "SX9500Touch",
              "type": "EmbeddedSX9500",
              "icon": "EmbeddedTouch.svg",
              "defaultAbility": "getTouchData",
              "defaultTrigger": "touchDataRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "code": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(undefined, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(undefined, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(undefined, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(undefined, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(undefined, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(undefined, pressRight));\n\treturn ATMO_Status_Success;"
                },
                {
                  "name": "getTouchData",
                  "triggers": [
                    "touchDataRead"
                  ],
                  "code": ""
                },
                {
                  "name": "pressUp",
                  "triggers": [
                    "upPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressDown",
                  "triggers": [
                    "downPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressLeft",
                  "triggers": [
                    "leftPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressRight",
                  "triggers": [
                    "rightPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interruptEnabled",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "interruptGpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x28"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedSX9500": "SX9500 Touch Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "interruptGpio": "Interrupt GPIO Pin",
                  "interruptEnabled": "Touch Interrupt Enabled",
                  "gpioInstance": "GPIO Driver Instance",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "getTouchData": "Get Current Touch Data",
                  "touchDataRead": "Touch Data Read",
                  "pressUp": "Press Up",
                  "upPressed": "Up Pressed",
                  "pressDown": "Press Down",
                  "downPressed": "Down Pressed",
                  "pressLeft": "Press Left",
                  "leftPressed": "Left Pressed",
                  "pressRight": "Press Right",
                  "rightPressed": "Right Pressed"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "sx9500.h": "#ifndef __ATMO_SX9500_H_\n#define __ATMO_SX9500_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n#include \"../gpio/gpio.h\"\n\ntypedef enum {\n    ATMO_SX9500_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_SX9500_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_SX9500_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_SX9500_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_SX9500_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_SX9500_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    bool interruptEnabled;\n    ATMO_GPIO_Device_Pin_t interruptPin;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    ATMO_DriverInstanceHandle_t gpioDriverInstance;\n} ATMO_SX9500_Config_t;\n\ntypedef struct {\n\tbool downPressed;\n\tbool upPressed;\n\tbool leftPressed;\n\tbool rightPressed;\n} SX9500_TouchState_t;\n\ntypedef enum {\n\tSX9500_Touched_Any = 0,\n\tSX9500_Touched_Down,\n\tSX9500_Touched_Right,\n\tSX9500_Touched_Up,\n\tSX9500_Touched_Left,\n\tSX9500_Touched_NumEvents,\n} SX9500_TouchEvent_t;\n\n\n/**\n * Initialize SX9500 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config);\n\n/**\n * Get current touch sensor state\n *\n * @param[out] touchState\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState);\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle);\n\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb);\n\n\n#endif\n\n",
                "sx9500_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.h\n * This is the header file for the SX9500 touch controller driver.\n */\n\n#ifndef SX9500_INTERNAL_H_\n#define SX9500_INTERNAL_H_\n\n/*!\n * @addtogroup sx9500 SX9500 touch controller API\n * @{\n */\n\n#include \"../app_src/atmosphere_platform.h\"\n\n\n#define SX9500_I2C_ADDRESS                          0x28\n\n#define SX9500_REG_IRQSRC                           0x00\n#define SX9500_REG_STAT                             0x01\n#define SX9500_REG_IRQMSK                           0x03\n#define SX9500_REG_PROXCTRL0                        0x06\n#define SX9500_REG_PROXCTRL1                        0x07\n#define SX9500_REG_PROXCTRL2                        0x08\n#define SX9500_REG_PROXCTRL3                        0x09\n#define SX9500_REG_PROXCTRL4                        0x0A\n#define SX9500_REG_PROXCTRL5                        0x0B\n#define SX9500_REG_PROXCTRL6                        0x0C\n#define SX9500_REG_PROXCTRL7                        0x0D\n#define SX9500_REG_PROXCTRL8                        0x0E\n#define SX9500_REG_SENSORSEL                        0x20\n#define SX9500_REG_USEMSB                           0x21\n#define SX9500_REG_USELSB                           0x22\n#define SX9500_REG_AVGMSB                           0x23\n#define SX9500_REG_AVGLSB                           0x24\n#define SX9500_REG_DIFFMSB                          0x25\n#define SX9500_REG_DIFFLSB                          0x26\n#define SX9500_REG_OFFSETMSB                        0x27\n#define SX9500_REG_OFFSETLSB                        0x28\n#define SX9500_REG_RESET                            0x7F\n \n#define SX9500_RESET_CMD                            0xDE\n \n/*! @brief Status return codes. */\ntypedef enum\n{\n    SX9500_SUCCESS,\n    SX9500_I2C_ERROR,\n    SX9500_INTERNAL_ERROR,\n\tSX9500_NOINIT_ERROR\n} SX9500_status;\n\ntypedef union {\n    struct {    // sx9500 register 0x00\n        uint8_t txen_stat   : 1;    // 0\n        uint8_t reserved    : 2;    // 1,2\n        uint8_t conv_done   : 1;    // 3\n        uint8_t comp_done   : 1;    // 4\n        uint8_t far         : 1;    // 5\n        uint8_t close       : 1;    // 6\n        uint8_t reset       : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegIrqSrc_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x01\n        uint8_t compstat         : 4;    // 0,1,2,3\n        uint8_t proxstat0        : 1;    // 4\n        uint8_t proxstat1        : 1;    // 5\n        uint8_t proxstat2        : 1;    // 6\n        uint8_t proxstat3        : 1;    // 7\n   } bits;\n    uint8_t octet;\n} RegStat_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x06\n        uint8_t sensor_en   : 4;    // 0,1,2,3\n        uint8_t scan_period : 3;    // 4,5,6\n        uint8_t reserved    : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl0_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x09\n        uint8_t raw_filt    : 2;    // 0,1\n        uint8_t reserved    : 2;    // 2,3\n        uint8_t doze_period : 2;    // 4,5\n        uint8_t doze_en     : 1;    // 6\n        uint8_t res7        : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl3_t;\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _sx9500_fct_t\n{\n\t/** Read hardware function */\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\n    /** Write hardware register, 8bit aligned function */\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\n    /** Wait function **/\n    void (*WaitMs)(uint32_t tms);\n} sx9500_fct_t, *ptsx9500_fct_t;\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize SX9500 driver.\n *\n * @param FCT Pointer to a structure with external functions\n */\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT);\n\n/*!\n * @brief De-initialize SX9500 driver.\n *\n */\nvoid SX9500_Deinit_Driver();\n\n/*!\n * @brief Initialize SX9500 hardware.\n *\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_Init_Hw();\n\n/*!\n * @brief Get information for selected sensor.\n *\n * @param  CSn Selected sensor (0-3)\n * @param  buf Pointer to an array with PROXUSEFUL/PROXAVG/PROXDIFF values\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf);\n\n/*!\n * @brief Get power mode.\n *\n * @return Power mode: active (true/1) or low power (false/0)\n */\nbool SX9500_get_active();\n\n/*!\n * @brief Set power mode.\n *\n * @param  bool Power mode: active (true/1) or low power (false/0)\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_set_active(bool);\n\n/*!\n * @brief Function returning the triggered capacitive sensing interface.\n * @note Returns 0xFF if no interface has been triggered.\n *\n * @param  CSi Pointer to sensing interface index\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi);\n\n/*!\n * @brief Read IRQ Source\n * @note  Used to clear interrupts on SX9500\n *\n * @param irqReg Pointer to store value from IRQ register\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg);\n\n/*!\n * @brief Read Proximity Sensors\n *\n * @param data Pointer to store data from proximity sensor data\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data);\n\n/*! @}*/\n\n#endif\n"
              },
              "objects": {
                "sx9500.c": "#include \"sx9500.h\"\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_SX9500_Config_t config;\n    unsigned int abilityHandle[SX9500_Touched_NumEvents];\n\tbool abilityHandleRegistered[SX9500_Touched_NumEvents];\n    ATMO_Callback_t callback[SX9500_Touched_NumEvents];\n    bool configured;\n} ATMO_SX9500_Priv_Config;\n\nstatic ATMO_SX9500_Priv_Config _ATMO_SX9500_config = {0};\n\nstatic ATMO_I2C_Peripheral_t _ATMO_SX9500_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic uint8_t _ATMO_SX9500_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t _ATMO_SX9500_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic bool ATMO_SX9500_TouchStateToIndex(SX9500_TouchState_t *touchState, uint32_t *index)\n{\n\tbool anyPressed = false;\n\n\tif(touchState->downPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Down;\n\t}\n\tif(touchState->upPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Up;\n\t}\n\tif(touchState->rightPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Right;\n\t}\n\tif(touchState->leftPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Left;\n\t}\n\n\treturn anyPressed;\n}\n\nstatic void ATMO_SX9500_Callback(void *data)\n{\n    RegIrqSrc_t irq;\n    if (SX9500_Read_Irq(&irq.octet) == SX9500_SUCCESS)\n    {\n        if (irq.bits.close || irq.bits.far)\n        {\n        \tSX9500_TouchState_t touchState;\n        \tif(ATMO_SX9500_GetTouchState(&touchState) == ATMO_SX9500_Status_Success)\n        \t{\n        \t\tuint32_t index = 0;\n        \t\tif(ATMO_SX9500_TouchStateToIndex(&touchState, &index))\n        \t\t{\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[SX9500_Touched_Any] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[SX9500_Touched_Any], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[index] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[index], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.callback[SX9500_Touched_Any] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[SX9500_Touched_Any](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t\tif(_ATMO_SX9500_config.callback[index] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[index](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t}\n        \t}\n        \telse\n        \t{\n        \t\treturn ATMO_SX9500_Status_Fail;\n        \t}\n        }\n    }\n    else\n    {\n    \treturn ATMO_SX9500_Status_Fail;\n    }\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_SX9500_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_SX9500_config.configured = false;\n    }\n\n\tsx9500_fct_t fct;\n\tfct.I2C_Read = _ATMO_SX9500_I2CRead_Simple;\n\tfct.I2C_Write = _ATMO_SX9500_I2CWrite_Simple;\n\tfct.WaitMs = ATMO_PLATFORM_DelayMilliseconds;\n\tSX9500_Init_Driver(&fct);\n\tSX9500_Init_Hw();\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_SX9500_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    // Register interrupt\n    if(config->interruptEnabled)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->interruptPin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_SX9500_Callback);\n    }\n\n    memcpy( &_ATMO_SX9500_config.config, config, sizeof(ATMO_SX9500_Config_t) );\n    _ATMO_SX9500_config.configured = true;\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL || !_ATMO_SX9500_config.configured )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_SX9500_config.config, sizeof(ATMO_SX9500_Config_t));\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState)\n{\n\tmemset(touchState, 0, sizeof(SX9500_TouchState_t));\n\n\tRegStat_t dir;\n\tif( SX9500_Read_Proximity_Sensors(&dir.octet) != SX9500_SUCCESS )\n\t{\n\t\treturn ATMO_SX9500_Status_Fail;\n\t}\n\n\tif(dir.octet > 0)\n\t{\n\t\tif(dir.bits.proxstat0)\n\t\t{\n\t\t\ttouchState->downPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat1)\n\t\t{\n\t\t\ttouchState->rightPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat2)\n\t\t{\n\t\t\ttouchState->upPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat3)\n\t\t{\n\t\t\ttouchState->leftPressed = true;\n\t\t}\n\t}\n\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle)\n{\n\t_ATMO_SX9500_config.abilityHandle[event] = abilityHandle;\n\t_ATMO_SX9500_config.abilityHandleRegistered[event] = true;\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb)\n{\n\t_ATMO_SX9500_config.callback[event] = cb;\n\treturn ATMO_SX9500_Status_Success;\n}\n\n\n",
                "sx9500_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.c\n * This is the source file for the SX9500 touch controller driver.\n */\n\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic sx9500_fct_t FCT_SX9500;\nstatic bool m_txen;\n\n/* Define registers that need to be initialized to values different than\n * default\n */\ntypedef struct smtc_reg_data {\n    unsigned char reg;\n    unsigned char val;\n}smtc_reg_data_t;\nstatic smtc_reg_data_t sx9500_i2c_reg_setup[] = {\n    {\n        .reg = SX9500_REG_IRQMSK,\n        .val = 0x60,  /* CLOSEIRQEN[6]=1 (close interrupt is on),            */\n                      /* FARIRQEN[5]=1 (far interrupt is on),                */\n                      /* COMPDONEIRQEN[4]=0 (compensation interrupt is off), */\n                      /* CONVDONEIRQEN[3]=0 (conversion interrupt is off)    */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL1,\n        .val = 0x03,  /* SHIELDEN[7:6]=0 (no shield),              */\n                      /* RANGE[1:0]=3 (small, +/-2.5pF Full Scale) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL2,\n        .val = 0x27,  /* GAIN[6:5]=1 (digital gain x2),          */\n                      /* FREQ[4:3]=0 (83kHz sampling frequency), */\n                      /* RESOLUTION[2:0]=0 (finest resolution)   */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL3,\n        .val = 0x41,  /* DOZEEN[6]=1 (enables doze mode),   */\n                      /* DOZEPERIOD[5:4]=0 (2*scan period), */\n                      /* RAWFILT[1:0]=1 (Low)               */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL4,\n        .val = 0x80,  /* AVGTHRESH[7:0]=0x80 (threshold triggering compensation = +/-128*value (typ between 16384 and 24576) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL5,\n        .val = 0x0F,  /* AVGDEB[7:6]=0 (debounce=off),               */\n                      /* AVGNEGFILT[5:3]=1 (lowest negative filter), */\n                      /* AVGPOSFILT[2:0]=7 (highest positive filter) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL6,\n        .val = 0x06,  /* PROXTHRESH[4:0]=6 (sensitivity=120) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL7,\n        .val = 0x00,  /* AVGCOMPDIS[7]=0 (compensation enabled),      */\n                      /* COMPMETHOD[6]=0 (separate CSx compensation), */\n                      /* HYST[5:4]=0 (hysteresis=32),                 */\n                      /* CLOSEDEB[3:2]=0 (close debouncer=off),       */\n                      /* FARDEB[1:0]=0 (far debouncer=off)            */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL8,\n        .val = 0x08,  /* STUCK[7:4]=0 (stuck timeout=off),                          */\n                      /* COMPPRD[3:0]=8 (periodic compensation every 8*128 samples) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL0,\n        .val = 0x0F,  /* SCANPERIOD[6:4]=0 (scan every 30ms),  */\n                      /* SENSOREN[3:0]=15 (enable all sensors) */\n    },\n};\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\nstatic SX9500_status SX9500_write(uint8_t addr, uint8_t data)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    cmd[1] = data;\n\n    return (SX9500_status)FCT_SX9500.I2C_Write(cmd, 2);\n}\n\nstatic SX9500_status SX9500_read(uint8_t addr, uint8_t *dst_buf, uint32_t length)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    return (SX9500_status)FCT_SX9500.I2C_Read(cmd, 1, dst_buf, length);\n}\n\nstatic SX9500_status SX9500_read_single(uint8_t addr, uint8_t* val)\n{\n    return (SX9500_status)FCT_SX9500.I2C_Read(&addr, 1, val, 1);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT)\n{\n    assert((FCT != NULL) &&\n            (FCT->I2C_Read != NULL) &&\n            (FCT->I2C_Write != NULL) &&\n            (FCT->WaitMs != NULL));\n    FCT_SX9500 = *FCT;\n    initDriverDone = true;\n}\n\nvoid SX9500_Denit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        SX9500_set_active(false); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nSX9500_status SX9500_Init_Hw()\n{\n    int i = 0;\n    uint8_t val;\n    SX9500_status status;\n\n    if (!initDriverDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    // perform a soft reset\n    status = SX9500_write(SX9500_REG_RESET, SX9500_RESET_CMD);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    FCT_SX9500.WaitMs(300); // wait until the reset has finished\n\n    // read IRQSRC to release NIRQ pin\n    status = SX9500_read(SX9500_REG_IRQSRC, &val,1);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    // init I2C registers\n    int lenRegTable = sizeof(sx9500_i2c_reg_setup) / sizeof(smtc_reg_data_t);\n    while (i < lenRegTable)\n    {\n        /* Write all registers/values contained in i2c_reg */\n        status = SX9500_write(sx9500_i2c_reg_setup[i].reg, sx9500_i2c_reg_setup[i].val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        /* Read back value from register and verify write */\n        status = SX9500_read_single(sx9500_i2c_reg_setup[i].reg, &val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        if (val != sx9500_i2c_reg_setup[i].val)\n        {\n            return SX9500_INTERNAL_ERROR;\n        }\n\n        i++;\n    }\n\n    initHwDone = true;\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf)\n{\n    SX9500_status status;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(buf != NULL);\n\n    status = SX9500_write(SX9500_REG_SENSORSEL, CSn);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_USEMSB, buf, 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_AVGMSB, &buf[2], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_DIFFMSB, &buf[4], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    return SX9500_SUCCESS;\n}\n\n// get power mode (active or low power)\nbool SX9500_get_active()\n{\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    return m_txen;\n}\n\n// set active mode or low power mode\nSX9500_status SX9500_set_active(bool en)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    m_txen = en;\n\n    uint8_t val = en ? sx9500_i2c_reg_setup[10].val : 0x00U;\n\n    status = SX9500_write(SX9500_REG_PROXCTRL0, val);\n\n    return status;\n}\n\n// returns the triggered capacitive sensing interface (CS0..CS3)\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi)\n{\n    SX9500_status status = SX9500_SUCCESS;\n    RegIrqSrc_t regirq;\n    RegStat_t prox;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(CSi != NULL);\n\n    *CSi = 0xFF;\n\n    status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    if (regirq.bits.close)\n    {\n        if (prox.bits.proxstat0)\n        {\n            *CSi = 0;\n        }\n        else if (prox.bits.proxstat1)\n        {\n            *CSi = 1;\n        }\n        else if (prox.bits.proxstat2)\n        {\n            *CSi = 2;\n        }\n        else if (prox.bits.proxstat3)\n        {\n            *CSi = 3;\n        }\n    }\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != irqReg)\n    {\n        RegIrqSrc_t regirq;\n        status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n        else\n        {\n            *irqReg = regirq.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != data)\n    {\n        RegStat_t prox;\n        status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            *data = 0xFF;\n            return status;\n        }\n        else\n        {\n            *data = prox.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\n"
              }
            }
          }
        },
        "tsl2572": {
          "libName": "tsl2572",
          "manufacturer": "AMS",
          "description": "Ambient Light Sensor",
          "type": "Ambient Light Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "TSL2572AmbientLight",
              "type": "EmbeddedTSL2572",
              "icon": "EmbeddedAmbientLight.svg",
              "defaultAbility": "readAmbientLight",
              "defaultTrigger": "ambientLightRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAmbientLight",
                  "triggers": [
                    "ambientLightRead"
                  ],
                  "code": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x39"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedTSL2572": "TSL2572 Ambient Light Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readAmbientLight": "Read Ambient Light(lux)",
                  "ambientLightRead": "Ambient Light Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "tsl2572.h": "#ifndef __ATMO_TSL2572_H_\r\n#define __ATMO_TSL2572_H_\r\n\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\ntypedef enum {\r\n    ATMO_TSL2572_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_TSL2572_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_TSL2572_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_TSL2572_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_TSL2572_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_TSL2572_Status_t;\r\n\r\ntypedef struct {\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_TSL2572_Config_t;\r\n\r\n\r\n/**\r\n * Initialize TSL2572 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable TSL2572 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of TSL2572 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get ambient light intensity in lux\r\n *\r\n * @param[out] lightLux\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux);\r\n\r\n\r\n#endif\r\n",
                "tsl2572_internal.h": "/*\r\n * tsl2572.h\r\n *\r\n *  Created on: 25 sept. 2017\r\n *      Author: frq05060\r\n */\r\n\r\n#ifndef TSL2572_H_\r\n#define TSL2572_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n//enum tsl2572_status {\r\n//    sensor_success = 0,\r\n//    sensor_I2C_error = 1,\r\n//    sensor_invalid_ID = 2,\r\n//    sensor_wrong_parameter = 3\r\n//};\r\n\r\ntypedef struct _tsl2572_IoFunc_t\r\n{\r\n  uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\r\n  uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\r\n  void         (*WaitMsec)(uint32_t millisec);\r\n} tsl2572_IoFunc_t, *ptsl2572_IoFunc_t;\r\n\r\n/**\r\n * struct tsl2x7x_default_settings - power on defaults unless\r\n *                                   overridden by platform data.\r\n *  @als_time:              ALS Integration time - multiple of 50mS\r\n *  @als_gain:              Index into the ALS gain table.\r\n *  @als_gain_level:        ALS gain level (When asserted, the 1 and 8 ALS gain (AGAIN) modes are scaled by 0.16)\r\n *  @wait_time:             Time between PRX and ALS cycles\r\n *                          in 2.7 periods\r\n *  @wlong:                 When asserted, the wait cycles are increased by a factor 12 from that programmed in the WTIME register\r\n *  @interrupts_enable:     Enable/Disable als interrupts\r\n *  @persistence:           H/W Filters, Number of 'out of limits'\r\n *                          ADC readings ALS.\r\n *  @als_thresh_low:        CH0 'low' count to trigger interrupt.\r\n *  @als_thresh_high:       CH0 'high' count to trigger interrupt.\r\n *  @als_enable:            This bit actives the two channel ADC\r\n *  @wait_enable:           This bit activates the wait feature.\r\n *  @power_on:              This bit activates the internal oscillator to permit the timers and ADC channels to operate\r\n *  @glass_attenuation:     scaling factor referred to as glass attenuation (GA) can be used to compensate for attenuation\r\n */\r\nstruct tsl2x7x_settings {\r\n    uint8_t als_time;\r\n    uint8_t als_gain;\r\n    bool als_gain_level;\r\n    uint8_t wait_time;\r\n    bool wlong;\r\n    bool  interrupts_enable;\r\n    uint8_t  persistence;\r\n    uint16_t als_thresh_low;\r\n    uint16_t als_thresh_high;\r\n    bool als_enable;\r\n    bool wait_enable;\r\n    bool power_on;\r\n    float glass_attenuation;\r\n};\r\n\r\n/****************************************************************************\r\n * Function Prototypes\r\n ****************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc);\r\nuint8_t TSL2572_Init_HW(void);\r\nuint8_t TSL2572_ReadAmbientLight(float *lux);\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN);\r\nuint8_t TSL2572_ClearALSInterrupt(void);\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS);\r\nuint8_t TSL2572_Enable_ALS(bool AEN);\r\nuint8_t TSL2572_Power_ON(bool PON);\r\nuint8_t TSL2572_Enable_Wait(bool WEN);\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData);\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData);\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG);\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL);\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME);\r\n\r\n#endif /* TSL2572_H_ */\r\n"
              },
              "objects": {
                "tsl2572.c": "#include \"tsl2572.h\"\r\n#include \"tsl2572_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_TSL2572_Config_t config;\r\n    bool configured;\r\n} ATMO_TSL2572_Priv_Config;\r\n\r\nstatic ATMO_TSL2572_Priv_Config _ATMO_TSL2572_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t _ATMO_TSL2572_i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool tsl2572Enabled = true;\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config)\r\n{\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_TSL2572_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n    \t_ATMO_TSL2572_config.configured = false;\r\n    }\r\n\r\n    tsl2572_IoFunc_t io;\r\n    io.I2C_Read = _ATMO_TSL2572_I2CRead_Simple;\r\n    io.I2C_Write = _ATMO_TSL2572_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    TSL2572_Init_Driver(&io);\r\n    TSL2572_Init_HW();\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled)\r\n{\r\n    tsl2572Enabled = enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = tsl2572Enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_TSL2572_i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy( &_ATMO_TSL2572_config.config, config, sizeof(ATMO_TSL2572_Config_t) );\r\n    _ATMO_TSL2572_config.configured = true;\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_TSL2572_config.configured )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_TSL2572_config.config, sizeof(ATMO_TSL2572_Config_t));\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux)\r\n{\r\n    if(!tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n    \r\n\tif( TSL2572_ReadAmbientLight(lightLux) != 0 )\r\n\t{\r\n\t\treturn ATMO_TSL2572_Status_Fail;\r\n\t}\r\n\r\n\treturn ATMO_TSL2572_Status_Success;\r\n}\r\n\r\n\r\n\r\n",
                "tsl2572_internal.c": "/*\r\n * tsl2572.c\r\n *\r\n *  Created on: 25 sept. 2017\r\n *      Author: frq05060\r\n */\r\n\r\n#include \"tsl2572_internal.h\"\r\n\r\n/* TSL2572 Register definitions */\r\n#define TSL2572_I2C_SLAVE_ADDRESS        0x39\r\n#define TSL2572_DEVICE_ID                0x34    // TSL25721\r\n#define TSL2572_REG_ENABLE               0x00\r\n#define TSL2572_REG_ATIME                0x01\r\n#define TSL2572_REG_WTIME                0x03\r\n#define TSL2572_REG_AILTL                0x04\r\n#define TSL2572_REG_AILTH                0x05\r\n#define TSL2572_REG_AIHTL                0x06\r\n#define TSL2572_REG_AIHTH                0x07\r\n#define TSL2572_REG_PERS                 0x0C\r\n#define TSL2572_REG_CONFIG               0x0D\r\n#define TSL2572_REG_CONTROL              0x0F\r\n#define TSL2572_REG_ID                   0x12\r\n#define TSL2572_REG_STATUS               0x13\r\n#define TSL2572_REG_C0DATA               0x14\r\n#define TSL2572_REG_C0DATAH              0x15\r\n#define TSL2572_REG_C1DATA               0x16\r\n#define TSL2572_REG_C1DATAH              0x17\r\n\r\n/* tsl2572 COMMAND register masks */\r\n#define TSL2572_COMMAND_MSK              0x80\r\n#define TSL2572_TYPE_REPEAT_MSK          0x00\r\n#define TSL2572_TYPE_AUTO_INC_MSK        0x20\r\n#define TSL2572_TYPE_SPL_FN_MSK          0x60\r\n#define TSL2572_ADD_ALS_INT_CLR_MSK      0x06\r\n\r\n/* tsl2572 CONTROL register masks */\r\n#define TSL2572_AGAIN_MASK               0x03\r\n\r\n/* tsl2572 CONFIG register masks */\r\n#define TSL2572_AGL_MSK                  0x04\r\n#define TSL2572_WLONG_MSK                0x02\r\n\r\n/* tsl2572 PERS register masks */\r\n#define TSL2572_APERS_MSK                0x0F\r\n\r\n/* tsl2572 ENABLE register masks */\r\n#define TSL2572_AIEN_MSK                 0x10\r\n#define TSL2572_AEN_MSK                  0x02\r\n#define TSL2572_WEN_MSK                  0x08\r\n#define TSL2572_PON_MSK                  0x01\r\n\r\nenum tsl2572_status {\r\n    TSL2572_sensor_success = 0,\r\n    TSL2572_sensor_I2C_error = 1,\r\n    TSL2572_sensor_invalid_ID = 2,\r\n    TSL2572_sensor_wrong_parameter = 3\r\n};\r\n\r\nstatic const struct tsl2x7x_settings tsl2x7x_default_settings = {\r\n        0xDB,\r\n        0,\r\n        true,\r\n        74,\r\n        false,\r\n        true,\r\n        1,\r\n        100,\r\n        300,\r\n        true,\r\n        true,\r\n        true,\r\n        1\r\n};\r\n\r\n/***********************************************************************************/\r\n/* variables                                                                       */\r\n/***********************************************************************************/\r\nstatic tsl2572_IoFunc_t sTSL2572_Func;\r\nuint8_t gain_val = 0;\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_Driver                                                          */\r\n/* wrap the low level function (I2C write, I2C read, WaitMsec)                  */\r\n/* required by TSL2572 driver                                                   */\r\n/* Note : this function does not initialize the HW                              */\r\n/********************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc){\r\n    sTSL2572_Func = *pIoFunc;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_HW                                                              */\r\n/* initialize the HW                                                            */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Init_HW(void){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* check device ID */\r\n    wBuf[0] = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    if (rBuf != TSL2572_DEVICE_ID){\r\n        return TSL2572_sensor_invalid_ID;\r\n    }\r\n\r\n    /* Set ALS gain */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSGain(tsl2x7x_default_settings.als_gain,tsl2x7x_default_settings.als_gain_level)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Set ALS time */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSTime(tsl2x7x_default_settings.als_time)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* configure the wait time */\r\n    if (TSL2572_sensor_success != TSL2572_SetWaitTime(tsl2x7x_default_settings.wait_time,tsl2x7x_default_settings.wlong)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt thresholds */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSThresholds(tsl2x7x_default_settings.als_thresh_low,tsl2x7x_default_settings.als_thresh_high)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt persistence */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSPersistence(tsl2x7x_default_settings.persistence)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* ALS Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_ALS(tsl2x7x_default_settings.als_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Wait Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_Wait(tsl2x7x_default_settings.wait_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Power ON  */\r\n    if (TSL2572_sensor_success != TSL2572_Power_ON(tsl2x7x_default_settings.power_on)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* clear the sensor IRQ status */\r\n    if (TSL2572_sensor_success != TSL2572_ClearALSInterrupt()){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if (TSL2572_sensor_success != TSL2572_EnableALSInterrupts(tsl2x7x_default_settings.interrupts_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAmbientLight                                                     */\r\n/* sample CH0 and CH1 photo_diodes and compute the human eye response to        */\r\n/* light intensity (in lux)                                                     */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAmbientLight(float *lux){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n    int c0,c1;\r\n    float lux1,lux2,cpl;\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    c0 = rBuf[1]<<8 | rBuf[0];\r\n    c1 = rBuf[3]<<8 | rBuf[2];\r\n\r\n    //see TSL2572 datasheet\r\n    cpl = (2.73 * (256-tsl2x7x_default_settings.als_time)) * gain_val / (tsl2x7x_default_settings.glass_attenuation * 60);\r\n    if (tsl2x7x_default_settings.als_gain_level){\r\n        cpl /= 6;\r\n    }\r\n    lux1 = ((float)c0 - (1.87 * (float)c1)) / cpl;\r\n    lux2 = ((0.63 * (float)c0) - (float)c1) / cpl;\r\n    cpl = lux1 >= lux2 ? lux1 : lux2; //max(lux1, lux2);\r\n    *lux = ((cpl >= 0.0) ? cpl : 0.0); //max(cpl, 0.0);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSGain                                                           */\r\n/* AGAIN = 0     ALS Gain value = 1 * gain                                      */\r\n/* AGAIN = 1     ALS Gain value = 8 * gain                                      */\r\n/* AGAIN = 2     ALS Gain value = 16 * gain                                     */\r\n/* AGAIN = 3     ALS Gain value = 120 * gain                                    */\r\n/* AGL = 0       AGAIN = 0 or 1 or 2 or 3     -> scaling by 1                   */\r\n/* AGL = 1       AGAIN = 0 or 1               -> scaling by 0.16                */\r\n/* Do not use AGL = 1 with AGAIN = 2 or 3                                       */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    if ((AGAIN > 1) && (AGL)){\r\n        return TSL2572_sensor_wrong_parameter;\r\n    }\r\n\r\n    wBuf[0] = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = AGAIN & TSL2572_AGAIN_MASK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AGL bit */\r\n    if (AGL){\r\n        wBuf[1] = rBuf | TSL2572_AGL_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AGL_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if ((AGAIN & TSL2572_AGAIN_MASK) == 0) gain_val = 1;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 1) gain_val = 8;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 2) gain_val = 16;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 3) gain_val = 120;\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSTime                                                           */\r\n/* set ALS Time = the ALS ADC integration time                                  */\r\n/* ATIME = 0xFF     ALS integration cycles = 1,   time = 2.73ms                 */\r\n/* ATIME = 0xF6     ALS integration cycles = 10,  time = 27.3ms                 */\r\n/* ATIME = 0xDB     ALS integration cycles = 37,  time = 101ms                  */\r\n/* ATIME = 0xC0     ALS integration cycles = 64,  time = 175ms                  */\r\n/* ATIME = 0x00     ALS integration cycles = 256, time = 699ms                  */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = ATIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* set ALS interrupt threshold low and threshold high                             */\r\n/* the thresholds refer to C0 photo_diode only                                     */\r\n/* (C1 is not used to trigger interrupts)                                        */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[5];\r\n\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = (uint8_t)(ALS_interrupt_Low_Threshold & 0x00FF);\r\n    wBuf[2] = (uint8_t)((ALS_interrupt_Low_Threshold & 0xFF00) >> 8);\r\n    wBuf[3] = (uint8_t)(ALS_interrupt_High_Threshold & 0x00FF);\r\n    wBuf[4] = (uint8_t)((ALS_interrupt_High_Threshold & 0xFF00) >> 8);\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* get ALS interrupt threshold low and threshold high                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    *ALS_interrupt_Low_Threshold = (uint16_t) (rBuf[1]<<8 | rBuf[0]);\r\n    *ALS_interrupt_High_Threshold = (uint16_t) (rBuf[3]<<8 | rBuf[2]);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSPersistence                                                    */\r\n/* set ALS interrupt persistence filter                                            */\r\n/* APERS = 0     every ALS cycle generates an interrupt                           */\r\n/* APERS = 1     1 value outside of threshold range generates an interrupt        */\r\n/* APERS = 2     2 consecutive values out of range generates an interrupt         */\r\n/* APERS = 3     3 consecutive values out of range generates an interrupt         */\r\n/* APERS = 4     5 consecutive values out of range generates an interrupt         */\r\n/* APERS = 5     10 consecutive values out of range generates an interrupt         */\r\n/* APERS = 6     15 consecutive values out of range generates an interrupt         */\r\n/* APERS = 7     20 consecutive values out of range generates an interrupt         */\r\n/* APERS = 8     25 consecutive values out of range generates an interrupt         */\r\n/* APERS = 9     30 consecutive values out of range generates an interrupt         */\r\n/* APERS = 10    35 consecutive values out of range generates an interrupt         */\r\n/* APERS = 11    40 consecutive values out of range generates an interrupt         */\r\n/* APERS = 12    45 consecutive values out of range generates an interrupt         */\r\n/* APERS = 13    50 consecutive values out of range generates an interrupt         */\r\n/* APERS = 14    55 consecutive values out of range generates an interrupt         */\r\n/* APERS = 15    60 consecutive values out of range generates an interrupt         */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = APERS & TSL2572_APERS_MSK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetWaitTime                                                             */\r\n/* WTIME = 0xFF     Wait time = 2.73ms (WLONG = 0), 0.033s (WLONG = 1)           */\r\n/* WTIME = 0xB6     Wait time = 202ms (WLONG = 0), 2.4s (WLONG = 1)               */\r\n/* WTIME = 0x00     Wait time = 699ms (WLONG = 0), 8.4s (WLONG = 1)               */\r\n/* The Wait time register should be configured before TSL2572_Enable_ALS(true)    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    wBuf[0] = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = WTIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WLONG bit */\r\n    if (WLONG){\r\n        wBuf[1] = rBuf | TSL2572_WLONG_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WLONG_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AIEN bit */\r\n    if (AIEN){\r\n        wBuf[1] = rBuf | TSL2572_AIEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AIEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_ClearALSInterrupt(void){\r\n    uint8_t wBuf;\r\n\r\n    wBuf = TSL2572_COMMAND_MSK | TSL2572_TYPE_SPL_FN_MSK | TSL2572_ADD_ALS_INT_CLR_MSK;\r\n    if (sTSL2572_Func.I2C_Write(&wBuf, sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_ALS                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_ALS(bool AEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AEN bit */\r\n    if (AEN){\r\n        wBuf[1] = rBuf | TSL2572_AEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_Wait                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_Wait(bool WEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WEN bit */\r\n    if (WEN){\r\n        wBuf[1] = rBuf | TSL2572_WEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Power_ON                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Power_ON(bool PON){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask PON bit */\r\n    if (PON){\r\n        wBuf[1] = rBuf | TSL2572_PON_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_PON_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAllRegisters                                                        */\r\n/* RegData contains 16 * uint8_t                                                */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read ENABLE register */\r\n    wBuf = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ATIME register */\r\n    wBuf = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read WTIME register */\r\n    wBuf = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTL register */\r\n    wBuf = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTH register */\r\n    wBuf = TSL2572_REG_AILTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTL register */\r\n    wBuf = TSL2572_REG_AIHTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTH register */\r\n    wBuf = TSL2572_REG_AIHTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read PERS register */\r\n    wBuf = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONFIG register */\r\n    wBuf = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONTROL register */\r\n    wBuf = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ID register */\r\n    wBuf = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read STATUS register */\r\n    wBuf = TSL2572_REG_STATUS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATA register */\r\n    wBuf = TSL2572_REG_C1DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATAH register */\r\n    wBuf = TSL2572_REG_C1DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadCH0                                                                 */\r\n/* RegData contains 2 * uint8_t                                                    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n"
              }
            }
          }
        },
        "mpl3115": {
          "libName": "mpl3115",
          "description": "NXP MPL3115 Pressure and Altitude Sensor",
          "type": "Pressure + Altitute Sensor",
          "icon": "",
          "manufacturer": "NXP Semiconductors",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "MPL3115Pressure",
              "type": "EmbeddedMPL3115",
              "icon": "EmbeddedPressure.svg",
              "defaultAbility": "readPressure",
              "defaultTrigger": "pressureRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_MPL3115_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.MPLsettings.mode = MPL_MODE_PRESSURE;\n\tconfig.MPLsettings.oversample = MPL_OS_0;\t\t\t// oversampling = 1\n\tconfig.MPLsettings.autoAcquisitionTime = MPL_ST_0;\t// Auto acquisition time = 1s\n\tconfig.MPLsettings.pressureOffset = ATMO_PROPERTY(undefined, pressureOffset);\t// Offset pressure correction = 4*-128 = -512Pa (8 bits signed integer)\n\tconfig.MPLsettings.altitudeOffset = ATMO_PROPERTY(undefined, altitudeOffset);\t// Offset altitude correction = 128m (signed 8 bits integer)\n\tconfig.MPLsettings.tempOffset = ATMO_PROPERTY(undefined, tempOffset);\t\t\t// Offset temperature correction -8C (0.0625C/LSB)\n\tconfig.MPLsettings.fifoMode = FIFO_DISABLED;\t\t// FIFO mode disabled\n\tconfig.MPLsettings.fifoWatermark = 5;\t\t\t\t// 6 bits to set the number of FIFO samples required to trigger a watermark interrupt.\n\tconfig.MPLsettings.fifoINTpin = FIFO_INT1;\t\t\t// set pin INT1 as output for FIFO interrupt\n\n\treturn ( ATMO_MPL3115_Init(&config) == ATMO_MPL3115_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_MPL3115_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAltitude",
                  "triggers": [
                    "altitudeRead"
                  ],
                  "code": "    uint32_t altitudeMeters;\n    if(ATMO_MPL3115_GetAltitude(&altitudeMeters) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)altitudeMeters);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressure",
                  "triggers": [
                    "pressureRead"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)pressurePa);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressureKpa",
                  "triggers": [
                    "pressureReadKpa"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)(pressurePa/1000));\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x60"
                },
                {
                  "name": "pressureOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "altitudeOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "tempOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedMPL3115": "MPL3115 Pressure",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readAltitude": "Read Altitude",
                  "readPressure": "Read Pressure",
                  "readPressureKpa": "Read Pressure (kPa)",
                  "pressureRead": "Pressure Read",
                  "altitudeRead": "Altitude Read",
                  "pressureReadKpa": "Pressure Read (kPa)",
                  "pressureOffset": "Pressure Offset",
                  "altitudeOffset": "Altitude Offset",
                  "tempOffset": "Temperature Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "mpl3115.h": "#ifndef __ATMO_MPL3115_H_\n#define __ATMO_MPL3115_H_\n\n#include \"mpl3115_internal.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_MPL3115_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_MPL3115_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_MPL3115_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_MPL3115_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_MPL3115_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_MPL3115_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n\tsettingsMPL_t MPLsettings;\n} ATMO_MPL3115_Config_t;\n\n\n/**\n * Initialize MPL3115 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config);\n\n/**\n * Enable/Disable MPL3115 Driver\n *\n * @param[in] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of MPL3115 driver\n *\n * @param[out] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config);\n\n/**\n * Get Barometeric Pressure in Pascals\n * \n * @param[out] pressurePascals\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperature\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Altitude in meters\n * \n * @param[out] altitudeMeters\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters);\n\n#endif\n",
                "mpl3115_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the header file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#ifndef MPL3115_H_\n#define MPL3115_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*!\n * @addtogroup mpl3115 MPL3115 atmospheric pressure sensor\n * This module provides the API to operate the MPL3115 atmospheric pressure sensor through an I2C interface.\n *\n * The MPL3115A2 is a compact, piezoresistive, absolute pressure sensor with an I2C\n * digital interface. MPL3115A2 has a wide operating range of 20 kPa to 110 kPa, a range\n * that covers all surface elevations on earth. The MEMS is temperature compensated\n * utilizing an on-chip temperature sensor. The pressure and temperature data is fed into\n * a high resolution ADC to provide fully compensated and digitized outputs for pressure\n * in Pascals and temperature in C.\n *\n * Usage\n *-----------------------------------------------------------------------------------------------------------\n *\n * Initialization:\n * @code\n *\n *  #include \"mpl3115.h\"\n *\n *  mpl3115_IoFunc_t MPL3115_sensor;\n *  MPL3115_sensor.I2C_Read = App_I2C1_Read;\n *  MPL3115_sensor.I2C_Write = App_I2C1_Write;\n *  MPL3115_sensor.WaitMsec = App_WaitMsec;\n *\n *  MPL3115_Init_Driver(&MPL3115_sensor);\n *  MPL3115_Init_Hw();\n * @endcode\n *\n * Basic Operation:\n * @code\n *\n *  int32_t data;\n *\n *  if (MPL_ReadRawData (MPL_MODE_PRESSURE, &data) == 0)\n *  {\n *        data /= 400; // in HPa (LSB = 0.25Pa)\n *  }\n *\n * @endcode\n *\n * @{\n */\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _mpl3115_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);     /*!< Function pointer to I2C Read function. */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);                                         /*!< Function pointer to I2C Write function. */\n    void      (*WaitMsec)(uint32_t millisec);                                                                                   /*!< Function pointer to waitMsec function  */\n} mpl3115_IoFunc_t, *pmpl3115_IoFunc_t;\n\ntypedef int16_t mE_t;\n\n/*! @brief Status return codes. */\ntypedef enum\n{\n    MPL_SUCCESS,            /*!< Function ran successfully. */\n    MPL_ERROR,              /*!< Error in running function. */\n    MPL_PROTOCOL_ERROR,     /*!< Protocol error has occurred. */\n    MPL_INIT_ERROR,         /*!< Initialization error has occurred. */\n    MPL_TIMEOUT,            /*!< MPL function has timed out */\n    MPL_NOT_SUPPORTED       /*!< Not Supported */\n} mpl_status_t;\n\n/*! @brief Oversampling factor */\ntypedef enum {\n    MPL_OS_0,               /*!< Oversample Ratio = 1    */\n    MPL_OS_1,               /*!< Oversample Ratio = 2    */\n    MPL_OS_2,               /*!< Oversample Ratio = 4    */\n    MPL_OS_3,               /*!< Oversample Ratio = 8    */\n    MPL_OS_4,               /*!< Oversample Ratio = 16   */\n    MPL_OS_5,               /*!< Oversample Ratio = 32   */\n    MPL_OS_6,               /*!< Oversample Ratio = 64   */\n    MPL_OS_7                /*!< Oversample Ratio = 128  */\n} overSampleMPL_t;\n\n/*! @brief Auto acquisition time step : power(2; MPL_ST_X) */\ntypedef enum {\n    MPL_ST_0,               /*!< Auto acquistion time step = 1 second       */\n    MPL_ST_1,               /*!< Auto acquistion time step = 2 seconds      */\n    MPL_ST_2,               /*!< Auto acquistion time step = 4 seconds      */\n    MPL_ST_3,               /*!< Auto acquistion time step = 8 seconds      */\n    MPL_ST_4,               /*!< Auto acquistion time step = 16 seconds     */\n    MPL_ST_5,               /*!< Auto acquistion time step = 32 seconds     */\n    MPL_ST_6,               /*!< Auto acquistion time step = 64 seconds     */\n    MPL_ST_7,               /*!< Auto acquistion time step = 128 seconds    */\n    MPL_ST_8,               /*!< Auto acquistion time step = 256 seconds    */\n    MPL_ST_9,               /*!< Auto acquistion time step = 512 seconds    */\n    MPL_ST_10,              /*!< Auto acquistion time step = 1024 seconds   */\n    MPL_ST_11,              /*!< Auto acquistion time step = 2048 seconds   */\n    MPL_ST_12,              /*!< Auto acquistion time step = 4096 seconds   */\n    MPL_ST_13,              /*!< Auto acquistion time step = 8192 seconds   */\n    MPL_ST_14,              /*!< Auto acquistion time step = 16384 seconds  */\n    MPL_ST_15               /*!< Auto acquistion time step = 32768 seconds  */\n} autoAcquisitionTime_t;\n\n/*! @brief Device Mode */\ntypedef enum {\n    MPL_MODE_PRESSURE    = 0,   /*!< Device is in barometer mode. It reports an absolute pressure.  */\n    MPL_MODE_ALTITUDE    = 1,   /*!< Device is in altimeter mode. The pressure data is converted to equivalent altitude based on US standard atmosphere */\n    MPL_MODE_TEMPERATURE = 2,   /*!< This mode provides temperature from a high resolution temperature sensor. */\n    MPL_MODE_CURRENT     = 0xFF\n} modeMPL_t;\n\n/*! @brief Fifo Mode */\ntypedef enum {\n    FIFO_DISABLED,        /*!< FIFO is disabled (reset value) */\n    FIFO_CIRCULAR,        /*!< FIFO contains the most recent samples when overflowed (circular buffer). Oldest sample is discarded to be replaced by new sample*/\n    FIFO_STOP_OVERFLOW    /*!< FIFO stops accepting new samples when overflowed */\n} modeFIFO_t;\n\n/*! @brief Pin to route FIFO interrupt */\ntypedef enum {\n    FIFO_INT1    = 1,   /*!< FIFO Interrupt routed to INT1 pin */\n    FIFO_INT2    = 0    /*!< FIFO Interrupt routed to INT2 pin */\n} pinINT_t;\n\n/* structure that contains MPL settings */\ntypedef struct {\n    modeMPL_t                 mode;                    /*!< device mode, altimeter or barometer */\n    overSampleMPL_t           oversample;              /*!< oversampling ratio */\n    autoAcquisitionTime_t     autoAcquisitionTime;     /*!< Auto acquisition time step */\n    int8_t                    pressureOffset;          /*!< Offset pressure correction (signed: 4 Pa/LSB) */\n    int8_t                    altitudeOffset;          /*!< Offset altitude correction (signed: 1m/LSB) */\n    int8_t                    tempOffset;              /*!< Offset temperature correction -8C (signed: 0.0625C/LSB) */\n    modeFIFO_t                fifoMode;                /*!< FIFO mode */\n    uint8_t                   fifoWatermark;           /*!< These (6) bits set the number of FIFO samples required to trigger a watermark interrupt. */\n    pinINT_t                  fifoINTpin;              /*!< Pin to route FIFO interrupt */\n} settingsMPL_t;\n\n/* MPL3115 I2C slave address */\n#define MPL3115_I2C_SLAVE_ADDRESS                (uint8_t)0x60\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize MPL3115 driver.\n * @note  Wrap the low level functions (I2C write, I2C read, WaitMsec).\n * @param pIoFunc  Pointer to a structure with external functions\n */\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc);\n\n/*!\n * @brief De-initialize MPL3115 driver.\n *\n */\nvoid MPL3115_Deinit_Driver();\n\n/*!\n * @brief Initialize MPL3115 hardware.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings);\n\n/*!\n * @brief Soft reset.\n * @note\n * The reset mechanism can be enabled in standby and active mode.\\n\n * When this bit is enabled, the reset mechanism resets all functional block\n * registers and loads the respective internal registers with default values\n * If the system was already in standby mode, the reboot process will\\n\n * immediately begin; else if the system was in active mode, the boot mechanism\n * will automatically transition the system from active mode to standby mode,\n * and only then can the reboot process begin.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SoftReset();\n\n/*!\n * @brief Toggle the OST bit.\n * @note Clears then sets the OST bit which causes the sensor to immediately\n * take another reading, necessary to sample faster than 1Hz.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ToggleOneShot();\n\n/*!\n * @brief Read the chip ID.\n *\n * @param sensorID Chip ID value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetID(uint8_t* sensorID);\n\n/*!\n * @brief Set the device mode (barometer or altimeter).\n *\n * @param mode 1 - barometer\n *             0 - altimeter\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetMode (modeMPL_t mode);\n\n/*!\n * @brief Put the sensor in stand-by mode.\n * @note It is needed to modify major control registers.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GotoStandby ();\n\n/*!\n * @brief Put the sensor in active mode.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetActive();\n\n/*!\n * @brief Set the over-sample rate.\n * @note\n * Datasheet calls for 128, but you can set it from 1 to 128 samples.\n * The higher the oversample rate, the greater the time between data samples.\n *\n * @param sampleRate Over-sample rate value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate);\n\n/*!\n * @brief Set the auto-acquisition time step.\n * @note\n * Reset value = 0.\\n\n * Step is power(2; sampleTime).\n *\n * @param sampleTime Sample time value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetAutoAcquisitionTime (uint8_t sampleTime);\n\n/*!\n * @brief Enable pressure and temperature measurement event flags.\n * @note This is recommended in datasheet during setup.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_EnableEventFlags();\n\n/*!\n * @brief Set the offset pressure correction.\n * @note\n * Pressure user accessible offset trim value number.\\n\n * The user offset registers may be adjusted to enhance accuracy and optimize\n * the system performance.\\n\n * Range is from 512 to +508 Pa, 4 Pa/LSB.\n *\n * @param pressOffset Pressure offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset);\n\n/*!\n * @brief Set the offset altitude correction.\n * @note\n * Altitude user accessible offset trim value number.\\n\n * The user offset register provides user adjustment to the vertical height of\n * the altitude output.\\n\n * The range of values are from 128 to +127 meters.\n *\n * @param altitudeOffset Altitude offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset);\n\n/*!\n * @brief Set the offset temperature correction.\n * @note\n * Temperature user accessible offset trim value number.\\n\n * The range of values is from 8 to +7.9375 C, 0.0625 C/LSB.\n *\n * @param temperatureOffset Temperature offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset);\n\n/*!\n * @brief Set the FIFO mode\n * @note\n * It can be configured in either circular buffer or in overflow mode.\\n\n * In circular buffer mode, a watermark can be set to trigger a flag event.\n * Exceeding the watermark, count does not stop the FIFO from accepting new\n * data, the oldest data is overwritten.\n *\n * @param fMode FIFO mode\n * @param fWmrk Watermark\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk);\n\n/*!\n * @brief Setup the FIFO interrupt and route it to pin INT1 or INT2\n *\n * @param pinINT Interrupt pin selection (INT1 or INT2)\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT);\n\n/*!\n * @brief Disable the FIFO interrupt\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_DisableFifoInterrupt();\n\n/*!\n * @brief Read the FIFO status register.\n *\n * @param fifoStatus Pointer to FIFO status\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus);\n\n/*!\n * @brief Read sensor raw data\n *\n * @param  mode Sensor mode (pressure, altitude...)\n * @param  sensorData Pointer to the sensor data\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData);\n\n/*!\n * @brief Read all the chip registers\n *\n * @param  sensorReg Pointer to the register dump\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Dump(uint8_t* sensorReg);\n\n/*! @}*/\n\n#endif /* MPL3115_H_ */\n"
              },
              "objects": {
                "mpl3115.c": "#include \"mpl3115.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_MPL3115_Config_t config;\n    bool configured;\n} ATMO_MPL3115_Priv_Config;\n\nstatic ATMO_MPL3115_Priv_Config _ATMO_MPL3115_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_MPL3115_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool mpl3115Enabled = true;\n\nstatic uint8_t ATMO_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\n\nstatic uint8_t ATMO_MPL3115_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_MPL3115_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_MPL3115_config.configured = false;\n    }\n\n    mpl3115_IoFunc_t io;\n    io.I2C_Read = ATMO_I2CRead_Simple;\n    io.I2C_Write = ATMO_MPL3115_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    MPL3115_Init_Driver(&io);\n    MPL3115_Init_Hw(&config->MPLsettings);\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled)\n{\n    mpl3115Enabled = enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled)\n{\n    *enabled = mpl3115Enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_MPL3115_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy( &_ATMO_MPL3115_config.config, config, sizeof(ATMO_MPL3115_Config_t) );\n    _ATMO_MPL3115_config.configured = true;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !_ATMO_MPL3115_config.configured )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_MPL3115_config.config, sizeof(ATMO_MPL3115_Config_t));\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)pressurePascals) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *pressurePascals = (*pressurePascals) / 4;\n\n    return ATMO_MPL3115_Status_Success;\n        \n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_TEMPERATURE, (int32_t *)temperatureCelsius) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *temperatureCelsius = (*temperatureCelsius) / 16;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n    \n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)altitudeMeters) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *altitudeMeters = (*altitudeMeters) / 16;\n\n    return ATMO_MPL3115_Status_Success; \n}\n\n\n\n\n",
                "mpl3115_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the source file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#include \"mpl3115_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/* unshifted 7-bit I2C address */\n#define MPL_I2C_ADDRESS  (0x60)\n\n#define REG_STATUS      (0x00)\n#define OUT_P_MSB       (0x01)\n#define OUT_P_CSB       (0x02)\n#define OUT_P_LSB       (0x03)\n#define OUT_T_MSB       (0x04)\n#define OUT_T_LSB       (0x05)\n#define DR_STATUS       (0x06)\n#define OUT_P_DELTA_MSB (0x07)\n#define OUT_P_DELTA_CSB (0x08)\n#define OUT_P_DELTA_LSB (0x09)\n#define OUT_T_DELTA_MSB (0x0A)\n#define OUT_T_DELTA_LSB (0x0B)\n#define WHO_AM_I        (0x0C)\n#define F_STATUS        (0x0D)\n#define F_DATA          (0x0E)\n#define F_SETUP         (0x0F)\n#define TIME_DLY        (0x10)\n#define SYSMOD          (0x11)\n#define INT_SOURCE      (0x12)\n#define PT_DATA_CFG     (0x13)\n#define BAR_IN_MSB      (0x14)\n#define BAR_IN_LSB      (0x15)\n#define P_TGT_MSB       (0x16)\n#define P_TGT_LSB       (0x17)\n#define T_TGT           (0x18)\n#define P_WND_MSB       (0x19)\n#define P_WND_LSB       (0x1A)\n#define T_WND           (0x1B)\n#define P_MIN_MSB       (0x1C)\n#define P_MIN_CSB       (0x1D)\n#define P_MIN_LSB       (0x1E)\n#define T_MIN_MSB       (0x1F)\n#define T_MIN_LSB       (0x20)\n#define P_MAX_MSB       (0x21)\n#define P_MAX_CSB       (0x22)\n#define P_MAX_LSB       (0x23)\n#define T_MAX_MSB       (0x24)\n#define T_MAX_LSB       (0x25)\n#define MPL_CTRL_REG1   (0x26)\n#define MPL_CTRL_REG2   (0x27)\n#define MPL_CTRL_REG3   (0x28)\n#define MPL_CTRL_REG4   (0x29)\n#define MPL_CTRL_REG5   (0x2A)\n#define OFF_P           (0x2B)\n#define OFF_T           (0x2C)\n#define OFF_H           (0x2D)\n\n// SHIFTS\n#define MPL_OS_SHIFT    (3)\n\n#define MPL_TDR_SHIFT   (1)\n#define MPL_PDR_SHIFT   (2)\n#define MPL_PTDR_SHIFT  (3)\n\n#define MPL_SBYB_SHIFT  (0)\n#define MPL_OST_SHIFT   (1)\n#define MPL_RST_SHIFT   (2)\n\n#define INT_EN_FIFO_SHIFT   (6)\n#define INT_CFG_FIFO_SHIFT  (6)\n\n// MASKS\n#define MPL_OS_MASK         (0x7 << MPL_OS_SHIFT)\n#define MPL_F_WMRKK_MASK    0xF\n\n/* MPL3115 CTRL_REG1 register */\n#define MPL_RST             (1 << 2)\n#define MPL_OST             (1 << 1)\n#define MPL_SBYB            (1 << 0)\n\n/***********************************************************************************/\n/* variables                                                                       */\n/***********************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic mpl3115_IoFunc_t sIoFunc;\n\n/* variable which denotes the sensor working as altimeter/barometer */\nstatic modeMPL_t selectedMode = MPL_MODE_PRESSURE;\n\nstatic uint16_t\nselectedSampleRate  = 0xA5A5,\nselectedDelay       = 0xA5A5;\n\n/* oversample factor */\nstatic uint16_t overSampleFactors[] = { 1,  2,  4,  8, 16,  32,  64, 128 };\n/* min. time between data samples in [ms] */\nstatic uint16_t overSampleDelays[]  = { 6, 10, 18, 34, 66, 130, 258, 512 };\n\nstatic settingsMPL_t settings;\n\n\n/*****************************************************************************\n * Static functions\n ****************************************************************************/\n\n/*\n * @brief Initialize the internal structures.\n *\n * @param mplSettings Pointer to the internal settings structure\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Init(const settingsMPL_t* mplSettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    memcpy( (void*)&settings, (void*)mplSettings, sizeof(settings) );\n\n    // reset all registers to POR values\n    if (MPL_SoftReset()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set the mode\n    else if (MPL_SetMode(settings.mode)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // set over-sampling\n    else if (MPL_SetOversampleRate(settings.oversample)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // enable the flags\n    else if (MPL_EnableEventFlags()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set auto acquisition time step\n    else if (MPL_SetAutoAcquisitionTime(settings.autoAcquisitionTime)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset pressure correction\n    else if (MPL_SetOffsetPressure(settings.pressureOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset altitude correction\n    else if (MPL_SetOffsetAltitude(settings.altitudeOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset temperature correction\n    else if (MPL_SetOffsetTemperature(settings.tempOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // setup FIFO register mode and event count to trigger interrupt\n    else if (MPL_SetFifoMode(settings.fifoMode, settings.fifoWatermark)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set FIFO interrupt and output pin (INT1 or INT2)\n    else if (MPL_SetFifoInterrupt(settings.fifoINTpin)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // goto active state\n    else if (MPL_SetActive()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    return status;\n}\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc)\n{\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sIoFunc = *pIoFunc;\n    initDriverDone = true;\n}\n\nvoid MPL3115_Deinit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        MPL_GotoStandby(); /* skip error management */\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    if (!initDriverDone) return MPL_INIT_ERROR;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    /* initialize the sensor */\n    status = MPL_Init(MPLsettings);\n    if (status != MPL_SUCCESS) initHwDone = false;\n    return status;\n\n}\n\nmpl_status_t MPL_SoftReset()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1, MPL_RST};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // Reset all registers to POR value\n    if (sIoFunc.I2C_Write(wBuf, 2)!= MPL_SUCCESS) return MPL_ERROR;\n    else\n    {\n        // by the end of the boot process the RST bit should be de-asserted to 0 => need to wait before next operation\n        sIoFunc.WaitMsec(10); // 10ms delay\n        return MPL_SUCCESS;\n    }\n}\n\nmpl_status_t MPL_ToggleOneShot()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear OST bit and write it back\n    wBuf[1] = rBuf & ~(MPL_OST);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read again settings, just to be safe\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set OST bit and write it back\n    wBuf[1] = rBuf | MPL_OST;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetID(uint8_t* sensorID)\n{\n    uint8_t wBuf[1] = {WHO_AM_I};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorID != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, sensorID, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetMode (modeMPL_t mode)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set/clear ALT bit\n    switch (mode)\n    {\n    case MPL_MODE_PRESSURE: {\n        wBuf[1] = rBuf & ~( 1 << 7 ); // Clear ALT bit\n        break;\n    }\n    case MPL_MODE_ALTITUDE: {\n        wBuf[1] = rBuf | ( 1 << 7 ); // Set ALT bit\n        break;\n    }\n    case MPL_MODE_TEMPERATURE: {\n        break;\n    }\n    default:\n        return MPL_NOT_SUPPORTED;\n    }\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n    // update the static variable\n    selectedMode = mode;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GotoStandby()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear SBYB bit for entering stand-by mode\n    wBuf[1] = rBuf & ~MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetActive()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set SBYB bit for entering active mode\n    wBuf[1] = rBuf | MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // rate cannot be larger than 7\n    if (sampleRate > 7) sampleRate = 7;\n\n    selectedSampleRate = overSampleFactors[sampleRate];\n    selectedDelay      = overSampleDelays[sampleRate];\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear out old OS bits\n    wBuf[1] = rBuf & ~MPL_OS_MASK;\n    // mask in new OS bits\n    wBuf[1] |= ( sampleRate << MPL_OS_SHIFT );\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t  MPL_SetAutoAcquisitionTime (uint8_t sampleTime)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG2};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // mask in new ST bits. sampleTime cannot be larger than 15 Giving a range of 1s to 9.1 hours\n    wBuf[1] |= (sampleTime > 15) ? 15 : sampleTime;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_EnableEventFlags()\n{\n    uint8_t wBuf[] = {PT_DATA_CFG, 0x07};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_P, pressOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset)\n{\n    uint8_t wBuf[] = {OFF_H, altitudeOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_T, temperatureOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk)\n{\n    uint8_t wBuf[2] = {F_SETUP};\n    wBuf[1] = (fMode << 6) | (fWmrk & MPL_F_WMRKK_MASK);\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & set INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf | (1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read CTRL5 register & Route interrupt to either INT1 or INT2 pin\n    wBuf[0] = MPL_CTRL_REG5;\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    wBuf[1] = (pinINT == FIFO_INT1) ? rBuf | (1 << INT_CFG_FIFO_SHIFT) : rBuf &~(1 << INT_CFG_FIFO_SHIFT);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_DisableFifoInterrupt ()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & disable INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf & ~(1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus)\n{\n    uint8_t wBuf[1] = {F_STATUS};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(fifoStatus != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, fifoStatus, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData)\n{\n    uint8_t wBuf[2] = {REG_STATUS};\n    uint8_t rBuf[5];\n    uint8_t dataReadyFlag,\n    dataReadyRegAddr,\n    bytesToRead = 0;\n    int16_t counter = 0;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorData != NULL);\n\n    /* set the new working mode, if given one */\n\n    if  (( mode > MPL_MODE_TEMPERATURE ) && ( mode < MPL_MODE_CURRENT )) return MPL_INIT_ERROR;\n    else if (( MPL_MODE_CURRENT != mode ) && ( selectedMode != mode ))\n    {\n        // goto standby\n        if (MPL_GotoStandby()!=MPL_SUCCESS) return MPL_ERROR;\n        // set the mode\n        if (MPL_SetMode(mode)!=MPL_SUCCESS) return MPL_ERROR;\n        // goto active state\n        if (MPL_SetActive()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    /* prepare for reading data */\n\n    switch (selectedMode)\n    {\n    case MPL_MODE_PRESSURE:\n    case MPL_MODE_ALTITUDE: {\n        dataReadyFlag     = 1 << MPL_PDR_SHIFT;\n        dataReadyRegAddr  = OUT_P_MSB;\n        bytesToRead       = 3;\n        break;\n    }\n\n    case MPL_MODE_TEMPERATURE: {\n        dataReadyFlag     = 1 << MPL_TDR_SHIFT;\n        dataReadyRegAddr  = OUT_T_MSB;\n        bytesToRead       = 2;\n        break;\n    }\n\n    default:  {}\n    }\n\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // check PDR/PTR bit; if it's not set, toggle OST\n    if (0 == (rBuf[0] & dataReadyFlag))\n    {\n        // toggle the OST bit, causing the sensor to immediately take another reading\n        if (MPL_ToggleOneShot()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    // wait for PDR/PTR bit, which indicates that we have new data\n    while (1)\n    {\n        if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        if ((0==(rBuf[0] & dataReadyFlag)) & ( ++counter > 5 )) return MPL_TIMEOUT;\n        else break;\n        sIoFunc.WaitMsec(100);  // Wait 100ms\n    }\n\n    /* read sensor data */\n\n    wBuf[0] = dataReadyRegAddr;\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, bytesToRead)!=MPL_SUCCESS) return MPL_ERROR;\n\n    switch ( selectedMode )\n    {\n    // pressure value is a Q18.2 right-aligned number in [Pa]\n    case MPL_MODE_PRESSURE:\n        // altitude value is a Q16.4 right-aligned number in [m]\n    case MPL_MODE_ALTITUDE:     {\n        *sensorData = (int32_t) ((rBuf[0] << 16) | (rBuf[1] << 8) | rBuf[2]) >> 4;\n        break;\n    }\n\n    // temperature value is a Q8.4 right-aligned number in [C]\n    case MPL_MODE_TEMPERATURE:  {\n        *sensorData = (int32_t) (((rBuf[0] << 8) | rBuf[1]) >> 4);\n        break;\n    }\n    default:  {}\n    }\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_Dump(uint8_t *sensorReg)\n{\n    uint8_t wBuf= 0;\n    uint8_t rBuf;\n    uint8_t i;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorReg != NULL);\n\n    // read all registers\n    for (i=0; i<45; i++)\n    {\n        if (sIoFunc.I2C_Read(&wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        *sensorReg = rBuf;\n        wBuf++;\n        sensorReg++;\n    }\n    return MPL_SUCCESS;\n}\n"
              }
            }
          }
        },
        "ens210": {
          "libName": "ens210",
          "description": "AMS ENS210 Humidity and Temperature Sensor",
          "type": "Humidity + Temperature Sensor",
          "icon": "",
          "manufacturer": "AMS",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "ENS210TemperatureHumidity",
              "type": "EmbeddedENS210",
              "icon": "EmbeddedTempHumidity.svg",
              "defaultAbility": "readTemperature",
              "defaultTrigger": "temperatureRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(undefined, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTemperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readHumidity",
                  "triggers": [
                    "humidityRead"
                  ],
                  "code": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x43"
                },
                {
                  "name": "tempCalibrationOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedENS210": "ENS210 Temperature/Humidity Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readTemperature": "Read Temperature(C)",
                  "temperatureRead": "Temperature Read",
                  "readHumidity": "Read Humidity(%rh)",
                  "humidityRead": "Humidity Read",
                  "tempCalibrationOffset": "Temperature Calibration Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ens210.h": "#ifndef _ATMO_ENS210_H_\n#define _ATMO_ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_ENS210_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_ENS210_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_ENS210_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_ENS210_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_ENS210_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_ENS210_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    int16_t tempCalibrationOffset;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n} ATMO_ENS210_Config_t;\n\n/**\n * Initialize ENS210 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config);\n\n/**\n * Enable/Disable ENS210 Driver\n *\n * @param[in] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of ENS210 driver\n *\n * @param[out] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct);\n\n#endif\n",
                "ens210_internal.h": "/*\n *****************************************************************************\n * Copyright by ams AG                                                       *\n * All rights are reserved.                                                  *\n *                                                                           *\n * IMPORTANT - PLEASE READ CAREFULLY BEFORE COPYING, INSTALLING OR USING     *\n * THE SOFTWARE.                                                             *\n *                                                                           *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       *\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         *\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS         *\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     *\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT          *\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     *\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     *\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       *\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     *\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      *\n *****************************************************************************\n */\n\n\n#ifndef __ENS210_H_\n#define __ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*! @addtogroup ens210   ENS210 Driver API\n * This module provides the API to operate an ENS210 relative humidity and temperature sensor with I2C interface.\n *\n * Basic steps to operate the sensor are as follows:\n * -# Set Run mode (#ENS210_SensRun_Set)\n * -# Start measurement (#ENS210_SensStart_Set)\n * -# Wait for measurement to complete\n * -# Read measurement (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get)\n *\n * Please refer to ENS210 Reference Driver and Porting Guide for more details on platform porting. In this module, names\n * T and H have been used to refer to temperature and relative humidity respectively to comply with ENS210 datasheet\n * naming convention.\n *\n * Example 1 - Sample application code to measure temperature and relative humidity without error checking\n * -------------------------------------------------------------------------------------------------------\n * @code\n * uint32_t T_Raw, H_Raw;\n * int32_t T_mCelsius, T_mFahrenheit, T_mKelvin, H_Percent;\n *\n * //Set runmode, start measurement, wait, read measurement (for both T and H)\n * ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * ENS210_SensStart_Set(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START);\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n * ENS210_THVal_Get(&T_Raw,&H_Raw);\n *\n * //Convert the raw temperature to milli Kelvin\n * T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n * //Convert the raw temperature to milli Celsius\n * T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n * //Convert the raw temperature to milli Fahrenheit\n * T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n * printf(\"T crc ok = %s\\n\", ENS210_IsCrcOk(T_Raw)  ? \"yes\" : \"no\");\n * printf(\"T valid = %s \\n\", ENS210_IsDataValid(T_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"T = %ld mK %ld mC %ld mF \\n\", T_mKelvin, T_mCelsius, T_mFahrenheit);\n *\n * //Convert the raw relative humidity to milli %\n * H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n * printf(\"H crc ok = %s\\n\", ENS210_IsCrcOk(H_Raw)  ? \"yes\" : \"no\");\n * printf(\"H valid = %s \\n\", ENS210_IsDataValid(H_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"H = %ld m%%\\n\", H_Percent);\n *\n * @endcode\n *\n *\n * Example 2 - Sample application code to measure relative humidity with error checking\n * ------------------------------------------------------------------------------------\n * @code\n * uint32_t H_Raw;\n * int32_t H_Percent;\n * int status;\n * bool i2cOk;\n *\n * i2cOk = true; //Start accumulating I2C transaction errors\n *\n * status = ENS210_SensRun_Set(ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * status = ENS210_SensStart_Set(ENS210_SENSSTART_H_START);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n *\n * status = ENS210_HVal_Get(&H_Raw);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * if( !i2cOk ) {\n *     printf(\"H i2c error\\n\")\n * } else if( !ENS210_IsCrcOk(H_Raw) ) {\n *     printf(\"H crc error\\n\")\n * } else if( !ENS210_IsDataValid(H_Raw) ) {\n *     printf(\"H data invalid\\n\")\n * } else {\n *     //Convert the raw relative humidity to milli %\n *     H_Percent = ENS210_ConvertRawToPercentageH(H_Raw,1000);\n *     //Update the int32_t format specifier (%ld) based on platform word-size\n *     printf(\"H = %ld m%%\\n\", H_Percent);\n * }\n *\n * @endcode\n *\n * @{\n */\n/*****************************************************************************\n * Types/enumerations/variables\n ****************************************************************************/\n\n/*! @brief Status return codes. */\ntypedef enum ens210_status_ {\n    ens210_success = 0,             /*!< Function returned successfully. */\n    ens210_I2C_error = 1,           /*!< I2C Error. */\n    ens210_invalid_ID = 2,          /*!< Invalid ID. */\n    ens210_Tdata_CRC_error = 3,     /*!< CRC error for temperature data. */\n    ens210_Hdata_CRC_error = 4,     /*!< CRC error for humidity data. */\n    ens210_T_invalid_data = 5,      /*!< Temperature Data is invalid. */\n    ens210_H_invalid_data = 6,      /*!< Humidity Data is invalid. */\n    ens210_wrong_parameter = 7,     /*!< Wrong Parameter entered. */\n    ens210_noinit = 8               /*!< ENS210 was not initialized. */\n} ens210_status_t;\n\n/*! @brief Measurement mode of Sensor */\nenum measurement_mode {\n    mode_TH = 0,        /*!< ENS210 set to measure both temperature and humidity. */\n    mode_Tonly = 1,     /*!< ENS210 set to measure temperature only. */\n    mode_Honly = 2      /*!< ENS210 set to measure humidity only. */\n};\n\n/*! ENS210 os-free driver version info */\n#define ENS210_OSFREE_DRIVER_VERSION            2\n\n/*! ENS210 T and H conversion time in milliseconds. Refer to ENS210 data sheet for timing information. */\n#define ENS210_T_H_CONVERSION_TIME_MS           130\n\n/*! ENS210 T conversion time in milliseconds */\n#define ENS210_T_CONVERSION_TIME_MS             110\n\n/*! ENS210 Booting time in milliseconds. */\n#define ENS210_BOOTING_TIME_MS                  10\n\n/*! ENS210 Reset time in milliseconds. */\n#define ENS210_RESET_WAIT_TIME_MS               10\n\n/*! ENS210 I2C slave address */\n#define ENS210_I2C_SLAVE_ADDRESS                (uint8_t)0x43\n\n/*! ENS210 SysCtrl register: Low power enable */\n#define ENS210_SYSCTRL_LOWPOWER_ENABLE          (1 << 0)\n/*! ENS210 SysCtrl register: Low power disable */\n#define ENS210_SYSCTRL_LOWPOWER_DISABLE         (0 << 0)\n/*! ENS210 SysCtrl register: Reset enable */\n#define ENS210_SYSCTRL_RESET_ENABLE             (1 << 7)\n/*! ENS210 SysCtrl register: Reset disable */\n#define ENS210_SYSCTRL_RESET_DISABLE            (0 << 7)\n\n/*! ENS210 SysStat register: Standby or Booting mode */\n#define ENS210_SYSSTAT_MODE_STANDBY             (0 << 0)\n/*! ENS210 SysStat register: Active mode */\n#define ENS210_SYSSTAT_MODE_ACTIVE              (1 << 0)\n\n\n/*! ENS210 SensRun register: temperature single shot mode */\n#define ENS210_SENSRUN_T_MODE_SINGLE_SHOT       (0 << 0)\n/*! ENS210 SensRun register: temperature continuous mode */\n#define ENS210_SENSRUN_T_MODE_CONTINUOUS        (1 << 0)\n/*! ENS210 SensRun register: relative humidity single shot mode */\n#define ENS210_SENSRUN_H_MODE_SINGLE_SHOT       (0 << 1)\n/*! ENS210 SensRun register: relative humidity continuous mode */\n#define ENS210_SENSRUN_H_MODE_CONTINUOUS        (1 << 1)\n\n/*! ENS210  SensStart register: T sensor start */\n#define ENS210_SENSSTART_T_START                (1 << 0)\n/*! ENS210  SensStart register: H sensor start */\n#define ENS210_SENSSTART_H_START                (1 << 1)\n\n/*! ENS210  SensStop register: T sensor stop */\n#define ENS210_SENSSTOP_T_STOP                  (1 << 0)\n/*! ENS210  SensStop register: H sensor stop */\n#define ENS210_SENSSTOP_H_STOP                  (1 << 1)\n\n/*! ENS210  SensStat register: T sensor idle */\n#define ENS210_SENSSTAT_T_STAT_IDLE             (0 << 0)\n/*! ENS210  SensStat register: T sensor active */\n#define ENS210_SENSSTAT_T_STAT_ACTIVE           (1 << 0)\n/*! ENS210  SensStat register: H sensor idle */\n#define ENS210_SENSSTAT_H_STAT_IDLE             (0 << 1)\n/*! ENS210  SensStat register: H sensor active */\n#define ENS210_SENSSTAT_H_STAT_ACTIVE           (1 << 1)\n\n/* wrapper for the I2C write, I2C read and wait functions needed by the sensor driver */\n/* it is expected that the I2C_Read and I2C_Write functions return 0 if the I2C transaction is successful */\ntypedef struct _ens210_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);  /*!< External I2C read function */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);  /*!< External I2C write function */\n    void      (*WaitMsec)(uint32_t millisec); /*!< Wait function in milliseconds */\n} ens210_IoFunc_t, *pens210_IoFunc_t;\n\n/*! @brief    ENS210 ID block structure */\ntypedef struct ENS210_Ids_s\n{\n    uint16_t    partId;             /*!< Part ID */\n    uint8_t     uId[8];             /*!< Unique Identifier 8 bytes */\n} ENS210_Ids_t;\n\n/*! @brief Structure of measurement data. */\ntypedef struct ens210_meas_data_s\n{\n    int32_t T_Celsius;              /*!< Temperature in Celsius */\n    int32_t T_Fahrenheit;           /*!< Temperature in Fahrenheit */\n    int32_t T_Kelvin;               /*!< Temperature in Kelvin */\n    int32_t T_mCelsius;             /*!< Temperature in milliCelsius */\n    int32_t T_mFahrenheit;          /*!< Temperature in milliFahrenheit */\n    int32_t T_mKelvin;              /*!< Temperature in milliKelvin */\n    int32_t H_Percent;              /*!< Relative Humidity to % */\n    int32_t H_mPercent;             /*!< Relative Humidity to milli% */\n} ens210_meas_data_t;\n\n/****************************************************************************\n * Function Prototypes\n ****************************************************************************/\n\n/*!\n * @brief   Initialize ENS210 driver.\n * @param   pIoFunc     :   Pointer to a structure of external functions or values\n */\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc);\n\n/*!\n * @brief   De-initialize ENS210 driver.\n */\nvoid ENS210_Deinit_Driver();\n\n/*!\n * @brief   Initialize ENS210 hardware.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_Init_Hw(void);\n\n/*!\n * @brief   Set ENS210 SysCtrl register; enabling reset and/or low power.\n * @param   sysCtrl     :   Mask composed of  ENS210_SYSCTRL_xxx macros.\n * @return  The return status value (0 for success)\n *  */\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysCtrl register.\n * @param   sysCtrl     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysStat register.\n * @param   sysStat     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat);\n\n/*!\n * @brief   Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\n * @param   sensRun     :   Mask composed of ENS210_SENSRUN_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun);\n\n/*!\n * @brief   Get ENS210 SensRun register.\n * @param   sensRun     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun);\n\n/*!\n * @brief   Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\n * @param   sensStart   :  Mask composed of ENS210_SENSSTART_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart);\n\n/*!\n * @brief   Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\n * @param   sensStop    :   Mask composed of ENS210_SENSSTOP_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop);\n\n/*!\n * @brief   Get ENS210 SensStat register.\n * @param   sensStat    :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat);\n\n/*!\n * @brief   Get ENS210 TVal register; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * Use ENS210_ConvertRawToXXX to convert raw data to standard units.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_TVal_Get(uint32_t *traw);\n\n/*!\n * @brief   Get ENS210 HVal register; raw measurement data as well as CRC and valid indication.\n * @param   hraw         :   Pointer to receive value of register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_HVal_Get(uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 TVal and HVal registers; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of TVal register. Must not be null.\n * @param   hraw         :   Pointer to receive value of HVal register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 Part ID and UID.\n * @param   ids         :   Pointer to receive ids. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If this function returns an error, it is suggested to reset the device to bring it to a known state.\n */\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids);\n\n/*!\n * @brief   Get ENS210 temperature and humidity measurements\n * @param   meas_mode    :   Measurement mode\n * @param   results      :   Pointer to the result structure\n * @return  The return status value (0 for success)\n * @note\n * mode = 0: temperature and humidity\\n\n * mode = 1: temperature only\\n\n * mode = 2: humidity only\n */\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results);\n\n/*!\n * @}\n */\n\n#endif /* __ENS210_H_ */\n\n"
              },
              "objects": {
                "ens210.c": "#include \"ens210.h\"\n#include \"ens210_internal.h\"\n\ntypedef struct {\n    ATMO_ENS210_Config_t config;\n    bool configured;\n} ATMO_ENS210_Priv_Config;\n\nstatic ATMO_ENS210_Priv_Config _ATMO_ENS210_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_ENS210_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool _ATMO_ENS210_Enabled = true;\n\nstatic uint8_t ATMO_ENS210_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t ATMO_ENS210_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_ENS210_SetConfiguration(config);\n    }\n    else\n    {\n        _ATMO_ENS210_config.configured = false;\n    }\n\n    ens210_IoFunc_t io;\n    io.I2C_Read = ATMO_ENS210_I2CRead_Simple;\n    io.I2C_Write = ATMO_ENS210_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    ENS210_Init_Driver(&io);\n    ENS210_Init_Hw();\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled)\n{\n    _ATMO_ENS210_Enabled = enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled)\n{\n    *enabled = _ATMO_ENS210_Enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_ENS210_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n    memcpy( &_ATMO_ENS210_config.config, config, sizeof(ATMO_ENS210_Config_t) );\n    _ATMO_ENS210_config.configured = true;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL || !_ATMO_ENS210_config.configured )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_ENS210_config.config, sizeof(ATMO_ENS210_Config_t));\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = results.T_Celsius + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_Percent;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = (results.T_mCelsius / 1000.0) + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_mPercent / 1000.0;\n\n    return ATMO_ENS210_Status_Success;\n}",
                "ens210_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file\n * This is the source file for the temperature and humidity sensor ENS210 driver.\n */\n\n#include \"ens210_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/*****************************************************************************\n * Private macros and functions\n ****************************************************************************/\n/* Register addresses */\n#define ENS210_REG_PART_ID     0x00\n#define ENS210_REG_UID         0x04\n#define ENS210_REG_SYS_CTRL    0x10\n#define ENS210_REG_SYS_STAT    0x11\n#define ENS210_REG_SENS_RUN    0x21\n#define ENS210_REG_SENS_START  0x22\n#define ENS210_REG_SENS_STOP   0x23\n#define ENS210_REG_SENS_STAT   0x24\n#define ENS210_REG_T_VAL       0x30\n#define ENS210_REG_H_VAL       0x33\n\n/** Mask to extract 16-bit data from raw T and H values */\n#define ENS210_T_H_MASK        0xFFFFU\n\n/** Simplification macro, implementing integer division with simple rounding to closest number\n *  It supports both positive and negative numbers, but ONLY positive divisors */\n#define IDIV(n,d)              ((n)>0 ? ((n)+(d)/2)/(d) : ((n)-(d)/2)/(d))\n\n#define CRC7WIDTH              7     //7 bits CRC has polynomial of 7th order (has 8 terms)\n#define CRC7POLY               0x89  //The 8 coefficients of the polynomial\n#define CRC7IVEC               0x7F  //Initial vector has all 7 bits high\n\n#define DATA7WIDTH             17\n#define DATA7MASK              ((1UL << DATA7WIDTH) - 1)  //0b 1 1111 1111 1111 1111\n#define DATA7MSB               (1UL << (DATA7WIDTH - 1))  //0b 1 0000 0000 0000 0000\n\n/** When the ENS210 is soldered a correction on T needs to be applied (see application note).\n *  Typically the correction is 50mK. Units for raw T is 1/64K. */\n#define ENS210_TRAW_SOLDERCORRECTION  (50*64/1000)\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\n\nstatic ens210_IoFunc_t sENS210_Func;\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\n\n/*****************************************************************************\n * Private functions prototypes\n ****************************************************************************/\n\n/*\n * @brief   Compute the CRC7 results.\n * @param   val   :   the value\n * @return  The CRC7 computed result\n */\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val);\n\n/*\n * @brief   Verify the CRC of the raw temperature or relative humidity.\n * @param   raw         :  Raw temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Success,  False - Failure.\n * @note    This function can be used on raw T as well as raw H data (since they use the same format and CRC).\n */\nstatic bool ENS210_IsCrcOk(uint32_t raw);\n\n/*\n * @brief   Verify data validity of the raw temperature or relative humidity.\n * @param   raw         :  Raw  temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Valid,  False - Invalid.\n */\nstatic bool ENS210_IsDataValid(uint32_t raw);\n\n/*\n * @brief   Converts a raw temperature value into Kelvin.\n *          The output value is in Kelvin multiplied by parameter \"multiplier\".\n * @param   traw        :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier  :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Kelvin.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Celsius.\n *          The output value is in Celsius multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Celsius.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Fahrenheit.\n *          The output value is in Fahrenheit multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted temperature\n * @return  The temperature value in 1/multiplier Fahrenheit.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw relative humidity value into human readable format.\n * @param   hraw         :   The relative humidity value in the raw format (#ENS210_HVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted relative humidity.\n * @return  The converted relative humidity value\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier);\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\n//Compute the CRC-7 of 'val' (which should only have 17 bits)\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val)\n{\n    //Setup polynomial\n    uint32_t pol= CRC7POLY;\n\n    //Align polynomial with data\n    pol = pol << (DATA7WIDTH-CRC7WIDTH-1);\n\n    //Loop variable (indicates which bit to test, start with highest)\n    uint32_t bit = DATA7MSB;\n\n    //Make room for CRC value\n    val = val << CRC7WIDTH;\n    bit = bit << CRC7WIDTH;\n    pol = pol << CRC7WIDTH;\n\n    //Insert initial vector\n    val |= CRC7IVEC;\n\n    //Apply division until all bits done\n    while( bit & (DATA7MASK<<CRC7WIDTH) )\n    {\n        if( bit & val )\n        {\n            val ^= pol;\n        }\n        bit >>= 1;\n        pol >>= 1;\n    }\n    return val;\n}\n\n//Verify the CRC\nstatic bool ENS210_IsCrcOk(uint32_t raw)\n{\n    uint32_t crc, data;\n\n    assert(raw <= 0xffffffUL);\n\n    //Extract 7-bit CRC(Bit-17 to Bit-23)\n    crc =  (raw >> 17) & 0x7F;\n\n    //Get the raw T/H and data valid indication.\n    data =  raw & 0x1ffff;\n\n    return ENS210_ComputeCRC7(data) == crc;\n}\n\n//Check the Data Valid Bit\nstatic bool ENS210_IsDataValid(uint32_t raw)\n{\n    assert(raw <= 0xffffffUL);\n\n    //Bit-16 is data valid bit. It will be set if data is valid\n    return (raw & (1UL << 16)) != 0;\n}\n\n//Convert raw temperature to Kelvin\n//The output value is in Kelvin multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*K\n    //where m is the multiplier, R the raw value and K is temperature in Kelvin.\n    //K=R/64 (since raw has format 10.6).\n    //m*K =  m*R/64\n    return IDIV(t*multiplier, 64);\n}\n\n//Convert raw temperature to Celsius\n//The output value is in Celsius multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*C\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use C=K-273.15 and K=R/64 (since raw has format 10.6).\n    //m*C = m*(K-273.15) = m*K - 27315*m/100 = m*R/64 - 27315*m/100\n\n    return IDIV(t*multiplier, 64) - IDIV(27315L*multiplier, 100);\n}\n\n//Convert raw temperature to Fahrenheit\n//The output value is in Fahrenheit multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*F\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use F=1.8*(K-273.15)+32 and K=R/64 (since raw has format 10.6).\n\n    //m*F = m*(1.8*(K-273.15)+32) = m*(1.8*K-273.15*1.8+32) = 1.8*m*K-459.67*m = 9*m*K/5 - 45967*m/100 = 9*m*R/320 - 45967*m/100\n    return IDIV(9*multiplier*t, 320) - IDIV(45967L*multiplier, 100);\n\n    //The first multiplication stays below 32 bits (tRaw:16, multiplier:11, 9:4)\n    //The second  multiplication stays below 32 bits (multiplier:10, 45967:16)\n}\n\n//Convert raw relative humidity to readable format\n//The output value is in % multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier)\n{\n    int32_t h;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw relative humidity\n    h = hraw & ENS210_T_H_MASK;\n\n    //As raw format is 7.9, to obtain the relative humidity, it must be divided by 2^9\n    return IDIV(h*multiplier, 512);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n// wrap the low level function (I2C write, I2C read, WaitMsec) required by ENS210 driver\n// this function does not initialize the HW\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc){\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sENS210_Func = *pIoFunc;\n    initDriverDone = true;\n}\n\n// De-initialize the driver\nvoid ENS210_Deinit_Driver(){\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\n// Initialize ENS210 hardware\nens210_status_t ENS210_Init_Hw(void)\n{\n    ens210_status_t status = ens210_success;\n\n    if (!initDriverDone) return ens210_noinit;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    //Reset the sensor\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_RESET_ENABLE | ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_status;\n\n    //Wait for ENS210 to complete reset\n    sENS210_Func.WaitMsec(ENS210_RESET_WAIT_TIME_MS);\n\n    //Set the run mode of sensors\n    status = ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n    if (status != ens210_success) goto return_status;\n\n    return_status:\n    if (status != ens210_success) initHwDone = false;\n    return status;\n}\n\n//Set ENS210 SysCtrl register; enabling reset and/or low power\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL, sysCtrl};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sysCtrl & ~(ENS210_SYSCTRL_LOWPOWER_ENABLE | ENS210_SYSCTRL_RESET_ENABLE)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof (wBuf));\n}\n\n//Get ENS210 SysCtrl register\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysCtrl != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysCtrl, sizeof (*sysCtrl));\n}\n\n//Get ENS210 SysStat register.\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysStat, sizeof (*sysStat));\n}\n\n//Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN, sensRun};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensRun & ~(ENS210_SENSRUN_T_MODE_CONTINUOUS | ENS210_SENSRUN_H_MODE_CONTINUOUS)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensRun register\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensRun != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensRun, sizeof *sensRun);\n}\n\n//Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_START, sensStart};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStart & ~(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STOP, sensStop};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStop & ~(ENS210_SENSSTOP_T_STOP | ENS210_SENSSTOP_H_STOP)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensStat register.\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensStat, sizeof *sensStat);\n}\n\n//Get ENS210 TVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_TVal_Get(uint32_t *traw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(traw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n\n    return status;\n}\n\n//Get ENS210 HVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_HVal_Get(uint32_t *hraw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_H_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(hraw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *hraw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n\n    return status;\n}\n\n//Get ENS210 TVal and Hval registers; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw)\n{\n    uint8_t rBuf[6];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert((traw != NULL) && (hraw != NULL));\n\n    // Read 6 bytes starting from ENS210_REG_T_VAL\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n    *hraw = ((uint32_t)rBuf[5]) << 16 | ((uint32_t)rBuf[4]) << 8 | (uint32_t)rBuf[3];\n\n    return status;\n}\n\n// Get ENS210 Part ID and UID.\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids)\n{\n    uint8_t rBuf[12];\n    uint8_t wBuf[] = {ENS210_REG_PART_ID};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(ids != NULL);\n\n    // Special procedure needed to read ID's: put device in high power (see datasheet)\n    // Set the system in Active mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_DISABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Wait for sensor to go to active mode\n    sENS210_Func.WaitMsec(ENS210_BOOTING_TIME_MS);\n\n    // Get the id's\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n    if (status != ens210_success) goto return_error_status;\n\n    // Copy id's (hw gives partid in little-endian format)\n    ids->partId = ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n    memcpy(&ids->uId[0], &rBuf[4], 8);\n\n    // Go back to low power mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Signal success\n    return status;\n\n    return_error_status:\n    // Make an attempt to restore low-power\n    ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    // Return original I2C error\n    return status;\n}\n\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results){\n    ens210_status_t status;\n    uint8_t meas_status;\n    uint32_t T_Raw = 0, H_Raw = 0;\n    uint32_t conversion_time_ms = 0;\n    uint8_t start_meas = 0;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(results != NULL);\n\n    switch (meas_mode){\n    case mode_TH :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START;\n        break;\n    case mode_Tonly :\n        conversion_time_ms = ENS210_T_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START;\n        break;\n    case mode_Honly :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_H_START;\n        break;\n    default :\n        return ens210_wrong_parameter;\n        break;\n    }\n\n    //check that the previous measurement is completed\n    status = ENS210_SensStat_Get(&meas_status);\n    if (status != ens210_success){\n        return status;\n    }\n    if(meas_status != 0){\n        // trying to start a measurement too early!\n        sENS210_Func.WaitMsec(conversion_time_ms);\n    }\n\n    //Start the measurement\n    status = ENS210_SensStart_Set(start_meas);\n    if(status != ens210_success){\n        //Start of measurement failed.\n        return status;\n    }\n\n    // wait for the measurement to be completed\n    sENS210_Func.WaitMsec(conversion_time_ms);\n\n    if (meas_mode == mode_TH){\n        //Get the temperature and humidity raw value\n        status = ENS210_THVal_Get(&T_Raw, &H_Raw);\n    }\n    else if (meas_mode == mode_Tonly){\n        status = ENS210_TVal_Get(&T_Raw);\n    }\n    else if (meas_mode == mode_Honly){\n        status = ENS210_HVal_Get(&H_Raw);\n    }\n    if(status != ens210_success){\n        //Getting T and/or H values failed\n        return status;\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Tonly)){\n        // Verify the temperature raw value\n        if(!ENS210_IsCrcOk(T_Raw))    {\n            return ens210_Tdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(T_Raw)){\n            return ens210_T_invalid_data;\n        }\n        else {\n            //Convert the raw temperature value to Kelvin\n            results->T_Kelvin = ENS210_ConvertRawToKelvin(T_Raw, 1);\n            //Convert the raw temperature value to Celsius\n            results->T_Celsius = ENS210_ConvertRawToCelsius(T_Raw, 1);\n            //Convert the raw temperature value to Fahrenheit\n            results->T_Fahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1);\n            //Convert the raw temperature value to milli Kelvin\n            results->T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n            //Convert the raw temperature value to milli Celsius\n            results->T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n            //Convert the raw temperature value to milli Fahrenheit\n            results->T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n        }\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Honly)){\n        //Verify the relative humidity raw value\n        if(!ENS210_IsCrcOk(H_Raw)){\n            return ens210_Hdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(H_Raw)){\n            return ens210_H_invalid_data;\n        }\n        else {\n            //Convert the raw relative humidity to %\n            results->H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1);\n            //Convert the raw relative humidity to milli%\n            results->H_mPercent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n        }\n    }\n    return ens210_success;\n}\n"
              }
            }
          }
        },
        "ccs811": {
          "libName": "ccs811",
          "manufacturer": "AMS",
          "description": "Digital Gas Sensor",
          "type": "Digital Gas Sensor",
          "icon": "",
          "image": "ccs811.jpg",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "CCS811AirQuality",
              "type": "EmbeddedCCS811",
              "icon": "EmbeddedAirQuality.svg",
              "defaultAbility": "readTVOC",
              "defaultTrigger": "TVOCRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(undefined, operatingMode);\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTVOC",
                  "triggers": [
                    "TVOCRead"
                  ],
                  "code": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readCO2",
                  "triggers": [
                    "CO2Read"
                  ],
                  "code": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x5A"
                },
                {
                  "name": "operatingMode",
                  "input": "number",
                  "value": "1"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedCCS811": "CCS811 Air Quality Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readTVOC": "Read TVOC (ppb)",
                  "readCO2": "Read CO2 (ppm)",
                  "TVOCRead": "TVOC Read",
                  "CO2Read": "CO2 Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ccs811.h": "#ifndef _ATMO_CCS811_H_\r\n#define _ATMO_CCS811_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\n\r\ntypedef enum {\r\n    ATMO_CCS811_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_CCS811_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_CCS811_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_CCS811_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_CCS811_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_CCS811_Status_t;\r\n\r\ntypedef struct {\r\n\t//Mode 0 = Idle\r\n\t//Mode 1 = read every 1s\r\n\t//Mode 2 = every 10s\r\n\t//Mode 3 = every 60s\r\n\t//Mode 4 = RAW mode\r\n\tuint8_t operatingMode;\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_CCS811_Config_t;\r\n\r\n\r\n/**\r\n * Initialize CCS811 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable CCS811 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of CCS811 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Set environmental data for more accurate readings\r\n *\r\n * @param[in] humidity - Pct from 0.0 to 100.0\r\n * @param[in] temperature - Degrees C\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnvironmentalData(float humidity, float temperature);\r\n\r\n/**\r\n * Get Total Volatile Organic Compounds (TVOC) Reading\r\n *\r\n * @param[out] tvoc - TVOC reading in PPB\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc);\r\n\r\n/**\r\n * Get total CO2 Reading in ppm\r\n *\r\n * @param[out] CO2\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2);\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality);\r\n\r\n\r\n#endif\r\n",
                "ccs811_internal.h": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*!\r\n * @file\r\n * This is the header file for the air quality sensor CCS811 driver.\r\n */\r\n\r\n#ifndef CCS811_H_\r\n#define CCS811_H_\r\n\r\n/*!\r\n * @addtogroup ccs811 CCS811 air quality sensor\r\n * This module provides the API to control and monitor the CCS811 air quality sensor through an I2C interface.\r\n *\r\n * The basic steps to operate the CCS811 are as follows:\r\n * -# Initialize the driver with callback functions (#CCS811_Init_Driver)\r\n * -# Initialize the hardware (#CCS811_Init_Hw)\r\n * -# Check data availability (#CCS811_dataAvailable)\r\n * -# Trigger all data acquisition (#CCS811_readAlgorithmResults)\r\n * -# Read the relevant data (for example #CCS811_getCO2)\r\n * -# If the CCS811 is not needed anymore, de-initialize the driver (#CCS811_Deinit_Driver). The CCS811 will\r\n * be switched off. It allows to eventually release shared resources.\r\n *\r\n * Example - Sample application code to set CCS811 without error management\r\n * ------------------------------------------------------------------------\r\n * @code\r\n * \\#include \"CCS811.h\"\r\n *\r\n * CCS811_fct_t ccs811_fct;\r\n * uint8_t ready;\r\n * uint16_t uCO2;\r\n *\r\n * ccs811_fct.connect_hw = Ccs811_Connect;       // callback function to activate CCS811 hardware resource\r\n * ccs811_fct.disconnect_hw = Ccs811_Disconnect; // callback function to deactivate CCS811 hardware resource\r\n * ccs811_fct.I2C_Read = I2c_Read;               // callback function for I2C read\r\n * ccs811_fct.I2C_Write = I2c_Write;             // callback function for I2C write\r\n * ccs811_fct.WaitMsec = WaitMs;                 // wait callback function (in ms)\r\n *\r\n * CCS811_Init_Driver(&ccs811_fct);\r\n * CCS811_Init_Hw();\r\n * // check new data availability\r\n * CCS811_dataAvailable(&ready);\r\n * if (ready == 1) {\r\n *     CCS811_readAlgorithmResults();\r\n *     uCO2 = CCS811_getCO2();\r\n *     printf(\"The current CO2 value is: %d\\n\", uCO2);\r\n * }\r\n * [..]\r\n * // if the CCS811 is not needed anymore, the driver can be de-initialized\r\n * printf(\"Deinitialize CCS811 (it will be turned off)\\n\");\r\n * CCS811_Deinit_Driver();\r\n *\r\n * @endcode\r\n * @{\r\n */\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include <stdbool.h>\r\n\r\n#define CCS811_I2C_ADDRESS              0x5A\r\n\r\n/* Register addresses */\r\n#define CCS811_STATUS                   0x00\r\n#define CCS811_MEAS_MODE                0x01\r\n#define CCS811_ALG_RESULT_DATA          0x02\r\n#define CCS811_RAW_DATA                 0x03\r\n#define CCS811_ENV_DATA                 0x05\r\n#define CCS811_NTC                      0x06\r\n#define CCS811_THRESHOLDS               0x10\r\n#define CCS811_BASELINE                 0x11\r\n#define CCS811_HW_ID                    0x20\r\n#define CCS811_HW_VERSION               0x21\r\n#define CCS811_FW_BOOT_VERSION          0x23\r\n#define CCS811_FW_APP_VERSION           0x24\r\n#define CCS811_ERROR_ID                 0xE0\r\n#define CCS811_APP_START                0xF4\r\n#define CCS811_SW_RESET                 0xFF\r\n#define CCS811_INTERRUPT_DRIVEN         0x8\r\n#define CCS811_THRESHOLDS_ENABLED       0x4\r\n\r\n/*! @brief Status return codes. */\r\ntypedef enum _CCS811_status\r\n{\r\n    CCS811_SUCCESS,        /*!< Success */\r\n    CCS811_ID_ERROR,       /*!< Bad hardware identifier */\r\n    CCS811_I2C_ERROR,      /*!< I2C read/write error */\r\n    CCS811_INTERNAL_ERROR, /*!< Internal hardware error */\r\n    CCS811_NOINIT_ERROR,   /*!< Hardware or driver not initialized */\r\n    CCS811_GENERIC_ERROR   /*!< Generic error (settings not allowed) */\r\n} CCS811_status;\r\n\r\n/*! @brief Structure of external functions or values. */\r\ntypedef struct _CCS811_fct_t\r\n{\r\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize); /*!< External I2C read function */\r\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize); /*!< External I2C write function */\r\n    void (*WaitMsec)(uint32_t tms); /*!< Wait function in milliseconds */\r\n} CCS811_fct_t, *ptCCS811_fct_t;\r\n\r\n/*!\r\n * @brief Initialize CCS811 driver.\r\n *\r\n * @param FCT Pointer to a structure of external functions or values\r\n */\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT);\r\n\r\n/*!\r\n * @brief De-initialize CCS811 driver.\r\n *\r\n */\r\nvoid CCS811_Deinit_Driver();\r\n\r\n/*!\r\n * @brief Initialize CCS811 hardware.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_Init_Hw(void);\r\n\r\n/*!\r\n * @brief Read algorithm results.\r\n * @note Update the total volatile organic compounds (TVOC) in parts per billion (PPB) and the CO2 value.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readAlgorithmResults(void);\r\n\r\n/*!\r\n * @brief Check if error bit is set.\r\n *\r\n * @param  StatusError Pointer to error status bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError);\r\n\r\n/*!\r\n * @brief Check if data is available.\r\n * @note Based on DATA_READ flag in the status register.\r\n *\r\n * @param  value Pointer to available data bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_dataAvailable(uint8_t* value);\r\n\r\n/*!\r\n * @brief Check if APP_VALID is set.\r\n * @note Based on APP_VALID flag in the status register.\r\n *\r\n * @param  value Pointer to APP_VALID bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_appValid(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the error register value.\r\n * @note Based on ERROR_ID register.\r\n *\r\n * @param  value Pointer to error value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  baseline Pointer to baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline);\r\n\r\n/*!\r\n * @brief Set the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  input Baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setBaseline(uint16_t input);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupts.\r\n * @note It clears/sets the nINT signal.\r\n *\r\n * @param  fct Interrupt mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setInterrupts(uint8_t fct);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupt thresholds.\r\n *\r\n * @param  fct Threshold mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setThresholds(uint8_t fct);\r\n\r\n/*!\r\n * @brief Set the drive mode.\r\n * @note\r\n * Mode 0 = Idle\\n\r\n * Mode 1 = read every 1s\\n\r\n * Mode 2 = every 10s\\n\r\n * Mode 3 = every 60s\\n\r\n * Mode 4 = RAW mode\r\n *\r\n * @param  mode Drive mode\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setDriveMode(uint8_t mode);\r\n\r\n/*!\r\n * @brief Set environmental data.\r\n * @note\r\n * Given a temperature and humidity, use these data for better compensation.\r\n *\r\n * @param  relativeHumidity Relative humidity, value within [0,100]\r\n * @param  temperature Temperature (Celsius), value within [-25,+50]\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature);\r\n\r\n/*!\r\n * @brief Set ref resistance.\r\n *\r\n * @param  input Ref resistance\r\n */\r\nvoid CCS811_setRefResistance(float input);\r\n\r\n/*!\r\n * @brief Read NTC.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readNTC(void);\r\n\r\n/*!\r\n * @brief Get Total Volatile Organic Compound (TVOC) value.\r\n *\r\n * @return TVOC value (0ppb to 1187ppb)\r\n */\r\nuint16_t CCS811_getTVOC(void);\r\n\r\n/*!\r\n * @brief Get the equivalent CO2 value.\r\n *\r\n * @return eCO2 value (400ppm to 8192ppm)\r\n */\r\nuint16_t CCS811_getCO2(void);\r\n\r\n/*!\r\n * @brief Get resistance value.\r\n *\r\n * @return Resistance value\r\n */\r\nfloat CCS811_getResistance(void);\r\n\r\n/*!\r\n * @brief Get temperature value.\r\n *\r\n * @return Temperature value (Celsius)\r\n */\r\nfloat CCS811_getTemperature(void);\r\n\r\n/*! @}*/\r\n\r\n#endif /* CCS811_H_ */\r\n"
              },
              "objects": {
                "ccs811.c": "#include \"ccs811.h\"\r\n#include \"ccs811_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n#define CCS811_TVOC_MAX_PPB (1187)\r\n\r\n\r\ntypedef struct {\r\n    ATMO_CCS811_Config_t config;\r\n    bool configured;\r\n} ATMO_CCS811_Priv_Config;\r\n\r\nstatic ATMO_CCS811_Priv_Config _ATMO_CCS811_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool _ATMO_CCS811_Enabled = true;\r\n\r\nstatic uint8_t ATMO_CCS811_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t ATMO_CCS811_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config)\r\n{\r\n\r\n    CCS811_fct_t io;\r\n    io.I2C_Read = ATMO_CCS811_I2CRead_Simple;\r\n    io.I2C_Write = ATMO_CCS811_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    CCS811_Init_Driver(&io);\r\n\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n        _ATMO_CCS811_config.configured = false;\r\n    }\r\n\r\n    if( CCS811_Init_Hw() != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    // The configuration has to be set before the Init_HW routine is called\r\n    // But the Init_HW routine resets the device\r\n    // So, we need to just set the configuration one more time after this reset\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled)\r\n{\r\n    _ATMO_CCS811_Enabled = enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = _ATMO_CCS811_Enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    memcpy( &_ATMO_CCS811_config.config, config, sizeof(ATMO_CCS811_Config_t) );\r\n    _ATMO_CCS811_config.configured = true;\r\n\r\n    if( CCS811_setDriveMode(config->operatingMode) != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_CCS811_config.configured )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_CCS811_config.config, sizeof(ATMO_CCS811_Config_t));\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*tvoc = CCS811_getTVOC();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*co2 = CCS811_getCO2();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    \r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*airQuality = (CCS811_getTVOC() * 100.0) / CCS811_TVOC_MAX_PPB;\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n",
                "ccs811_internal.c": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*!\r\n * @file\r\n * This is the source file for the air quality sensor CCS811 driver.\r\n */\r\n\r\n#include \"ccs811_internal.h\"\r\n#include <math.h>\r\n#include <stdbool.h>\r\n#include <assert.h>\r\n\r\n/*****************************************************************************\r\n * Variables\r\n ****************************************************************************/\r\nstatic CCS811_fct_t FCT_CCS811;\r\nstatic bool initDriverDone = false;\r\nstatic bool initHwDone = false;\r\n\r\n/* air quality values obtained from the sensor */\r\nstatic float refResistance;\r\nstatic float resistance = 10000;\r\nstatic uint16_t tVOC = 0;\r\nstatic uint16_t CO2 = 0;\r\nstatic uint16_t vrefCounts = 0;\r\nstatic uint16_t ntcCounts = 0;\r\nstatic float temperature = 0;\r\n\r\n/*****************************************************************************\r\n * Static functions\r\n ****************************************************************************/\r\n\r\n/*\r\n * @brief Read a CCS811 register.\r\n *\r\n * @param  Address of the register to read\r\n * @param  Pointer to the read value\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_readRegister(uint8_t offset, uint8_t* outputPointer)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, 1);\r\n}\r\n\r\n/*\r\n * @brief Read several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to read\r\n * @param  Pointer to the read values\r\n * @param  Number of consecutive registers to read\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiReadRegister(uint8_t offset, uint8_t *outputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, length);\r\n}\r\n\r\n/*\r\n * @brief Write to a CCS811 register.\r\n *\r\n * @param  Address of the register to write to\r\n * @param  Value to write\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_writeRegister(uint8_t offset, uint8_t dataToWrite)\r\n{\r\n\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    cmd[1] = dataToWrite;\r\n\r\n    return FCT_CCS811.I2C_Write(cmd, 2);\r\n}\r\n\r\n/*\r\n * @brief Write to several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to write to\r\n * @param  Pointer to the values to be written\r\n * @param  Number of consecutive registers to write to\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiWriteRegister(uint8_t offset, uint8_t *inputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[length+1];\r\n    cmd[0] = offset;\r\n    for( uint32_t i = 0; i < length; i++ ) //This waits > 1ms @ 80MHz clock\r\n    {\r\n        cmd[1+i] = inputPointer[i];\r\n    }\r\n    return FCT_CCS811.I2C_Write(cmd, length+1);\r\n}\r\n\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT)\r\n{\r\n    assert((FCT != NULL) &&\r\n            (FCT->I2C_Read != NULL) &&\r\n            (FCT->I2C_Write != NULL) &&\r\n            (FCT->WaitMsec != NULL));\r\n    FCT_CCS811 = *FCT;\r\n    initDriverDone = true;\r\n}\r\n\r\nvoid CCS811_Deinit_Driver()\r\n{\r\n    /* Deinit driver */\r\n    initDriverDone = false;\r\n    initHwDone = false;\r\n}\r\n\r\nCCS811_status CCS811_Init_Hw(void)\r\n{\r\n    uint8_t data[4] = {0x11,0xE5,0x72,0x8A}; /* reset key */\r\n    uint8_t status;\r\n    uint8_t val = 0;\r\n    CCS811_status error_status = CCS811_SUCCESS;\r\n\r\n    if (!initDriverDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* trick to allow calling internal public functions */\r\n    initHwDone = true;\r\n\r\n    /* check HW ID */\r\n    if (CCS811_readRegister( CCS811_HW_ID,  &val) != 0)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (val != 0x81)\r\n    {\r\n        error_status = CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* reset the device */\r\n    if (CCS811_multiWriteRegister(CCS811_SW_RESET, data, 4)!=0)\r\n    {\r\n        error_status =  CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    FCT_CCS811.WaitMsec(10);\r\n\r\n    if (CCS811_checkForStatusError(&status) == CCS811_I2C_ERROR)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (status == true) return CCS811_INTERNAL_ERROR;\r\n\r\n    error_status = CCS811_appValid(&val);\r\n    if (error_status != CCS811_SUCCESS) goto return_status;\r\n    if (val == 0)\r\n    {\r\n        error_status =  CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* write 0 byte to this register to start app */\r\n    //if (CCS811_writeRegister(CCS811_APP_START, 0)!=0) return CCS811_I2C_ERROR;\r\n    val = CCS811_APP_START;\r\n    if (FCT_CCS811.I2C_Write(&val, 1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* read every second */\r\n    if (CCS811_setDriveMode(1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    return_status:\r\n    if (error_status != CCS811_SUCCESS) initHwDone = false;\r\n    return error_status;\r\n}\r\n\r\nCCS811_status CCS811_readAlgorithmResults(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_ALG_RESULT_DATA, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    /* data ordered: co2MSB, co2LSB, tvocMSB, tvocLSB */\r\n    CO2 = ((uint16_t)data[0] << 8) | data[1];\r\n    tVOC = ((uint16_t)data[2] << 8) | data[3];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(StatusError != NULL);\r\n\r\n    /* read the status bit */\r\n    if (CCS811_readRegister(CCS811_STATUS, StatusError )!=0) return CCS811_I2C_ERROR;\r\n    *StatusError = *StatusError & 1 << 0; // bit ERROR\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_dataAvailable(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 3)>>3; // bit DATA_READY\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_appValid(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 4)>>4; // bit APP_VALID\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    *value=0xFF;\r\n    if (CCS811_readRegister(CCS811_ERROR_ID, value )!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(baseline != NULL);\r\n\r\n    uint8_t data[2];\r\n    if (CCS811_multiReadRegister(CCS811_BASELINE,data, 2)!=0) return CCS811_I2C_ERROR;\r\n\r\n    *baseline = ((uint16_t)data[0] << 8) | data[1];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setBaseline(uint16_t input)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[2];\r\n    data[0] = (input >> 8) & 0x00FF;\r\n    data[1] = input & 0x00FF;\r\n\r\n    if (CCS811_multiWriteRegister(CCS811_BASELINE, data, 2)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setInterrupts(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_INTERRUPT_DRIVEN); /* clear INTERRUPT bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_INTERRUPT_DRIVEN); /* set INTERRUPT bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setThresholds(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_THRESHOLDS_ENABLED); /* clear THRESHOLDS bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_THRESHOLDS_ENABLED); /* set THRESHOLDS bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setDriveMode(uint8_t mode)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    if (mode > 4) mode = 4; /* sanitize input */\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value)!=0) return CCS811_I2C_ERROR;\r\n    value &= ~(0b00000111 << 4); /* clear DRIVE_MODE bits */\r\n    value |= (mode << 4); /* mask in mode */\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* check for invalid temperatures */\r\n    if ((temperature < -25) || (temperature > 50)) return CCS811_GENERIC_ERROR;\r\n\r\n    /* check for invalid humidity */\r\n    if ((relativeHumidity < 0) || (relativeHumidity > 100)) return CCS811_GENERIC_ERROR;\r\n\r\n    uint32_t rH = relativeHumidity * 1000; /* 42.348 becomes 42348 */\r\n    uint32_t temp = temperature * 1000; /* 23.2 becomes 23200 */\r\n\r\n    uint8_t envData[4];\r\n\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;\r\n    envData[1] = 0; /* support only increments of 0.5 so bits 7-0 will always be zero */\r\n    if (((rH % 1000) / 100) > 2 && (((rH % 1000) / 100) < 8))\r\n    {\r\n        envData[0] |= 1; /* set 9th bit of fractional to indicate 0.5% */\r\n    }\r\n\r\n    temp += 25000; /* add the 25C offset */\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;\r\n    envData[3] = 0;\r\n    if (((temp % 1000) / 100) > 2 && (((temp % 1000) / 100) < 8))\r\n    {\r\n        envData[2] |= 1;  /* set 9th bit of fractional to indicate 0.5C */\r\n    }\r\n    if (CCS811_multiWriteRegister(CCS811_ENV_DATA, envData, 4)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nvoid CCS811_setRefResistance(float input)\r\n{\r\n    refResistance = input;\r\n}\r\n\r\nCCS811_status CCS811_readNTC(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_NTC, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    vrefCounts = ((uint16_t)data[0] << 8) | data[1];\r\n    ntcCounts = ((uint16_t)data[2] << 8) | data[3];\r\n    resistance = ((float)ntcCounts * refResistance / (float)vrefCounts);\r\n\r\n    temperature = log((long)resistance);\r\n    temperature = 1 / (0.001129148 + (0.000234125 * temperature) + (0.0000000876741 * temperature * temperature * temperature));\r\n    temperature = temperature - 273.15;  /* convert from Kelvin to Celsius */\r\n\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nuint16_t CCS811_getTVOC(void)\r\n{\r\n    return tVOC;\r\n}\r\n\r\nuint16_t CCS811_getCO2(void)\r\n{\r\n    return CO2;\r\n}\r\n\r\nfloat CCS811_getResistance(void)\r\n{\r\n    return resistance;\r\n}\r\n\r\nfloat CCS811_getTemperature(void)\r\n{\r\n    return temperature;\r\n}\r\n\r\n"
              }
            }
          }
        },
        "fxos8700": {
          "libName": "fxos8700",
          "manufacturer": "NXP Semiconductors",
          "description": "FXOS8700 Accelerometer/Magnetometer",
          "type": "Accelerometer + Magnetometer",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/adafruit-industries-llc/3463/1528-2130-ND/7064490"
              },
              "cartData": {
                "part": " 1528-2130-ND",
                "partid": "3463",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "gpio"
          ],
          "elements": [
            {
              "name": "FXOS8700AccelerometerMagnetometer",
              "type": "EmbeddedFXOS8700",
              "icon": "EmbeddedAccelerometerMagnetometer.svg",
              "defaultAbility": "getAccelData",
              "defaultTrigger": "accelDataRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/nxpfxos8700element.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "hidden": true,
                  "code": "\tATMO_FXOS8700_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.int1En = ATMO_PROPERTY(undefined, interrupt1Enabled);\n    config.int2En = ATMO_PROPERTY(undefined, interrupt2Enabled);\n    config.int1Pin = ATMO_PROPERTY(undefined, interrupt1Gpio);\n    config.int2Pin = ATMO_PROPERTY(undefined, interrupt2Gpio);\n\n    switch(ATMO_PROPERTY(undefined, motionDetectType))\n    {\n        case FXOS8700_NoDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_FreefallDetect:\n        {\n            config.freefallEnabled = true;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_MotionDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = true;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_TapDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = true;\n            break; \n        }\n        default:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;  \n            config.tapDetectionEnabled = false;\n            break;\n        }\n    }\n\n    ATMO_FXOS8700_SetMotionDetectedAbilityHandle(ATMO_ABILITY(undefined, detectMotion));\n    ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(ATMO_ABILITY(undefined, detectFreefall));\n    ATMO_FXOS8700_SetTapDetectedAbilityHandle(ATMO_ABILITY(undefined, detectTap));\n\tATMO_FXOS8700_Init(&config);\n\n    return ATMO_Status_Success;\n\t"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_FXOS8700_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_FXOS8700_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_FXOS8700_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "getAccelData",
                  "triggers": [
                    "accelDataRead"
                  ],
                  "code": "    ATMO_3dFloatVector_t data;\r\n\r\n    if( ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success )\r\n    {\r\n        ATMO_CreateValueVoid(out);\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &data);\r\n\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "getAccelX",
                  "triggers": [
                    "accelXRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.x);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getAccelY",
                  "triggers": [
                    "accelYRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.y);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getAccelZ",
                  "triggers": [
                    "accelZRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.z);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getMagData",
                  "triggers": [
                    "magDataRead"
                  ],
                  "code": "    ATMO_3dFloatVector_t data;\r\n\r\n    if( ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success )\r\n    {\r\n        ATMO_CreateValueVoid(out);\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &data);\r\n\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "getMagX",
                  "triggers": [
                    "magXRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.x);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getMagY",
                  "triggers": [
                    "magYRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.y);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getMagZ",
                  "triggers": [
                    "magZRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.z);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "detectTap",
                  "triggers": [
                    "tapDetected"
                  ],
                  "hidden": true,
                  "code": "\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "detectMotion",
                  "triggers": [
                    "motionDetected"
                  ],
                  "hidden": true,
                  "code": "\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "detectFreefall",
                  "triggers": [
                    "freefallDetected"
                  ],
                  "hidden": true,
                  "code": "\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "enableFreefallDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_EnableFreefallDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                },
                {
                  "name": "enableMotionDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_EnableMotionDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                },
                {
                  "name": "enableTapDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_EnableTapDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                },
                {
                  "name": "disableDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_DisableAllDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interrupt1Enabled",
                  "input": "checkbox",
                  "value": false
                },
                {
                  "name": "interrupt2Enabled",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "interrupt1Gpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interrupt2Gpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "motionDetectType",
                  "input": "select",
                  "inputOptions": [
                    "FXOS8700_NoDetect",
                    "FXOS8700_FreefallDetect",
                    "FXOS8700_MotionDetect",
                    "FXOS8700_TapDetect"
                  ],
                  "value": "FXOS8700_NoDetect"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x1E"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedFXOS8700": "NXP FXOS8700",
                  "FXOS8700_NoDetect": "No Detection",
                  "FXOS8700_FreefallDetect": "Detect Freefall",
                  "FXOS8700_MotionDetect": "Detect Motion",
                  "FXOS8700_TapDetect": "Detect Tap",
                  "motionDetectType": "Motion Detection Type",
                  "i2cInstance": "I2C Driver Instance",
                  "gpioInstance": "GPIO Driver Instance",
                  "interrupt1Enabled": "Interrupt 1 Enabled",
                  "interrupt1Gpio": "Interrupt 1 GPIO Pin",
                  "interrupt2Enabled": "Interrupt 2 Enabled",
                  "interrupt2Gpio": "Interrupt 2 GPIO Pin",
                  "tapDetectEnabled": "Tap Detection Enabled",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "getAccelData": "Get Accelerometer Data",
                  "accelDataRead": "Accelerometer Data Read",
                  "getMagData": "Get Magnetometer Data",
                  "magDataRead": "Magnetometer Data Read",
                  "detectTap": "Detect Tap",
                  "detectMotionFreefall": "Detect Motion/Freefall",
                  "tapDetected": "Tap Detected",
                  "motionDetected": "Motion Detected",
                  "freefallDetected": "Freefall Detected",
                  "EmbeddedAccelerometerMagnetometer": "Accelerometer Magnetometer",
                  "getAccelX": "Get Accelerometer X Value",
                  "getAccelY": "Get Accelerometer Y Value",
                  "getAccelZ": "Get Accelerometer Z Value",
                  "getMagX": "Get Magnetometer X Value",
                  "getMagY": "Get Magnetometer Y Value",
                  "getMagZ": "Get Magnetometer Z Value",
                  "accelXRead": "Accelerometer X Value Read",
                  "accelYRead": "Accelerometer Y Value Read",
                  "accelZRead": "Accelerometer Z Value Read",
                  "magXRead": "Magnetometer X Value Read",
                  "magYRead": "Magnetometer Y Value Read",
                  "magZRead": "Magnetometer Z Value Read",
                  "disableDetection": "Disable All Detection",
                  "enableFreefallDetection": "Enable Freefall Detection",
                  "enableMotionDetection": "Enable Motion Detection",
                  "enableTapDetection": "Enable Tap Detection"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "fxos8700.h": "#ifndef _ATMO_FXOS8700_H_\n#define _ATMO_FXOS8700_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n#include \"../gpio/gpio.h\"\n\ntypedef enum {\n    ATMO_FXOS8700_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_FXOS8700_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_FXOS8700_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_FXOS8700_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_FXOS8700_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_FXOS8700_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    ATMO_DriverInstanceHandle_t gpioDriverInstance;\n    bool int1En;\n    ATMO_GPIO_Device_Pin_t int1Pin;\n    bool int2En;\n    ATMO_GPIO_Device_Pin_t int2Pin;\n    bool motionEnabled;\n    bool freefallEnabled;\n    bool tapDetectionEnabled;\n\n} ATMO_FXOS8700_Config_t;\n\ntypedef enum {\n\tFXOS8700_NoDetect,\n\tFXOS8700_FreefallDetect,\n\tFXOS8700_MotionDetect,\n    FXOS8700_TapDetect,\n} FXOS8700_Detect_t;\n\n/**\n * Initialize FXOS8700 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_Init(ATMO_FXOS8700_Config_t *config);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetConfiguration(const ATMO_FXOS8700_Config_t *config);\n\n/**\n * Enable/Disable FXOS8700 Driver\n *\n * @param[in] enabled\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of FXOS8700 driver\n *\n * @param[out] enabled\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetEnabled(bool *enabled);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetConfiguration(ATMO_FXOS8700_Config_t *config);\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetAccelData(ATMO_3dFloatVector_t *data);\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetMagData(ATMO_3dFloatVector_t *data);\n\n/**\n * Motion/Freefall detection\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedCallback(ATMO_Callback_t cb);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedCallback(ATMO_Callback_t cb);\n\n/**\n * Tap detection\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_IsTapDetected(bool *isTapDetected, bool *isDoubleTap);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedCallback(ATMO_Callback_t cb);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedCallback(ATMO_Callback_t cb);\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableFreefallDetection();\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableMotionDetection();\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableTapDetection();\nATMO_FXOS8700_Status_t ATMO_FXOS8700_DisableAllDetection();\n\n#endif\n",
                "fxos8700_internal.h": "/*\n * The Clear BSD License\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\n * Copyright 2016-2017 NXP\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided\n * that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#ifndef _FSL_FXOS_H_\n#define _FSL_FXOS_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n#define EN_FFMT_INTERRUPT\n#define EN_TAP_INTERRUPT\n\n\n#define SINGLE_TAP 1\n#define DOUBLE_TAP 1\n/*\n *  STATUS Register\n */\n#define FXOS8700_STATUS_00_REG 0x00\n            \n#define FXOS8700_ZYXOW_MASK 0x80\n#define FXOS8700_ZOW_MASK 0x40\n#define FXOS8700_YOW_MASK 0x20\n#define FXOS8700_XOW_MASK 0x10\n#define FXOS8700_ZYXDR_MASK 0x08\n#define FXOS8700_ZDR_MASK 0x04\n#define FXOS8700_YDR_MASK 0x02\n#define FXOS8700_XDR_MASK 0x01\n            \n/*          \n *  F_STATUS FIFO Status Register\n */         \n#define FXOS8700_F_STATUS_REG 0x00\n            \n#define FXOS8700_F_OVF_MASK 0x80\n#define FXOS8700_F_WMRK_FLAG_MASK 0x40\n#define FXOS8700_F_CNT5_MASK 0x20\n#define FXOS8700_F_CNT4_MASK 0x10\n#define FXOS8700_F_CNT3_MASK 0x08\n#define FXOS8700_F_CNT2_MASK 0x04\n#define FXOS8700_F_CNT1_MASK 0x02\n#define FXOS8700_F_CNT0_MASK 0x01\n#define FXOS8700_F_CNT_MASK 0x3F\n            \n/*          \n *  XYZ Data Registers\n */         \n#define FXOS8700_OUT_X_MSB_REG 0x01\n#define FXOS8700_OUT_X_LSB_REG 0x02\n#define FXOS8700_OUT_Y_MSB_REG 0x03\n#define FXOS8700_OUT_Y_LSB_REG 0x04\n#define FXOS8700_OUT_Z_MSB_REG 0x05\n#define FXOS8700_OUT_Z_LSB_REG 0x06\n            \n/*          \n *  F_SETUP FIFO Setup Register\n */         \n#define FXOS8700_F_SETUP_REG 0x09\n            \n#define FXOS8700_F_MODE1_MASK 0x80\n#define FXOS8700_F_MODE0_MASK 0x40\n#define FXOS8700_F_WMRK5_MASK 0x20\n#define FXOS8700_F_WMRK4_MASK 0x10\n#define FXOS8700_F_WMRK3_MASK 0x08\n#define FXOS8700_F_WMRK2_MASK 0x04\n#define FXOS8700_F_WMRK1_MASK 0x02\n#define FXOS8700_F_WMRK0_MASK 0x01\n#define FXOS8700_F_MODE_MASK 0xC0\n#define FXOS8700_F_WMRK_MASK 0x3F\n            \n#define FXOS8700_F_MODE_DISABLED 0x00\n#define FXOS8700_F_MODE_CIRCULAR (F_MODE0_MASK)\n#define FXOS8700_F_MODE_FILL (F_MODE1_MASK)\n#define FXOS8700_F_MODE_TRIGGER (F_MODE1_MASK + F_MODE0_MASK)\n            \n/*          \n *  TRIG_CFG FIFO Trigger Configuration Register\n */         \n#define FXOS8700_TRIG_CFG_REG 0x0A\n            \n#define FXOS8700_TRIG_TRANS_MASK 0x20\n#define FXOS8700_TRIG_LNDPRT_MASK 0x10\n#define FXOS8700_TRIG_PULSE_MASK 0x08\n#define FXOS8700_TRIG_FF_MT_MASK 0x04\n            \n/*          \n *  SYSMOD System Mode Register\n */         \n#define FXOS8700_SYSMOD_REG 0x0B\n            \n#define FXOS8700_FGERR_MASK 0x80 /* MMA8451 only */\n#define FXOS8700_FGT_4_MASK 0x40 /* MMA8451 only */\n#define FXOS8700_FGT_3_MASK 0x20 /* MMA8451 only */\n#define FXOS8700_FGT_2_MASK 0x10 /* MMA8451 only */\n#define FXOS8700_FGT_1_MASK 0x08 /* MMA8451 only */\n#define FXOS8700_FGT_0_MASK 0x04 /* MMA8451 only */\n#define FXOS8700_FGT_MASK 0x7C   /* MMA8451 only */\n#define FXOS8700_SYSMOD1_MASK 0x02\n#define FXOS8700_SYSMOD0_MASK 0x01\n#define FXOS8700_SYSMOD_MASK 0x03\n            \n#define FXOS8700_SYSMOD_STANDBY 0x00\n#define FXOS8700_SYSMOD_WAKE (SYSMOD0_MASK)\n#define FXOS8700_SYSMOD_SLEEP (SYSMOD1_MASK)\n            \n/*          \n *  INT_SOURCE System Interrupt Status Register\n */         \n#define FXOS8700_INT_SOURCE_REG 0x0C\n            \n#define FXOS8700_SRC_ASLP_MASK 0x80\n#define FXOS8700_SRC_FIFO_MASK 0x40\n#define FXOS8700_SRC_TRANS_MASK 0x20\n#define FXOS8700_SRC_LNDPRT_MASK 0x10\n#define FXOS8700_SRC_PULSE_MASK 0x08\n#define FXOS8700_SRC_FF_MT_MASK 0x04\n#define FXOS8700_SRC_DRDY_MASK 0x01\n            \n/*          \n *  WHO_AM_I Device ID Register\n */         \n#define FXOS8700_WHO_AM_I_REG 0x0D\n            \n/* Content */\n#define FXOS8700_kFXOS_WHO_AM_I_Device_ID 0xC7\n            \n/* XYZ_DATA_CFG Sensor Data Configuration Register */\n#define FXOS8700_XYZ_DATA_CFG_REG 0x0E\n            \n#define FXOS8700_HPF_OUT_MASK 0x10\n#define FXOS8700_FS1_MASK 0x02\n#define FXOS8700_FS0_MASK 0x01\n#define FXOS8700_FS_MASK 0x03\n            \n#define FXOS8700_FULL_SCALE_2G 0x00\n#define FXOS8700_FULL_SCALE_4G (FXOS8700_FS0_MASK)\n#define FXOS8700_FULL_SCALE_8G (FXOS8700_FS1_MASK)\n            \n/* HP_FILTER_CUTOFF High Pass Filter Register */\n#define FXOS8700_HP_FILTER_CUTOFF_REG 0x0F\n            \n#define FXOS8700_PULSE_HPF_BYP_MASK 0x20\n#define FXOS8700_PULSE_LPF_EN_MASK 0x10\n#define FXOS8700_SEL1_MASK 0x02\n#define FXOS8700_SEL0_MASK 0x01\n#define FXOS8700_SEL_MASK 0x03\n            \n/*          \n *  PL_STATUS Portrait/Landscape Status Register\n */         \n#define FXOS8700_PL_STATUS_REG 0x10\n            \n#define FXOS8700_NEWLP_MASK 0x80\n#define FXOS8700_LO_MASK 0x40\n#define FXOS8700_LAPO1_MASK 0x04\n#define FXOS8700_LAPO0_MASK 0x02\n#define FXOS8700_BAFRO_MASK 0x01\n#define FXOS8700_LAPO_MASK 0x06\n            \n/*          \n *  PL_CFG Portrait/Landscape Configuration Register\n */         \n#define FXOS8700_PL_CFG_REG 0x11\n            \n#define FXOS8700_DBCNTM_MASK 0x80\n#define FXOS8700_PL_EN_MASK 0x40\n            \n/*          \n *  PL_COUNT Portrait/Landscape Debounce Register\n */         \n#define FXOS8700_PL_COUNT_REG 0x12\n            \n/*          \n *  PL_BF_ZCMP Back/Front and Z Compensation Register\n */         \n#define FXOS8700_PL_BF_ZCOMP_REG 0x13\n            \n#define FXOS8700_BKFR1_MASK 0x80\n#define FXOS8700_BKFR0_MASK 0x40\n#define FXOS8700_ZLOCK2_MASK 0x04\n#define FXOS8700_ZLOCK1_MASK 0x02\n#define FXOS8700_ZLOCK0_MASK 0x01\n#define FXOS8700_BKFR_MASK 0xC0\n#define FXOS8700_ZLOCK_MASK 0x07\n            \n/*          \n *  PL_P_L_THS Portrait to Landscape Threshold Register\n */         \n#define FXOS8700_PL_P_L_THS_REG 0x14\n            \n#define FXOS8700_P_L_THS4_MASK 0x80\n#define FXOS8700_P_L_THS3_MASK 0x40\n#define FXOS8700_P_L_THS2_MASK 0x20\n#define FXOS8700_P_L_THS1_MASK 0x10\n#define FXOS8700_P_L_THS0_MASK 0x08\n#define FXOS8700_HYS2_MASK 0x04\n#define FXOS8700_HYS1_MASK 0x02\n#define FXOS8700_HYS0_MASK 0x01\n#define FXOS8700_P_L_THS_MASK 0xF8\n#define FXOS8700_HYS_MASK 0x07\n            \n/*          \n *  FF_MT_CFG Freefall and Motion Configuration Register\n */         \n#define FXOS8700_FF_MT_CFG_REG 0x15\n            \n#define FXOS8700_ELE_MASK 0x80\n#define FXOS8700_OAE_MASK 0x40\n#define FXOS8700_ZEFE_MASK 0x20\n#define FXOS8700_YEFE_MASK 0x10\n#define FXOS8700_XEFE_MASK 0x08\n            \n/*          \n *  FF_MT_SRC Freefall and Motion Source Registers\n */         \n#define FXOS8700_FF_MT_SRC_REG 0x16\n            \n#define FXOS8700_EA_MASK 0x80\n#define FXOS8700_ZHE_MASK 0x20\n#define FXOS8700_ZHP_MASK 0x10\n#define FXOS8700_YHE_MASK 0x08\n#define FXOS8700_YHP_MASK 0x04\n#define FXOS8700_XHE_MASK 0x02\n#define FXOS8700_XHP_MASK 0x01\n            \n/*          \n *  FF_MT_THS Freefall and Motion Threshold Registers\n *  TRANSIENT_THS Transient Threshold Register\n */         \n#define FXOS8700_FT_MT_THS_REG 0x17\n#define FXOS8700_TRANSIENT_THS_REG 0x1F\n            \n#define FXOS8700_DBCNTM_MASK 0x80\n#define FXOS8700_THS6_MASK 0x40\n#define FXOS8700_THS5_MASK 0x20\n#define FXOS8700_THS4_MASK 0x10\n#define FXOS8700_THS3_MASK 0x08\n#define FXOS8700_THS2_MASK 0x04\n#define FXOS8700_TXS1_MASK 0x02\n#define FXOS8700_THS0_MASK 0x01\n#define FXOS8700_THS_MASK 0x7F\n            \n/* FF_MT_COUNT Freefall Motion Count Registers */\n#define FXOS8700_FF_MT_COUNT_REG 0x18\n            \n/* TRANSIENT_CFG Transient Configuration Register */\n#define FXOS8700_TRANSIENT_CFG_REG 0x1D\n            \n#define FXOS8700_TELE_MASK 0x10\n#define FXOS8700_ZTEFE_MASK 0x08\n#define FXOS8700_YTEFE_MASK 0x04\n#define FXOS8700_XTEFE_MASK 0x02\n#define FXOS8700_HPF_BYP_MASK 0x01\n            \n/* TRANSIENT_SRC Transient Source Register */\n#define FXOS8700_TRANSIENT_SRC_REG 0x1E\n            \n#define FXOS8700_TEA_MASK 0x40\n#define FXOS8700_ZTRANSE_MASK 0x20\n#define FXOS8700_Z_TRANS_POL_MASK 0x10\n#define FXOS8700_YTRANSE_MASK 0x08\n#define FXOS8700_Y_TRANS_POL_MASK 0x04\n#define FXOS8700_XTRANSE_MASK 0x02\n#define FXOS8700_X_TRANS_POL_MASK 0x01\n            \n/* TRANSIENT_COUNT Transient Debounce Register */\n#define FXOS8700_TRANSIENT_COUNT_REG 0x20\n            \n/* PULSE_CFG Pulse Configuration Register */\n#define FXOS8700_PULSE_CFG_REG 0x21\n            \n#define FXOS8700_DPA_MASK 0x80\n#define FXOS8700_PELE_MASK 0x40\n#define FXOS8700_ZDPEFE_MASK 0x20\n#define FXOS8700_ZSPEFE_MASK 0x10\n#define FXOS8700_YDPEFE_MASK 0x08\n#define FXOS8700_YSPEFE_MASK 0x04\n#define FXOS8700_XDPEFE_MASK 0x02\n#define FXOS8700_XSPEFE_MASK 0x01\n            \n/* PULSE_SRC Pulse Source Register */\n#define FXOS8700_PULSE_SRC_REG 0x22\n            \n#define FXOS8700_PEA_MASK 0x80\n#define FXOS8700_AXZ_MASK 0x40\n#define FXOS8700_AXY_MASK 0x20\n#define FXOS8700_AXX_MASK 0x10\n#define FXOS8700_DPE_MASK 0x08\n#define FXOS8700_POLZ_MASK 0x04\n#define FXOS8700_POLY_MASK 0x02\n#define FXOS8700_POLX_MASK 0x01\n            \n/* PULSE_THS XYZ Pulse Threshold Registers */\n#define FXOS8700_PULSE_THSX_REG 0x23\n#define FXOS8700_PULSE_THSY_REG 0x24\n#define FXOS8700_PULSE_THSZ_REG 0x25\n            \n#define FXOS8700_PTHS_MASK 0x7F\n            \n/* PULSE_TMLT Pulse Time Window Register */\n#define FXOS8700_PULSE_TMLT_REG 0x26\n            \n/* PULSE_LTCY Pulse Latency Timer Register */\n#define FXOS8700_PULSE_LTCY_REG 0x27\n            \n/* PULSE_WIND Second Pulse Time Window Register */\n#define FXOS8700_PULSE_WIND_REG 0x28\n            \n/* ASLP_COUNT Auto Sleep Inactivity Timer Register */\n#define FXOS8700_ASLP_COUNT_REG 0x29\n            \n/* CTRL_REG1 System Control 1 Register */\n#define FXOS8700_CTRL_REG1 0x2A\n            \n#define FXOS8700_ASLP_RATE1_MASK 0x80\n#define FXOS8700_ASLP_RATE0_MASK 0x40\n#define FXOS8700_DR2_MASK 0x20\n#define FXOS8700_DR1_MASK 0x10\n#define FXOS8700_DR0_MASK 0x08\n#define FXOS8700_LNOISE_MASK 0x04\n#define FXOS8700_FREAD_MASK 0x02\n#define FXOS8700_ACTIVE_MASK 0x01\n#define FXOS8700_ASLP_RATE_MASK 0xC0\n#define FXOS8700_DR_MASK 0x38\n            \n#define FXOS8700_ASLP_RATE_20MS 0x00\n#define FXOS8700_ASLP_RATE_80MS (FXOS8700_ASLP_RATE0_MASK)\n#define FXOS8700_ASLP_RATE_160MS (FXOS8700_ASLP_RATE1_MASK)\n#define FXOS8700_ASLP_RATE_640MS (FXOS8700_ASLP_RATE1_MASK + FXOS8700_ASLP_RATE0_MASK)\n            \n#define FXOS8700_ASLP_RATE_50HZ (FXOS8700_ASLP_RATE_20MS)\n#define FXOS8700_ASLP_RATE_12_5HZ (FXOS8700_ASLP_RATE_80MS)\n#define FXOS8700_ASLP_RATE_6_25HZ (FXOS8700_ASLP_RATE_160MS)\n#define FXOS8700_ASLP_RATE_1_56HZ (FXOS8700_ASLP_RATE_640MS)\n            \n#define FXOS8700_HYB_ASLP_RATE_25HZ (FXOS8700_ASLP_RATE_20MS)\n#define FXOS8700_HYB_ASLP_RATE_6_25HZ (FXOS8700_ASLP_RATE_80MS)\n#define FXOS8700_HYB_ASLP_RATE_1_56HZ (FXOS8700_ASLP_RATE_160MS)\n#define FXOS8700_HYB_ASLP_RATE_0_8HZ (FXOS8700_ASLP_RATE_640MS)\n            \n#define FXOS8700_DATA_RATE_1250US 0x00\n#define FXOS8700_DATA_RATE_2500US (FXOS8700_DR0_MASK)\n#define FXOS8700_DATA_RATE_5MS (FXOS8700_DR1_MASK)\n#define FXOS8700_DATA_RATE_10MS (FXOS8700_DR1_MASK + FXOS8700_DR0_MASK)\n#define FXOS8700_DATA_RATE_20MS (FXOS8700_DR2_MASK)\n#define FXOS8700_DATA_RATE_80MS (FXOS8700_DR2_MASK + FXOS8700_DR0_MASK)\n#define FXOS8700_DATA_RATE_160MS (FXOS8700_DR2_MASK + FXOS8700_DR1_MASK)\n#define FXOS8700_DATA_RATE_640MS (FXOS8700_DR2_MASK + FXOS8700_DR1_MASK + FXOS8700_DR0_MASK)\n            \n#define FXOS8700_DATA_RATE_800HZ (FXOS8700_DATA_RATE_1250US)\n#define FXOS8700_DATA_RATE_400HZ (FXOS8700_DATA_RATE_2500US)\n#define FXOS8700_DATA_RATE_200HZ (FXOS8700_DATA_RATE_5MS)\n#define FXOS8700_DATA_RATE_100HZ (FXOS8700_DATA_RATE_10MS)\n#define FXOS8700_DATA_RATE_50HZ (FXOS8700_DATA_RATE_20MS)\n#define FXOS8700_DATA_RATE_12_5HZ (FXOS8700_DATA_RATE_80MS)\n#define FXOS8700_DATA_RATE_6_25HZ (FXOS8700_DATA_RATE_160MS)\n#define FXOS8700_DATA_RATE_1_56HZ (FXOS8700_DATA_RATE_640MS)\n            \n/* for hybrid (TO, Aug 2012) */\n#define FXOS8700_HYB_DATA_RATE_400HZ (FXOS8700_DATA_RATE_1250US)\n#define FXOS8700_HYB_DATA_RATE_200HZ (FXOS8700_DATA_RATE_2500US)\n#define FXOS8700_HYB_DATA_RATE_100HZ (FXOS8700_DATA_RATE_5MS)\n#define FXOS8700_HYB_DATA_RATE_50HZ (FXOS8700_DATA_RATE_10MS)\n#define FXOS8700_HYB_DATA_RATE_25HZ (FXOS8700_DATA_RATE_20MS)\n#define FXOS8700_HYB_DATA_RATE_6_25HZ (FXOS8700_DATA_RATE_80MS)\n#define FXOS8700_HYB_DATA_RATE_3_15HZ (FXOS8700_DATA_RATE_160MS)\n#define FXOS8700_HYB_DATA_RATE_0_8HZ (FXOS8700_DATA_RATE_640MS)\n            \n#define FXOS8700_ACTIVE (FXOS8700_ACTIVE_MASK)\n#define FXOS8700_STANDBY 0x00\n            \n/* CTRL_REG2 System Control 2 Register */\n#define FXOS8700_CTRL_REG2 0x2B\n            \n#define FXOS8700_ST_MASK 0x80\n#define FXOS8700_RST_MASK 0x40\n#define FXOS8700_SMODS1_MASK 0x10\n#define FXOS8700_SMODS0_MASK 0x08\n#define FXOS8700_SLPE_MASK 0x04\n#define FXOS8700_MODS1_MASK 0x02\n#define FXOS8700_MODS0_MASK 0x01\n#define FXOS8700_SMODS_MASK 0x18\n#define FXOS8700_MODS_MASK 0x03\n            \n#define FXOS8700_SMOD_NORMAL 0x00\n#define FXOS8700_SMOD_LOW_NOISE (FXOS8700_SMODS0_MASK)\n#define FXOS8700_SMOD_HIGH_RES (FXOS8700_SMODS1_MASK)\n#define FXOS8700_SMOD_LOW_POWER (FXOS8700_SMODS1_MASK + FXOS8700_SMODS0_MASK)\n            \n#define FXOS8700_MOD_NORMAL 0x00\n#define FXOS8700_MOD_LOW_NOISE (FXOS8700_MODS0_MASK)\n#define FXOS8700_MOD_HIGH_RES (FXOS8700_MODS1_MASK)\n#define FXOS8700_MOD_LOW_POWER (FXOS8700_MODS1_MASK + FXOS8700_MODS0_MASK)\n            \n/* CTRL_REG3 Interrupt Control Register */\n#define FXOS8700_CTRL_REG3 0x2C\n            \n#define FXOS8700_FIFO_GATE_MASK 0x80\n#define FXOS8700_WAKE_TRANS_MASK 0x40\n#define FXOS8700_WAKE_LNDPRT_MASK 0x20\n#define FXOS8700_WAKE_PULSE_MASK 0x10\n#define FXOS8700_WAKE_FF_MT_MASK 0x08\n#define FXOS8700_IPOL_MASK 0x02\n#define FXOS8700_PP_OD_MASK 0x01\n            \n/* CTRL_REG4 Interrupt Enable Register */\n#define FXOS8700_CTRL_REG4 0x2D\n            \n#define FXOS8700_INT_EN_ASLP_MASK 0x80\n#define FXOS8700_INT_EN_FIFO_MASK 0x40\n#define FXOS8700_INT_EN_TRANS_MASK 0x20\n#define FXOS8700_INT_EN_LNDPRT_MASK 0x10\n#define FXOS8700_INT_EN_PULSE_MASK 0x08\n#define FXOS8700_INT_EN_FF_MT_MASK 0x04\n#define FXOS8700_INT_EN_DRDY_MASK 0x01\n            \n/* CTRL_REG5 Interrupt Configuration Register */\n#define FXOS8700_CTRL_REG5 0x2E\n            \n#define FXOS8700_INT_CFG_ASLP_MASK 0x80\n#define FXOS8700_INT_CFG_FIFO_MASK 0x40\n#define FXOS8700_INT_CFG_TRANS_MASK 0x20\n#define FXOS8700_INT_CFG_LNDPRT_MASK 0x10\n#define FXOS8700_INT_CFG_PULSE_MASK 0x08\n#define FXOS8700_INT_CFG_FF_MT_MASK 0x04\n#define FXOS8700_INT_CFG_DRDY_MASK 0x01\n            \n/* XYZ Offset Correction Registers */\n#define FXOS8700_OFF_X_REG 0x2F\n#define FXOS8700_OFF_Y_REG 0x30\n#define FXOS8700_OFF_Z_REG 0x31\n            \n/* M_DR_STATUS Register */\n#define FXOS8700_M_DR_STATUS_REG 0x32\n            \n#define FXOS8700_ZYXOW_MASK 0x80\n#define FXOS8700_ZOW_MASK 0x40\n#define FXOS8700_YOW_MASK 0x20\n#define FXOS8700_XOW_MASK 0x10\n#define FXOS8700_ZYXDR_MASK 0x08\n#define FXOS8700_ZDR_MASK 0x04\n#define FXOS8700_YDR_MASK 0x02\n#define FXOS8700_XDR_MASK 0x01\n            \n/* MAG XYZ Data Registers */\n#define FXOS8700_M_OUT_X_MSB_REG 0x33\n#define FXOS8700_M_OUT_X_LSB_REG 0x34\n#define FXOS8700_M_OUT_Y_MSB_REG 0x35\n#define FXOS8700_M_OUT_Y_LSB_REG 0x36\n#define FXOS8700_M_OUT_Z_MSB_REG 0x37\n#define FXOS8700_M_OUT_Z_LSB_REG 0x38\n            \n/* MAG CMP Data Registers */\n#define FXOS8700_CMP_X_MSB_REG 0x39\n#define FXOS8700_CMP_X_LSB_REG 0x3A\n#define FXOS8700_CMP_Y_MSB_REG 0x3B\n#define FXOS8700_CMP_Y_LSB_REG 0x3C\n#define FXOS8700_CMP_Z_MSB_REG 0x3D\n#define FXOS8700_CMP_Z_LSB_REG 0x3E\n            \n/* MAG XYZ Offset Correction Registers */\n#define FXOS8700_M_OFF_X_MSB_REG 0x3F\n#define FXOS8700_M_OFF_X_LSB_REG 0x40\n#define FXOS8700_M_OFF_Y_MSB_REG 0x41\n#define FXOS8700_M_OFF_Y_LSB_REG 0x42\n#define FXOS8700_M_OFF_Z_MSB_REG 0x43\n#define FXOS8700_M_OFF_Z_LSB_REG 0x44\n            \n/* MAG MAX XYZ Registers */\n#define FXOS8700_MAX_X_MSB_REG 0x45\n#define FXOS8700_MAX_X_LSB_REG 0x46\n#define FXOS8700_MAX_Y_MSB_REG 0x47\n#define FXOS8700_MAX_Y_LSB_REG 0x48\n#define FXOS8700_MAX_Z_MSB_REG 0x49\n#define FXOS8700_MAX_Z_LSB_REG 0x4A\n            \n/* MAG MIN XYZ Registers */\n#define FXOS8700_MIN_X_MSB_REG 0x4B\n#define FXOS8700_MIN_X_LSB_REG 0x4C\n#define FXOS8700_MIN_Y_MSB_REG 0x4D\n#define FXOS8700_MIN_Y_LSB_REG 0x4E\n#define FXOS8700_MIN_Z_MSB_REG 0x4F\n#define FXOS8700_MIN_Z_LSB_REG 0x50\n            \n/* TEMP Registers */\n#define FXOS8700_TEMP_REG 0x51\n            \n/* M_THS CONFIG Registers */\n#define FXOS8700_M_THS_CFG_REG 0x52\n            \n/* M_THS SRC Registers */\n#define FXOS8700_M_THS_SRC_REG 0x53\n            \n/* MAG THRESHOLD XYZ Registers */\n#define FXOS8700_M_THS_X_MSB_REG 0x54\n#define FXOS8700_M_THS_X_LSB_REG 0x55\n#define FXOS8700_M_THS_Y_MSB_REG 0x56\n#define FXOS8700_M_THS_Y_LSB_REG 0x57\n#define FXOS8700_M_THS_Z_MSB_REG 0x58\n#define FXOS8700_M_THS_Z_LSB_REG 0x59\n            \n/* M_THS COUNT Registers */\n#define FXOS8700_M_THS_COUNT 0x5A\n            \n/* MAG CTRL_REG1 System Control 1 Register */\n#define FXOS8700_M_CTRL_REG1 0x5B\n            \n#define FXOS8700_M_ACAL_MASK 0x80\n#define FXOS8700_M_RST_MASK 0x40\n#define FXOS8700_M_OST_MASK 0x20\n#define FXOS8700_M_OSR2_MASK 0x10\n#define FXOS8700_M_OSR1_MASK 0x08\n#define FXOS8700_M_OSR0_MASK 0x04\n#define FXOS8700_M_HMS1_MASK 0x02\n#define FXOS8700_M_HMS0_MASK 0x01\n#define FXOS8700_M_OSR_MASK 0x1C\n#define FXOS8700_M_HMS_MASK 0x03\n            \n/* OSR Selections */\n#define FXOS8700_M_OSR_1_56_HZ 0x00\n#define FXOS8700_M_OSR_6_25_HZ FXOS8700_M_OSR0_MASK\n#define FXOS8700_M_OSR_12_5_HZ FXOS8700_M_OSR1_MASK\n#define FXOS8700_M_OSR_50_HZ   FXOS8700_M_OSR1_MASK + FXOS8700_M_OSR0_MASK\n#define FXOS8700_M_OSR_100_HZ  FXOS8700_M_OSR2_MASK\n#define FXOS8700_M_OSR_200_HZ  FXOS8700_M_OSR2_MASK + FXOS8700_M_OSR0_MASK\n#define FXOS8700_M_OSR_400_HZ  FXOS8700_M_OSR2_MASK + FXOS8700_M_OSR1_MASK\n#define FXOS8700_M_OSR_800_HZ  FXOS8700_M_OSR2_MASK + FXOS8700_M_OSR1_MASK + M_OSR0_MASK\n            \n/* Hybrid Mode Selection */\n#define FXOS8700_ACCEL_ACTIVE 0x00\n#define FXOS8700_MAG_ACTIVE FXOS8700_M_HMS0_MASK\n#define FXOS8700_HYBRID_ACTIVE (FXOS8700_M_HMS1_MASK | FXOS8700_M_HMS0_MASK)\n            \n/* MAG CTRL_REG2 System Control 2 Register */\n#define FXOS8700_M_CTRL_REG2 0x5C\n            \n#define FXOS8700_M_HYB_AUTOINC_MASK 0x20\n#define FXOS8700_M_MAXMIN_DIS_MASK 0x10\n#define FXOS8700_M_MAXMIN_DIS_THS_MASK 0x08\n#define FXOS8700_M_MAXMIN_RST_MASK 0x04\n#define FXOS8700_M_RST_CNT1_MASK 0x02\n#define FXOS8700_M_RST_CNT0_MASK 0x01\n            \n/* Mag Auto-Reset De-Gauss Frequency */\n#define FXOS8700_RST_ODR_CYCLE 0x00\n#define FXOS8700_RST_16_ODR_CYCLE FXOS8700_M_RST_CNT0_MASK\n#define FXOS8700_RST_512_ODR_CYCLE FXOS8700_M_RST_CNT1_MASK\n#define FXOS8700_RST_DISABLED FXOS8700_M_RST_CNT1_MASK + FXOS8700_M_RST_CNT0_MASK\n            \n/* MAG CTRL_REG3 System Control 3 Register */\n#define FXOS8700_M_CTRL_REG3 0x5D\n            \n#define FXOS8700_M_RAW_MASK 0x80\n#define FXOS8700_M_ASLP_OS_2_MASK 0x40\n#define FXOS8700_M_ASLP_OS_1_MASK 0x20\n#define FXOS8700_M_ASLP_OS_0_MASK 0x10\n#define FXOS8700_M_THS_XYZ_MASK 0x08\n#define FXOS8700_M_ST_Z_MASK 0x04\n#define FXOS8700_M_ST_XY1_MASK 0x02\n#define FXOS8700_M_ST_XY0_MASK 0x01\n#define FXOS8700_M_ASLP_OSR_MASK 0x70\n#define FXOS8700_M_ST_XY_MASK 0x03\n            \n/* OSR Selections */\n#define FXOS8700_M_ASLP_OSR_1_56_HZ 0x00\n#define FXOS8700_M_ASLP_OSR_6_25_HZ FXOS8700_M_ASLP_OS_0_MASK\n#define FXOS8700_M_ASLP_OSR_12_5_HZ FXOS8700_M_ASLP_OS_1_MASK\n#define FXOS8700_M_ASLP_OSR_50_HZ  FXOS8700_M_ASLP_OS_1_MASK + FXOS8700_M_ASLP_OS_0_MASK\n#define FXOS8700_M_ASLP_OSR_100_HZ FXOS8700_M_ASLP_OS_2_MASK\n#define FXOS8700_M_ASLP_OSR_200_HZ FXOS8700_M_ASLP_OS_2_MASK + FXOS8700_M_ASLP_OS_0_MASK\n#define FXOS8700_M_ASLP_OSR_400_HZ FXOS8700_M_ASLP_OS_2_MASK + FXOS8700_M_ASLP_OS_1_MASK\n#define FXOS8700_M_ASLP_OSR_800_HZ FXOS8700_M_ASLP_OS_2_MASK + FXOS8700_M_ASLP_OS_1_MASK + FXOS8700_M_ASLP_OS_0_MASK\n            \n/* MAG INT SOURCE Register */\n#define FXOS8700_M_INT_SOURCE 0x5E\n            \n#define FXOS8700_SRC_M_DRDY_MASK 0x04\n#define FXOS8700_SRC_M_VECM_MASK 0x02\n#define FXOS8700_SRC_M_THS_MASK 0x01\n            \n/* ACCEL VECTOR CONFIG Register */\n#define FXOS8700_A_VECM_CFG 0x5F\n            \n#define FXOS8700_A_VECM_INIT_CFG_MASK 0x40\n#define FXOS8700_A_VECM_INIT_EN_MASK 0x20\n#define FXOS8700_A_VECM_WAKE_EN_MASK 0x10\n#define FXOS8700_A_VECM_EN_MASK 0x08\n#define FXOS8700_A_VECM_UPDM_MASK 0x04\n#define FXOS8700_A_VECM_INITM_MASK 0x02\n#define FXOS8700_A_VECM_ELE_MASK 0x01\n            \n/* ACCEL VECTOR THS MSB AND LSB Register */\n#define FXOS8700_A_VECM_THS_MSB 0x60\n            \n#define FXOS8700_A_VECM_DBCNTM_MASK 0x80\n            \n#define FXOS8700_A_VECM_THS_LSB 0x61\n            \n/* ACCEL VECTOR CNT Register */\n#define FXOS8700_A_VECM_CNT 0x62\n            \n/* ACCEL INI8700TIAL XYZ VECTORS Register */\n#define FXOS8700_A_VECM_INITX_MSB 0x63\n#define FXOS8700_A_VECM_INITX_LSB 0x64\n#define FXOS8700_A_VECM_INITY_MSB 0x65\n#define FXOS8700_A_VECM_INITY_LSB 0x66\n#define FXOS8700_A_VECM_INITZ_MSB 0x67\n#define FXOS8700_A_VECM_INITZ_LSB 0x68\n            \n/* MAG VECTOR CONFIG Register */\n#define FXOS8700_M_VECM_CFG 0x69\n            \n#define FXOS8700_M_VECM_INIT_CFG_MASK 0x40\n#define FXOS8700_M_VECM_INIT_EN_MASK 0x20\n#define FXOS8700_M_VECM_WAKE_EN_MASK 0x10\n#define FXOS8700_M_VECM_EN_MASK 0x08\n#define FXOS8700_M_VECM_UPDM_MASK 0x04\n#define FXOS8700_M_VECM_INITM_MASK 0x02\n#define FXOS8700_M_VECM_ELE_MASK 0x01\n            \n/* MAG VECTOR THS MSB AND LSB Register */\n#define FXOS8700_M_VECM_THS_MSB 0x6A\n            \n#define FXOS8700_M_VECM_DBCNTM_MASK 0x80\n            \n#define FXOS8700_M_VECM_THS_LSB 0x6B\n            \n/* MAG VECTOR CNT Register */\n#define FXOS8700_M_VECM_CNT 0x6C\n            \n/* MAG INITIAL XYZ VECTORS Register */\n#define FXOS8700_M_VECM_INITX_MSB 0x6D\n#define FXOS8700_M_VECM_INITX_LSB 0x6E\n#define FXOS8700_M_VECM_INITY_MSB 0x6F\n#define FXOS8700_M_VECM_INITY_LSB 0x70\n#define FXOS8700_M_VECM_INITZ_MSB 0x71\n#define FXOS8700_M_VECM_INITZ_LSB 0x72\n            \n/* ACCEL FFMT THS X MSB AND LSB Register */\n#define FXOS8700_A_FFMT_THS_X_MSB 0x73\n            \n#define FXOS8700_A_FFMT_THS_XYZ_EN_MASK 0x80\n            \n#define FXOS8700_A_FFMT_THS_X_LSB 0x74\n            \n#define FXOS8700_A_FFMT_THS_X_LSB_MASK 0xFC\n            \n/* ACCEL FFMT THS Y MSB AND LSB Register */\n#define FXOS8700_A_FFMT_THS_Y_MSB 0x75\n            \n#define FXOS8700_A_FFMT_THS_Y_EN_MASK 0x80\n            \n#define FXOS8700_A_FFMT_THS_Y_LSB 0x76\n            \n#define FXOS8700_A_FFMT_THS_Y_LSB_MASK 0xFC\n            \n/* ACCEL FFMT THS Z MSB AND LSB Register */\n#define FXOS8700_A_FFMT_THS_Z_MSB 0x77\n            \n#define FXOS8700_A_FFMT_THS_Z_EN_MASK 0x80\n            \n#define FXOS8700_A_FFMT_THS_Z_LSB 0x78\n            \n#define FXOS8700_A_FFMT_THS_Z_LSB_MASK 0xFC\n            \n/* ACCEL TRANSIENT INIT Register */\n#define FXOS8700_A_TRAN_INIT_XYZ_MSB 0x79\n#define FXOS8700_A_TRAN_INIT_X_LSB 0x7A\n#define FXOS8700_A_TRAN_INIT_Y_LSB 0x7B\n#define FXOS8700_A_TRAN_INIT_Z_LSB 0x7C\n\n/*! @brief fxos8700cq configure definition. This structure should be global.*/\ntypedef struct _fxos8700_handle\n{\n\t  uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\n\t  uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\n\t  void      (*WaitMsec)(uint32_t millisec);\n} fxos8700_handle_t;\n\ntypedef struct _fxos8700cq_data\n{\n    uint8_t accelXMSB;\n    uint8_t accelXLSB;\n    uint8_t accelYMSB;\n    uint8_t accelYLSB;\n    uint8_t accelZMSB;\n    uint8_t accelZLSB;\n    uint8_t magXMSB;\n    uint8_t magXLSB;\n    uint8_t magYMSB;\n    uint8_t magYLSB;\n    uint8_t magZMSB;\n    uint8_t magZLSB;\n} fxos8700_data_t;\n\n/*!\n * @addtogroup fxos8700_common\n * @{\n */\n\ntypedef int32_t fxos8700_status_t;\n#define FXOS8700_Status_Success (0)\n#define FXOS8700_Status_Fail (1)\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/*!\n * @brief Verify and initialize fxos8700_handle ice: Hybrid mode with ODR=200Hz, Mag OSR=32, Acc OSR=Normal.\n * Interrupt for data ready can be set using #define EN_FXOS_DATAREADY_INTERRUPT\n *\n * @param fxos8700_handle The pointer to accel driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Read data from sensors, assumes hyb_autoinc_mode is set in M_CTRL_REG2\n *\n * @param fxos8700_handle The pointer to accel driver handle.\n * @param sensorData The pointer to the buffer to hold sensor data\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_ReadSensorData(fxos8700_handle_t *fxos8700_handle, fxos8700_data_t *sensorData);\n\n/*!\n * @brief Write value to register of sensor.\n *\n * @param handle The pointer to fxos8700cq driver handle.\n * @param reg Register address.\n * @param val Data want to write.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_WriteReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t val);\n\n/*!\n * @brief Read n bytes start at register from sensor.\n *\n * @param handle The pointer to fxos8700cq driver handle.\n * @param reg Register address.\n * @param val The pointer to address which store data.\n * @param bytesNumber Number of bytes receiver.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_ReadReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t *val, uint8_t bytesNumber);\n\n/*!\n * @brief Puts the FXOS8700CQ into Standby Mode\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_SetStandby(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Puts the FXOS8700CQ int Active Mode\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_SetActive(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Motion Detection on x and y axis with 0.5g Threshold. \n * NOTE: Motion Detect and FreeFall Detect shares the same hardware block so only one function can be initialized/used at a time. \n * Please refer to NXP Application Note AN4070: Motion and Freefall Detection Using the MMA8451, 2, 3Q\n * on how to configure the Motion Detection parameters. FXOS8700CQ shares the same registers and hardware blocks\n * as the MMA8451 so AN4070 is applicable for this sensor.\n *\n * Interrupts can be set with #define EN_FFMT_INTERRUPT. \n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_MotionDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Freefall Detection on z axis with 0.25g Threshold. \n * NOTE: Motion Detect and FreeFall Detect shares the same hardware block so only one function can be initialized/used at a time. \n * Please refer to NXP Application Note AN4070: Motion and Freefall Detection Using the MMA8451, 2, 3Q\n * on how to configure the Freefall Detection parameters. FXOS8700CQ shares the same registers and hardware blocks\n * as the MMA8451 so AN4070 is applicable for this sensor.\n *\n * Interrupts can be set with #define EN_FFMT_INTERRUPT. \n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_FreefallDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Tap Detection (also called Pulse Detection) \n * Pulse Thresholds: X:2g Y:2g Z:3g \n * Pulse Time Window: 6 counts\n * Pulse Latency Timer: 40 counts\n * Pulse 2nd Time Window: 15 counts\n *\n * Please refer to NXP Application Note AN4072: MMA8451, 2, 3Q Single/Double and Directional Tap Detection\n * on how to configure the Tap Detection parameters. FXOS8700CQ shares the same registers and hardware blocks\n * as the MMA8451 so AN4072 is applicable for this sensor.\n *\n * Interrupts can be set with #define EN_TAP_INTERRUPT. \n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_TapDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Disables either freefall or motion detection. \n * Disables the associated interrupts if enabled\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_FreefallMotion_DeInit(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Disables Tap Detection. \n * Disables the associated interrupts if enabled\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_TapDetect_DeInit(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Transient Detection on x,y,z axis with 0.25g Threshold and High-Pass Filter to 2 Hz (OSR= 200Hz,High Res)\n * Transient Detection is similar to Motion Detection except it only detects dynamic acceleration. It will not register\n * static acceleration such as gravity.\n *\n * Please refer to NXP Application Note AN4071: High-Pass Filtered Data and Transient Detection Using the MMA8451, 2, 3Q\n * on how to configure the Transient Detection parameters. It also lists when to use transient detection and when to use motion detection.\n * FXOS8700CQ shares the same registers and hardware blocks as the MMA8451 so AN4071 is applicable for this sensor.\n *\n * Interrupts can be set with \\#define EN_TRANS_INTERRUPT.\n * Interrupts when enabled goes to INT2 pin, set to INT1 pin using \\#define EN_TRANS_INT1_PIN\n *\n * @param fxos8700_handle The pointer to fxos8700cq driver handle.\n *\n * @return kStatus_Success if success or kStatus_Fail if error.\n */\nfxos8700_status_t FXOS8700_TransientDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Disables Transient detection.\n * Disables the associated interrupts if enabled\n *\n * @param fxos8700_handle The pointer to fxos8700cq driver handle.\n *\n * @return kStatus_Success if success or kStatus_Fail if error.\n */\nfxos8700_status_t FXOS8700_TransientDetect_DeInit(fxos8700_handle_t *fxos8700_handle);\n\n\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* _FSL_FXOS_H_ */\n"
              },
              "objects": {
                "fxos8700.c": "#include \"fxos8700.h\"\n#include \"fxos8700_internal.h\"\n\ntypedef struct {\n    ATMO_FXOS8700_Config_t config;\n\n    unsigned int motionDetectedAbilityHandle;\n    ATMO_Callback_t motionDetectedCallback;\n    bool motionDetectedAbilityHandleRegistered;\n\n\tunsigned int freefallDetectedAbilityHandle;\n    ATMO_Callback_t freefallDetectedCallback;\n    bool freefallDetectedAbilityHandleRegistered;\n\n    unsigned int tapDetectedAbilityHandle;\n    ATMO_Callback_t tapDetectedCallback;\n    bool tapDetectedAbilityHandleRegistered;\n\n    unsigned int doubleTapDetectedAbilityHandle;\n    ATMO_Callback_t doubleTapDetectedCallback;\n    bool doubleTapDetectedAbilityHandleRegistered;\n\n    bool configured;\n} ATMO_FXOS8700_Priv_Config;\n\nstatic bool fxos8700Enabled = true;\n\nstatic ATMO_FXOS8700_Priv_Config _ATMO_FXOS8700_config = {0};\n\nstatic ATMO_I2C_Peripheral_t _ATMO_FXOS8700_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic fxos8700_handle_t handle;\n\nstatic uint8_t ATMO_FXOS8700_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_FXOS8700_config.config.i2cDriverInstance, _ATMO_FXOS8700_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t ATMO_FXOS8700_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_FXOS8700_config.config.i2cDriverInstance, _ATMO_FXOS8700_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic void ATMO_FXOS8700_INT_DoAbilityOrCallback(bool abilityRegistered, unsigned int abilityHandle, ATMO_Callback_t cb, void *data, uint32_t dataLen)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn;\n\t}\n\n\tATMO_Value_t value;\n\tATMO_InitValue(&value);\n\tif(data != NULL)\n\t{\n\t\tATMO_CreateValueBinary(&value, data, dataLen);\n\t}\n\n\tif(abilityRegistered)\n\t{\n\t\tATMO_AddAbilityExecute(abilityHandle, &value);\n\t}\n\n\tif(cb != NULL)\n\t{\n\t\tATMO_AddCallbackExecute(cb, &value);\n\t}\n\n\tATMO_FreeValue(&value);\n}\n\nstatic void ATMO_FXOS8700_INT_Callback(void *data)\n{\n\t// Read int src\n\tuint8_t src;\n\tif( FXOS8700_ReadReg(&handle, FXOS8700_INT_SOURCE_REG, &src, 1) == FXOS8700_Status_Success )\n\t{\n\t\tuint8_t tmp;\n\t\tif(src & FXOS8700_SRC_DRDY_MASK)\n\t\t{\n\t\t\t// Clear it by reading accelerometer data\n\t\t\tfxos8700_data_t sensorData;\n\t\t\tFXOS8700_ReadSensorData(&handle, &sensorData);\n\t\t\t//ATMO_FXOS8700_INT_DoAbilityOrCallback(_src, &sensorData, sizeof(sensorData));\n\t\t}\n\n\t\tif(src & FXOS8700_SRC_FF_MT_MASK)\n\t\t{\n\t\t\t// Clear it by reading ffmt register\n\t\t\tFXOS8700_ReadReg(&handle, FXOS8700_FF_MT_SRC_REG, &tmp, 1);\n\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.freefallDetectedAbilityHandleRegistered,\n\t\t\t\t\t_ATMO_FXOS8700_config.freefallDetectedAbilityHandle, _ATMO_FXOS8700_config.freefallDetectedCallback, NULL, 0);\n\t\t}\n\n\t\tif(src & FXOS8700_SRC_TRANS_MASK)\n\t\t{\n\t\t\t// Clear it by reading trans register\n\t\t\tFXOS8700_ReadReg(&handle, FXOS8700_TRANSIENT_SRC_REG, &tmp, 1);\n\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.motionDetectedAbilityHandleRegistered,\n\t\t\t_ATMO_FXOS8700_config.motionDetectedAbilityHandle, _ATMO_FXOS8700_config.motionDetectedCallback, NULL, 0);\t\n\t\t}\n\n\t\tif(src & FXOS8700_SRC_PULSE_MASK)\n\t\t{\n\t\t\t// Clear it by reading PULSE_SRC reg\n\t\t\tbool tapDetected, doubleTap = false;\n\t\t\tATMO_FXOS8700_IsTapDetected(&tapDetected, &doubleTap);\n\n\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.tapDetectedAbilityHandleRegistered,\n\t\t\t\t\t_ATMO_FXOS8700_config.tapDetectedAbilityHandle, _ATMO_FXOS8700_config.tapDetectedCallback, NULL, 0);\n\n\t\t\tif(doubleTap)\n\t\t\t{\n\t\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandleRegistered,\n\t\t\t\t\t\t_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandle, _ATMO_FXOS8700_config.doubleTapDetectedCallback, NULL, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic ATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableInterrupts()\n{\n\t// Cannot enable both motion and freefall detection\n\tif(_ATMO_FXOS8700_config.config.freefallEnabled && _ATMO_FXOS8700_config.config.motionEnabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfxos8700_status_t status = FXOS8700_Status_Success;\n\n\tif(_ATMO_FXOS8700_config.config.freefallEnabled)\n\t{\n\t\tstatus = FXOS8700_FreefallDetect_Init(&handle);\n\t}\n\telse\n\t{\n\t\tstatus = FXOS8700_MotionDetectFreefall_DeInit(&handle);\n\t}\n\n\tif(_ATMO_FXOS8700_config.config.motionEnabled && status == FXOS8700_Status_Success)\n\t{\n\t\tstatus = FXOS8700_TransientDetect_Init(&handle);\n\t}\n\telse\n\t{\n\t\tstatus = FXOS8700_TransientDetect_DeInit(&handle);\n\t}\n\n\tif(_ATMO_FXOS8700_config.config.tapDetectionEnabled && status == FXOS8700_Status_Success)\n\t{\n\t\tstatus = FXOS8700_TapDetect_Init(&handle);\n\t}\n\telse\n\t{\n\t\tstatus = FXOS8700_TapDetect_DeInit(&handle);\n\t}\n\n\treturn status == FXOS8700_Status_Success ? ATMO_FXOS8700_Status_Success : ATMO_FXOS8700_Status_Fail;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_Init(ATMO_FXOS8700_Config_t *config)\n{\n\thandle.I2C_Read = ATMO_FXOS8700_I2CRead_Simple;\n\thandle.I2C_Write = ATMO_FXOS8700_I2CWrite_Simple;\n\thandle.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_FXOS8700_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_FXOS8700_config.configured = false;\n    }\n\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetEnabled(bool enabled)\n{\n\tfxos8700Enabled = enabled;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetEnabled(bool *enabled)\n{\n\t*enabled = fxos8700Enabled;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetConfiguration(const ATMO_FXOS8700_Config_t *config)\n{\n    if( config == NULL || !fxos8700Enabled)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_FXOS8700_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n    memcpy( &_ATMO_FXOS8700_config.config, config, sizeof(ATMO_FXOS8700_Config_t) );\n    _ATMO_FXOS8700_config.configured = true;\n\n\tfxos8700_status_t status = FXOS8700_Init(&handle);\n\n\tif(status != FXOS8700_Status_Success)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n    // Register interrupt\n    if(config->int1En)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->int1Pin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_FXOS8700_INT_Callback);\n    }\n    if(config->int2En)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->int2Pin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_FXOS8700_INT_Callback);\n    }\n\n\n    return ATMO_FXOS8700_EnableInterrupts();\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetConfiguration(ATMO_FXOS8700_Config_t *config)\n{\n    if( config == NULL || !_ATMO_FXOS8700_config.configured )\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_FXOS8700_config.config, sizeof(ATMO_FXOS8700_Config_t));\n\n    return ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetAccelData(ATMO_3dFloatVector_t *data)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfxos8700_data_t rawData;\n\tif(FXOS8700_ReadSensorData(&handle, &rawData) != FXOS8700_Status_Success)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfloat dataScale = 0;\n\tuint8_t sensorRange = 0;\n\n\t    /* Get sensor range */\n    if (FXOS8700_ReadReg(&handle, FXOS8700_XYZ_DATA_CFG_REG, &sensorRange, 1) != FXOS8700_Status_Success)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n    if(sensorRange == 0x00)\n    {\n    \t/* 0.244 mg/LSB */\n        dataScale = 0.000244;\n    }\n    else if(sensorRange == 0x01)\n    {\n    \t/* 0.488 mg/LSB */\n        dataScale = 0.000488;\n    }\n    else if(sensorRange == 0x10)\n    {\n    \t/* 0.976 mg/LSB */\n        dataScale = 0.000976;\n    }\n\n\tdata->x =  ((float)((int16_t)(((rawData.accelXMSB*256) + (rawData.accelXLSB)))>> 2));\n\tdata->y =  ((float)((int16_t)(((rawData.accelYMSB*256) + (rawData.accelYLSB)))>> 2));\n\tdata->z =  ((float)((int16_t)(((rawData.accelZMSB*256) + (rawData.accelZLSB)))>> 2));\n\tdata->x *= dataScale;\n\tdata->y *= dataScale;\n\tdata->z *= dataScale;\n\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetMagData(ATMO_3dFloatVector_t *data)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfxos8700_data_t rawData;\n\tif(FXOS8700_ReadSensorData(&handle, &rawData) != FXOS8700_Status_Success)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfloat dataScale = 0;\n\tuint8_t sensorRange = 0;\n\n\t    /* Get sensor range */\n    if (FXOS8700_ReadReg(&handle, FXOS8700_XYZ_DATA_CFG_REG, &sensorRange, 1) != FXOS8700_Status_Success)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n\tdata->x =  (float)((int16_t)((rawData.magXMSB*256) + (rawData.magXLSB))) * 0.1;\n\tdata->y =  (float)((int16_t)((rawData.magYMSB*256) + (rawData.magYLSB))) * 0.1;\n\tdata->z =  (float)((int16_t)((rawData.magZMSB*256) + (rawData.magZLSB))) * 0.1;\n\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\t_ATMO_FXOS8700_config.freefallDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.freefallDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n\n}\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.freefallDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\t_ATMO_FXOS8700_config.motionDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.motionDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n\n}\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.motionDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\n/**\n * Tap detection\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_IsTapDetected(bool *isTapDetected, bool *isDoubleTap)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n    uint8_t tmp[1];\n    *isDoubleTap = false;\n\n    if(FXOS8700_ReadReg(&handle, FXOS8700_PULSE_SRC_REG, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n\n    if ((tmp[0] & FXOS8700_PEA_MASK) == FXOS8700_PEA_MASK)\n    {\n        /* Check to see if it was a double tap */\n        if ((tmp[0] & FXOS8700_DPE_MASK) == FXOS8700_DPE_MASK)\n        {\n            *isDoubleTap = true;\n        }\n\n        *isTapDetected = true;\n    }\n    else\n    {\n    \t*isTapDetected = false;\n    }\n\n    return ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.tapDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.tapDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.tapDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.doubleTapDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableFreefallDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = true;\n\t_ATMO_FXOS8700_config.config.motionEnabled = false;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = false;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableMotionDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = false;\n\t_ATMO_FXOS8700_config.config.motionEnabled = true;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = false;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableTapDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = false;\n\t_ATMO_FXOS8700_config.config.motionEnabled = false;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = true;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_DisableAllDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = false;\n\t_ATMO_FXOS8700_config.config.motionEnabled = false;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = false;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\n\n",
                "fxos8700_internal.c": "/*\n * The Clear BSD License\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\n * Copyright 2016-2017 NXP\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided\n * that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fxos8700_internal.h\"\n\n#define EN_FFMT_INTERRUPT 1\n\n/******************************************************************************\n * Code\n ******************************************************************************/\n\nfxos8700_status_t FXOS8700_SetStandby(fxos8700_handle_t *fxos8700_handle)\n{\n\tuint8_t tmp[1];\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp[0] & (uint8_t)~FXOS8700_ACTIVE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Read again to make sure we are in standby mode. */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if ((tmp[0] & FXOS8700_ACTIVE_MASK) == FXOS8700_ACTIVE_MASK)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\nfxos8700_status_t FXOS8700_SetActive(fxos8700_handle_t *fxos8700_handle)\n{\n\tuint8_t tmp[1];\n\n    /* Set Active Mode*/ \n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp[0] | (uint8_t)FXOS8700_ACTIVE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n     /* Read Control register again to ensure we are in active mode */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if ((tmp[0] & FXOS8700_ACTIVE_MASK) != FXOS8700_ACTIVE_MASK)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n\n}\n\nfxos8700_status_t FXOS8700_Init(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1] = {0};\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_WHO_AM_I_REG, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if (tmp[0] != FXOS8700_kFXOS_WHO_AM_I_Device_ID)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* go to standby */\n    FXOS8700_SetStandby(fxos8700_handle);\n\n    /* Disable the FIFO */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_F_SETUP_REG, FXOS8700_F_MODE_DISABLED) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef LPSLEEP_HIRES\n    /* enable auto-sleep, low power in sleep, high res in wake */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG2, FXOS8700_SLPE_MASK | FXOS8700_SMOD_LOW_POWER | FXOS8700_MOD_HIGH_RES) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#else\n\n    /* Accel OSR mode: High Resolution*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG2, FXOS8700_MOD_HIGH_RES) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#endif\n\n    /* set MSR OSR=7 ,set FXOS8700 to hybrid mode (both accel and mag on), One-shot magnetic reset is enabled*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_M_CTRL_REG1, (FXOS8700_M_RST_MASK | FXOS8700_M_OSR_MASK | FXOS8700_M_HMS_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Enable hyrid mode auto increment using M_CTRL_REG2 */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_M_CTRL_REG2, (FXOS8700_M_HYB_AUTOINC_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_AUTO_SLEEP\n    /* set auto-sleep wait period to 5s (=5/0.64=~8) */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_ASLP_COUNT_REG, 8) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#endif\n\n#ifdef EN_FXOS_DATAREADY_INTERRUPT\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n\n     if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_DRDY_MASK) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n\n     /* Set Data Ready Interrupt to route to INT1 */\n     if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n     if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_DRDY_MASK) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n\n#endif\n\n    /* default set to 4g mode */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_XYZ_DATA_CFG_REG, FXOS8700_FULL_SCALE_4G) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n\n    /* Setup the ODR for 200 Hz (Hybrid) and activate the accelerometer */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG1, (FXOS8700_HYB_DATA_RATE_200HZ | FXOS8700_ACTIVE_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Read Control register again to ensure we are in active mode */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if ((tmp[0] & FXOS8700_ACTIVE_MASK) != FXOS8700_ACTIVE_MASK)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\nfxos8700_status_t FXOS8700_ReadSensorData(fxos8700_handle_t *fxos8700_handle, fxos8700_data_t *sensorData)\n{\n    fxos8700_status_t status = FXOS8700_Status_Success;\n    uint8_t tmp_buff[6] = {0};\n    uint8_t i = 0;\n\n    if (!FXOS8700_ReadReg(fxos8700_handle, FXOS8700_OUT_X_MSB_REG, tmp_buff, 6) == FXOS8700_Status_Success)\n    {\n        status = FXOS8700_Status_Fail;\n    }\n\n    for (i = 0; i < 6; i++)\n    {\n        ((int8_t *)sensorData)[i] = tmp_buff[i];\n    }\n\n    if (!FXOS8700_ReadReg(fxos8700_handle, FXOS8700_M_OUT_X_MSB_REG, tmp_buff, 6) == FXOS8700_Status_Success)\n    {\n        status = FXOS8700_Status_Fail;\n    }\n\n    for (i = 0; i < 6; i++)\n    {\n        ((int8_t *)sensorData)[i + 6] = tmp_buff[i];\n    }\n\n    return status;\n}\n\nfxos8700_status_t FXOS8700_ReadReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t *val, uint8_t bytesNumber)\n{\n    /* Configure I2C xfer */\n    return handle->I2C_Read(&reg, 1, val, bytesNumber) == 0 ? FXOS8700_Status_Success : FXOS8700_Status_Fail;\n}\n\nfxos8700_status_t FXOS8700_WriteReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t val)\n{\n    uint8_t buff[2];\n    buff[0] = reg;\n    buff[1] = val;\n    return handle->I2C_Write(buff, 2) == 0 ? FXOS8700_Status_Success : FXOS8700_Status_Fail;\n}\n\nfxos8700_status_t FXOS8700_MotionDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n\n    uint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable FFMT for motion detect for X and Y axes, latch enable.\n    If Z axis were included in this motion detect setup and the threshold is less than 1G, it will cause motion detect to be triggered.\n    (assuming Z-axis is experiencing gravity)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_CFG_REG, (FXOS8700_XEFE_MASK | FXOS8700_YEFE_MASK | FXOS8700_OAE_MASK|FXOS8700_ELE_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set threshold to about 0.5g (0.5g/0.063 g/count = 8)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FT_MT_THS_REG, 0x08) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set debounce to zero */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_COUNT_REG, 0x00) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_FFMT_INTERRUPT\n    /*Enable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that FFMT Interrupt will go to INT2 pin. */\n    /* To route FFMT interrupt to INT1 pin define below */\n    #ifdef EN_FFMT_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    \n    return FXOS8700_Status_Success;\n\n}\n\nfxos8700_status_t FXOS8700_MotionDetectFreefall_DeInit(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1];\n    \n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Reset Freefall/Motion Config Register to 0. Disables FF and Motion Detection*/ \n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_CFG_REG, 0x0 != FXOS8700_Status_Success))\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n\n#ifdef EN_FFMT_INTERRUPT\n    /*Disable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] & (uint8_t)~FXOS8700_INT_EN_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    #ifdef EN_FFMT_INT1_PIN\n    /* Reset to default behavior */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|(uint8_t)~FXOS8700_INT_CFG_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif \n\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\n\n\nfxos8700_status_t FXOS8700_FreefallDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1] = {0};\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Freefall detect is triggered when combined X,Y,Z magnitude is less than the threshold. Latch also enabled. */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_CFG_REG, FXOS8700_ZEFE_MASK|FXOS8700_YEFE_MASK|FXOS8700_XEFE_MASK|FXOS8700_ELE_MASK)  != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set threshold to about 0.25g (0.25g/0.063 g/count = 4)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FT_MT_THS_REG, 0x04) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set debounce to zero */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_COUNT_REG, 0x00) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_FFMT_INTERRUPT\n    /*Enable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that FFMT Interrupt will go to INT2 pin. */\n    /* To route FFMT interrupt to INT1 pin define below */\n    #ifdef EN_FFMT_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif\n\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\n\n\nfxos8700_status_t FXOS8700_TapDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n\tuint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable PULSE_CFG for only single tap  */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, FXOS8700_PELE_MASK|FXOS8700_ZSPEFE_MASK|FXOS8700_YSPEFE_MASK|FXOS8700_XSPEFE_MASK ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable PULSE_CFG for only double tap  */\n    #if DOUBLE_TAP && !SINGLE_TAP\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, FXOS8700_PELE_MASK|FXOS8700_ZDPEFE_MASK|FXOS8700_YDPEFE_MASK|FXOS8700_XDPEFE_MASK ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif \n\n\t#if DOUBLE_TAP && SINGLE_TAP\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, FXOS8700_PELE_MASK|FXOS8700_ZDPEFE_MASK|FXOS8700_ZSPEFE_MASK|FXOS8700_YDPEFE_MASK|FXOS8700_YSPEFE_MASK|FXOS8700_XDPEFE_MASK|FXOS8700_XSPEFE_MASK ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\t#endif\n\n    /* set PULSE_THSX to about 2g */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_THSX_REG, 0x20) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set PULSE_THSY to about 2g */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_THSY_REG, 0x20) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set PULSE_THSZ to about 3g */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_THSZ_REG, 0x0C) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set the Pulse Time Window (PULSE_TMLT) to 6 counts */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_TMLT_REG, 0x06) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set the Pulse Latency Timer to 40 counts */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_LTCY_REG, 0x28) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set the Second Pulse Time Window to 15 counts */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_WIND_REG, 0x0F) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_TAP_INTERRUPT\n\n    /*Enable Tap/Pulse Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that Pulse Interrupt will go to INT2 pin. */\n    /* To route Pulse interrupt to INT1 pin define below */\n    #ifdef EN_PULSE_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    #endif\n#endif\n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n   \n    return FXOS8700_Status_Success;\n}\n\n\n\nfxos8700_status_t FXOS8700_TapDetect_DeInit(fxos8700_handle_t *fxos8700_handle)\n{\n\n\tuint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable PULSE_CFG for only single tap  */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, 0x0 ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n\n#ifdef EN_TAP_INTERRUPT\n\n    /*Disable Pulse Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] & (uint8_t)~FXOS8700_INT_EN_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that Pulse Interrupt will go to INT2 pin. */\n    /* To route Pulse interrupt to INT1 pin define below */\n    #ifdef EN_PULSE_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|(uint8_t)~FXOS8700_INT_CFG_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    \n    #endif\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n   \n    return FXOS8700_Status_Success;\n}\n\n\nfxos8700_status_t FXOS8700_TransientDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1] = {0};\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable TRANSIENT CFG REG for Transient detect for X,Y,Z axis.latch enabled */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_CFG_REG, FXOS8700_TELE_MASK |FXOS8700_ZTEFE_MASK|FXOS8700_YTEFE_MASK|FXOS8700_XTEFE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set threshold to about 0.25g (0.25g/0.063 g/count = 4)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_THS_REG, 0x04) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set debounce to zero */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_COUNT_REG, 0x00) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set High-Pass Filter to 2Hz (Sampling Rate = 200Hz, Oversample Mode = High Res) Check APP note AN4071 */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_HP_FILTER_CUTOFF_REG, 0x03) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /*Enable Transient Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that FFMT Interrupt will go to INT2 pin. */\n    /* To route TRANS interrupt to INT1 pin define below */\n#ifdef EN_TRANS_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#endif\n\n    /* Set Active Mode*/\n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\nfxos8700_status_t FXOS8700_TransientDetect_DeInit(fxos8700_handle_t *fxos8700_handle)\n{\n\n    uint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Reset Transient Config Register to 0. Disables Transient Detection*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_CFG_REG, 0x0 != FXOS8700_Status_Success))\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /*Disable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] & (uint8_t)~FXOS8700_INT_EN_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_TRANS_INT1_PIN\n    /* Reset to default behavior */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|(uint8_t)~FXOS8700_INT_CFG_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#endif\n\n    /* Set Active Mode*/\n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n"
              }
            }
          },
          "md5": "36cf0fe3a90e560a67be2c20c6a2e17b"
        },
        "fxas21002": {
          "libName": "fxas21002",
          "manufacturer": "NXP Semiconductors",
          "description": "Gyroscope",
          "type": "Gyroscope",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/adafruit-industries-llc/3463/1528-2130-ND/7064490"
              },
              "cartData": {
                "part": " 1528-2130-ND",
                "partid": "3463",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c"
          ],
          "elements": [
            {
              "name": "FXAS21002Gyroscope",
              "type": "EmbeddedFXAS21002",
              "icon": "EmbeddedGyroscope.svg",
              "defaultAbility": "getSensorData",
              "defaultTrigger": "sensorDataRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/nxpfxas21002element.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "hidden": true,
                  "code": "\tATMO_FXAS21002_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.samplingRate = ATMO_PROPERTY(undefined, samplingRate);\n\tATMO_FXAS21002_Init(&config);\n\treturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_FXAS21002_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_FXAS21002_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_FXAS21002_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "getSensorData",
                  "triggers": [
                    "sensorDataRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\tATMO_3dFloatVector_t atmoVec;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tatmoVec.x = data.X;\n\tatmoVec.y = data.Y;\n\tatmoVec.z = data.Z;\n\n\tATMO_CreateValue3dVectorFloat(out, &atmoVec);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getDpsX",
                  "triggers": [
                    "dpsXRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.X);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getDpsY",
                  "triggers": [
                    "dpsYRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.Y);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getDpsZ",
                  "triggers": [
                    "dpsZRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.Z);\n\treturn ATMO_Status_Success;\n"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x20"
                },
                {
                  "name": "samplingRate",
                  "input": "select",
                  "inputOptions": [
                    "FXAS21002_CTRL_REG1_DR_12_5HZ",
                    "FXAS21002_CTRL_REG1_DR_25HZ",
                    "FXAS21002_CTRL_REG1_DR_50HZ",
                    "FXAS21002_CTRL_REG1_DR_100HZ",
                    "FXAS21002_CTRL_REG1_DR_200HZ",
                    "FXAS21002_CTRL_REG1_DR_400HZ",
                    "FXAS21002_CTRL_REG1_DR_800HZ"
                  ],
                  "value": "FXAS21002_CTRL_REG1_DR_12_5HZ"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedFXAS21002": "FXAS21002 Gyroscope",
                  "FXAS21002_CTRL_REG1_DR_12_5HZ": "12.5 Hz",
                  "FXAS21002_CTRL_REG1_DR_25HZ": "25 Hz",
                  "FXAS21002_CTRL_REG1_DR_50HZ": "50 Hz",
                  "FXAS21002_CTRL_REG1_DR_100HZ": "100 Hz",
                  "FXAS21002_CTRL_REG1_DR_200HZ": "200 Hz",
                  "FXAS21002_CTRL_REG1_DR_400HZ": "400 Hz",
                  "FXAS21002_CTRL_REG1_DR_800HZ": "800 Hz",
                  "samplingRate": "Sample Rate",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "getSensorData": "Get Sensor Data",
                  "sensorDataRead": "Sensor Data Read",
                  "getDpsX": "Get X Rotation Speed (DPS)",
                  "getDpsY": "Get Y Rotation Speed (DPS)",
                  "getDpsZ": "Get Z Rotation Speed (DPS)",
                  "dpsXRead": "Read X Rotation Speed (DPS)",
                  "dpsYRead": "Read Y Rotation Speed (DPS)",
                  "dpsZRead": "Read Z Rotation Speed (DPS)"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "fxas21002.h": "#ifndef _ATMO_FXAS21002_H_\n#define _ATMO_FXAS21002_H_\n\n#include \"../i2c/i2c.h\"\n#include \"fxas21002_internal.h\"\n\ntypedef enum {\n    ATMO_FXAS21002_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_FXAS21002_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_FXAS21002_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_FXAS21002_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_FXAS21002_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_FXAS21002_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    uint8_t samplingRate;\n} ATMO_FXAS21002_Config_t;\n\n// X Y Z values in DPS\ntypedef struct {\n\tfloat X;\n\tfloat Y;\n\tfloat Z;\n} ATMO_FXAS21002_SensorData_t;\n\n/**\n * Initialize FXAS21002 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_Init(ATMO_FXAS21002_Config_t *config);\n\n/**\n * Enable/Disable FXAS21002 Driver\n *\n * @param[in] enabled\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of FXAS21002 driver\n *\n * @param[out] enabled\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetConfiguration(const ATMO_FXAS21002_Config_t *config);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetConfiguration(ATMO_FXAS21002_Config_t *config);\n\n/**\n * Get XYZ data from sensor\n *\n * @param[out] data\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetSensorData(ATMO_FXAS21002_SensorData_t *data);\n\n#endif\n",
                "fxas21002_internal.h": "/*\n * The Clear BSD License\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\n * Copyright 2016-2017 NXP\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided\n * that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file fxas21002.h\n * @brief The fxas21002.h contains the fxas21002 sensor register definitions and its bit mask.\n*/\n\n#ifndef FXAS21002_H_\n#define FXAS21002_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/**\n **  FXAS21002 I2C Address\n */\n#define   FXAS21002_I2C_ADDRESS     0x20\n\n/**\n **\n ** @brief The FXAS21002 Sensor Register  Map.\n */\nenum {\n     FXAS21002_STATUS             = 0x00,\n     FXAS21002_OUT_X_MSB          = 0x01,\n     FXAS21002_OUT_X_LSB          = 0x02,\n     FXAS21002_OUT_Y_MSB          = 0x03,\n     FXAS21002_OUT_Y_LSB          = 0x04,\n     FXAS21002_OUT_Z_MSB          = 0x05,\n     FXAS21002_OUT_Z_LSB          = 0x06,\n     FXAS21002_DR_STATUS          = 0x07,\n     FXAS21002_F_STATUS           = 0x08,\n     FXAS21002_F_SETUP            = 0x09,\n     FXAS21002_F_EVENT            = 0x0A,\n     FXAS21002_INT_SRC_FLAG       = 0x0B,\n     FXAS21002_WHO_AM_I           = 0x0C,\n     FXAS21002_CTRL_REG0          = 0x0D,\n     FXAS21002_RT_CFG             = 0x0E,\n     FXAS21002_RT_SRC             = 0x0F,\n     FXAS21002_RT_THS             = 0x10,\n     FXAS21002_RT_COUNT           = 0x11,\n     FXAS21002_TEMP               = 0x12,\n     FXAS21002_CTRL_REG1          = 0x13,\n     FXAS21002_CTRL_REG2          = 0x14,\n     FXAS21002_CTRL_REG3          = 0x15,\n};\n\n\n/*--------------------------------\n** Register: STATUS\n** Enum: FXAS21002_STATUS\n** --\n** Offset : 0x00 - Alias for DR_STATUS or F_STATUS.\n** ------------------------------*/\ntypedef uint8_t FXAS21002_STATUS_t;\n\n\n\n/*--------------------------------\n** Register: OUT_X_MSB\n** Enum: FXAS21002_OUT_X_MSB\n** --\n** Offset : 0x01 - 8 MSBs of 16 bit X-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_X_MSB_t;\n\n\n/*--------------------------------\n** Register: OUT_X_LSB\n** Enum: FXAS21002_OUT_X_LSB\n** --\n** Offset : 0x02 - 8 LSBs of 16 bit X-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_X_LSB_t;\n\n\n\n/*--------------------------------\n** Register: OUT_Y_MSB\n** Enum: FXAS21002_OUT_Y_MSB\n** --\n** Offset : 0x03 - 8 MSBs of 16 bit Y-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Y_MSB_t;\n\n\n/*--------------------------------\n** Register: OUT_Y_LSB\n** Enum: FXAS21002_OUT_Y_LSB\n** --\n** Offset : 0x04 - 8 LSBs of 16 bit Y-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Y_LSB_t;\n\n\n\n/*--------------------------------\n** Register: OUT_Z_MSB\n** Enum: FXAS21002_OUT_Z_MSB\n** --\n** Offset : 0x05 - 8 MSBs of 16 bit Z-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Z_MSB_t;\n\n\n/*--------------------------------\n** Register: OUT_Z_LSB\n** Enum: FXAS21002_OUT_Z_LSB\n** --\n** Offset : 0x06 - 8 LSBs of 16 bit Z-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Z_LSB_t;\n\n\n\n/*--------------------------------\n** Register: DR_STATUS\n** Enum: FXAS21002_DR_STATUS\n** --\n** Offset : 0x07 - Data-ready status information (FIFO disabled by setting F_SETUP :: F_MODE = 0)\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                   xdr : 1; /*  X-axis new data available.                                                 */\n\n        uint8_t                   ydr : 1; /*  Y-axis new data available.                                                 */\n\n        uint8_t                   zdr : 1; /*  Z-axis new data available.                                                 */\n\n        uint8_t                 zyxdr : 1; /*  X-, Y-, and Z-axis data available.                                         */\n\n        uint8_t                   xow : 1; /*  X-axis data overwrite.                                                     */\n\n        uint8_t                   yow : 1; /*  Y-axis data overwrite.                                                     */\n\n        uint8_t                   zow : 1; /*  Z-axis data overwrite.                                                     */\n\n        uint8_t                 zyxow : 1; /*  X-, Y-, Z-axis data overwrite.                                             */\n\n    } b;\n    uint8_t w;\n} FXAS21002_DR_STATUS_t;\n\n\n/*\n** DR_STATUS - Bit field mask definitions\n*/\n#define FXAS21002_DR_STATUS_XDR_MASK     ((uint8_t) 0x01)\n#define FXAS21002_DR_STATUS_XDR_SHIFT    ((uint8_t)    0)\n\n#define FXAS21002_DR_STATUS_YDR_MASK     ((uint8_t) 0x02)\n#define FXAS21002_DR_STATUS_YDR_SHIFT    ((uint8_t)    1)\n\n#define FXAS21002_DR_STATUS_ZDR_MASK     ((uint8_t) 0x04)\n#define FXAS21002_DR_STATUS_ZDR_SHIFT    ((uint8_t)    2)\n\n#define FXAS21002_DR_STATUS_ZYXDR_MASK   ((uint8_t) 0x08)\n#define FXAS21002_DR_STATUS_ZYXDR_SHIFT  ((uint8_t)    3)\n\n#define FXAS21002_DR_STATUS_XOW_MASK     ((uint8_t) 0x10)\n#define FXAS21002_DR_STATUS_XOW_SHIFT    ((uint8_t)    4)\n\n#define FXAS21002_DR_STATUS_YOW_MASK     ((uint8_t) 0x20)\n#define FXAS21002_DR_STATUS_YOW_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_DR_STATUS_ZOW_MASK     ((uint8_t) 0x40)\n#define FXAS21002_DR_STATUS_ZOW_SHIFT    ((uint8_t)    6)\n\n#define FXAS21002_DR_STATUS_ZYXOW_MASK   ((uint8_t) 0x80)\n#define FXAS21002_DR_STATUS_ZYXOW_SHIFT  ((uint8_t)    7)\n\n\n/*\n** DR_STATUS - Bit field value definitions\n*/\n#define FXAS21002_DR_STATUS_XDR_DRDY              ((uint8_t) 0x01)  /*  Set to 1 whenever a new X-axis data acquisition   */\n                                                                    /*  is completed. Cleared anytime the OUT_X_MSB       */\n                                                                    /*  register is read.                                 */\n#define FXAS21002_DR_STATUS_YDR_DRDY              ((uint8_t) 0x02)  /*  Set to 1 whenever a new Y-axis data acquisition   */\n                                                                    /*  is completed. Cleared anytime the OUT_Y_MSB       */\n                                                                    /*  register is read.                                 */\n#define FXAS21002_DR_STATUS_ZDR_DRDY              ((uint8_t) 0x04)  /*  Set to 1 whenever a new Z-axis data acquisition   */\n                                                                    /*  is completed. Cleared anytime the OUT_Z_MSB       */\n                                                                    /*  register is read.                                 */\n#define FXAS21002_DR_STATUS_ZYXDR_DRDY            ((uint8_t) 0x08)  /*  Cleared when the high-bytes of the acceleration   */\n                                                                    /*  data (OUT_X_MSB, OUT_Y_MSB, OUT_Z_MSB) are read.  */\n#define FXAS21002_DR_STATUS_XOW_OWR               ((uint8_t) 0x10)  /*  Asserted whenever a new X-axis acquisition is     */\n                                                                    /*  completed before the retrieval of the previous    */\n                                                                    /*  data.                                             */\n#define FXAS21002_DR_STATUS_YOW_OWR               ((uint8_t) 0x20)  /*  Asserted whenever a new Y-axis acquisition is     */\n                                                                    /*  completed before the retrieval of the previous    */\n                                                                    /*  data.                                             */\n#define FXAS21002_DR_STATUS_ZOW_OWR               ((uint8_t) 0x40)  /*  Asserted whenever a new Z-axis acquisition is     */\n                                                                    /*  completed before the retrieval of the previous    */\n                                                                    /*  data.                                             */\n#define FXAS21002_DR_STATUS_ZYXOW_OWR             ((uint8_t) 0x80)  /*  Asserted whenever new X-, Y-, and Z-axis data is  */\n                                                                    /*  acquired before completing the retrieval of the   */\n                                                                    /*  previous set.                                     */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: F_STATUS\n** Enum: FXAS21002_F_STATUS\n** --\n** Offset : 0x08 - FIFO status information (FIFO enabled by setting F_SETUP :: F_MODE > 0)\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                 f_cnt : 6; /*  FIFO sample counter; indicates the number of samples currently stored in   */\n                                           /*  the FIFO.                                                                  */\n\n        uint8_t                f_wmkf : 1; /*  FIFO sample count greater than or equal to the watermark count (F_SETUP :: */\n                                           /*  F_WMRK) has been detected.                                                 */\n\n        uint8_t                 f_ovf : 1; /*  FIFO overflow event, such as when F_CNT = 32 and a new sample arrives,     */\n                                           /*  asserts the F_OVF flag.                                                    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_F_STATUS_t;\n\n\n/*\n** F_STATUS - Bit field mask definitions\n*/\n#define FXAS21002_F_STATUS_F_CNT_MASK    ((uint8_t) 0x3F)\n#define FXAS21002_F_STATUS_F_CNT_SHIFT   ((uint8_t)    0)\n\n#define FXAS21002_F_STATUS_F_WMKF_MASK   ((uint8_t) 0x40)\n#define FXAS21002_F_STATUS_F_WMKF_SHIFT  ((uint8_t)    6)\n\n#define FXAS21002_F_STATUS_F_OVF_MASK    ((uint8_t) 0x80)\n#define FXAS21002_F_STATUS_F_OVF_SHIFT   ((uint8_t)    7)\n\n\n/*\n** F_STATUS - Bit field value definitions\n*/\n#define FXAS21002_F_STATUS_F_WMKF_DETECT         ((uint8_t) 0x40)  /*  FIFO Watermark event has been detected.            */\n#define FXAS21002_F_STATUS_F_OVF_DETECT          ((uint8_t) 0x80)  /*  FIFO Overflow event has been detected.             */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: F_SETUP\n** Enum: FXAS21002_F_SETUP\n** --\n** Offset : 0x09 - FIFO configuration\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                f_wmrk : 6; /*  FIFO operating mode selection.                                             */\n\n        uint8_t                f_mode : 2; /*  FIFO sample count watermark setting.                                       */\n\n    } b;\n    uint8_t w;\n} FXAS21002_F_SETUP_t;\n\n\n/*\n** F_SETUP - Bit field mask definitions\n*/\n#define FXAS21002_F_SETUP_F_WMRK_MASK   ((uint8_t) 0x3F)\n#define FXAS21002_F_SETUP_F_WMRK_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_F_SETUP_F_MODE_MASK   ((uint8_t) 0xC0)\n#define FXAS21002_F_SETUP_F_MODE_SHIFT  ((uint8_t)    6)\n\n\n/*\n** F_SETUP - Bit field value definitions\n*/\n#define FXAS21002_F_SETUP_F_MODE_FIFO_OFF       ((uint8_t) 0x00)  /*  FIFO is disabled.                                   */\n#define FXAS21002_F_SETUP_F_MODE_CIR_MODE       ((uint8_t) 0x40)  /*  FIFO is in Circular Buffer mode.                    */\n#define FXAS21002_F_SETUP_F_MODE_STOP_MODE      ((uint8_t) 0x80)  /*  FIFO is in Stop mode.                               */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: F_EVENT\n** Enum: FXAS21002_F_EVENT\n** --\n** Offset : 0x0A - FIFO event status\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t               fe_time : 5; /*  Number of ODR periods elapsed since F_EVENT was set.                       */\n\n        uint8_t               f_event : 1; /*  FIFO Event: Indicates if either F_WMKF or F_OVF flags are set (logical     */\n                                           /*  OR).                                                                       */\n\n    } b;\n    uint8_t w;\n} FXAS21002_F_EVENT_t;\n\n\n/*\n** F_EVENT - Bit field mask definitions\n*/\n#define FXAS21002_F_EVENT_FE_TIME_MASK   ((uint8_t) 0x1F)\n#define FXAS21002_F_EVENT_FE_TIME_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_F_EVENT_F_EVENT_MASK   ((uint8_t) 0x20)\n#define FXAS21002_F_EVENT_F_EVENT_SHIFT  ((uint8_t)    5)\n\n\n/*\n** F_EVENT - Bit field value definitions\n*/\n#define FXAS21002_F_EVENT_F_EVENT_DETECTED      ((uint8_t) 0x20)  /*  FIFO event was detected                             */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: INT_SRC_FLAG\n** Enum: FXAS21002_INT_SRC_FLAG\n** --\n** Offset : 0x0B - Interrupt source status\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t              src_drdy : 1; /*  Data ready event source flag.                                              */\n\n        uint8_t                src_rt : 1; /*  Rate threshold event source flag.                                          */\n\n        uint8_t              src_fifo : 1; /*  FIFO event source flag.                                                    */\n\n        uint8_t               bootend : 1; /*  Boot sequence complete event flag.                                         */\n\n    } b;\n    uint8_t w;\n} FXAS21002_INT_SRC_FLAG_t;\n\n\n/*\n** INT_SRC_FLAG - Bit field mask definitions\n*/\n#define FXAS21002_INT_SRC_FLAG_SRC_DRDY_MASK   ((uint8_t) 0x01)\n#define FXAS21002_INT_SRC_FLAG_SRC_DRDY_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_INT_SRC_FLAG_SRC_RT_MASK     ((uint8_t) 0x02)\n#define FXAS21002_INT_SRC_FLAG_SRC_RT_SHIFT    ((uint8_t)    1)\n\n#define FXAS21002_INT_SRC_FLAG_SRC_FIFO_MASK   ((uint8_t) 0x04)\n#define FXAS21002_INT_SRC_FLAG_SRC_FIFO_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_INT_SRC_FLAG_BOOTEND_MASK    ((uint8_t) 0x08)\n#define FXAS21002_INT_SRC_FLAG_BOOTEND_SHIFT   ((uint8_t)    3)\n\n\n/*\n** INT_SRC_FLAG - Bit field value definitions\n*/\n#define FXAS21002_INT_SRC_FLAG_SRC_DRDY_READY        ((uint8_t) 0x01)  /*  Asserted whenever a data-ready event triggers  */\n                                                                       /*  the interrupt.                                 */\n#define FXAS21002_INT_SRC_FLAG_SRC_RT_THRESH         ((uint8_t) 0x02)  /*  Indicates that the rate threshold event flag   */\n                                                                       /*  triggered the interrupt.                       */\n#define FXAS21002_INT_SRC_FLAG_SRC_FIFO_EVENT        ((uint8_t) 0x04)  /*  F_OVF or F_WMKF are set, provided the FIFO     */\n                                                                       /*  interrupt is enabled.                          */\n#define FXAS21002_INT_SRC_FLAG_BOOTEND_BOOT_DONE     ((uint8_t) 0x08)  /*  Boot sequence is complete.                     */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: WHO_AM_I\n** Enum: FXAS21002_WHO_AM_I\n** --\n** Offset : 0x0C - The WHO_AM_I register contains the device idenifier.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                whoami; /*  The WHO_AM_I register contains the device identifier which is factory          */\n                                       /*  programmed.                                                                    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_WHO_AM_I_t;\n\n\n/*\n** WHO_AM_I - Bit field mask definitions\n*/\n#define FXAS21002_WHO_AM_I_WHOAMI_MASK   ((uint8_t) 0xFF)\n#define FXAS21002_WHO_AM_I_WHOAMI_SHIFT  ((uint8_t)    0)\n\n\n/*\n** WHO_AM_I - Bit field value definitions\n*/\n#define FXAS21002_WHO_AM_I_WHOAMI_OLD_VALUE     ((uint8_t) 0xd1)  /*  FXAS21000                       */\n#define FXAS21002_WHO_AM_I_WHOAMI_PRE_VALUE     ((uint8_t) 0xd6)  /*  Engineering Samples             */\n#define FXAS21002_WHO_AM_I_WHOAMI_PROD_VALUE    ((uint8_t) 0xd7)  /*  FXAS21002 Rev 2.1 (production)  */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: CTRL_REG0\n** --\n** Offset : 0x0D - Used for general control and configuration.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                    fs : 2; /*  Full-scale range selection.                                                */\n\n        uint8_t                hpf_en : 1; /*  High-pass filter enable. The high-pass filter is initialized on operating  */\n                                           /*  mode and ODR change. When enabled, the HPF is applied to the angular rate  */\n                                           /*  data supplied to the output registers/FIFO and the embedded rate threshold */\n                                           /*  algorithm.                                                                 */\n\n        uint8_t                   sel : 2; /*  High-pass filter cutoff frequency selection.                               */\n\n        uint8_t                  spiw : 1; /*  SPI interface mode selection.                                              */\n\n        uint8_t                    bw : 2; /*  Bandwidth selects the cut-off frequency of the digital low-pass filter.    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG0_t;\n\n\n/*\n** CTRL_REG0 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG0_FS_MASK       ((uint8_t) 0x03)\n#define FXAS21002_CTRL_REG0_FS_SHIFT      ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG0_HPF_EN_MASK   ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG0_HPF_EN_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG0_SEL_MASK      ((uint8_t) 0x18)\n#define FXAS21002_CTRL_REG0_SEL_SHIFT     ((uint8_t)    3)\n\n#define FXAS21002_CTRL_REG0_SPIW_MASK     ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG0_SPIW_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_CTRL_REG0_BW_MASK       ((uint8_t) 0xC0)\n#define FXAS21002_CTRL_REG0_BW_SHIFT      ((uint8_t)    6)\n\n\n/*\n** CTRL_REG0 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG0_FS_DPS2000            ((uint8_t) 0x00)  /*  2000 degrees per second (4000 dps if CTRL_REG3 :  */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_FS_DPS1000            ((uint8_t) 0x01)  /*  1000 degrees per second (2000 dps if CTRL_REG3 :  */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_FS_DPS500             ((uint8_t) 0x02)  /*  500 degrees per second (1000 dps if CTRL_REG3 :   */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_FS_DPS250             ((uint8_t) 0x03)  /*  250 degrees per second (500 dps if CTRL_REG3 :    */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_HPF_EN_ENABLE         ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG0_HPF_EN_DISABLE        ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG0_SPIW_4WIRE            ((uint8_t) 0x00)  /*  SPI 4-wire mode (default).                        */\n#define FXAS21002_CTRL_REG0_SPIW_3WIRE            ((uint8_t) 0x20)  /*  SPI 3-wire mode (MOSI pin is used for SPI input   */\n                                                                    /*  and output signals).                              */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_CFG\n** Enum: FXAS21002_RT_CFG\n** --\n** Offset : 0x0E - Used to enable the Rate Threshold interrupt generation.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                 xtefe : 1; /*  Event flag enable on X rate.                                               */\n\n        uint8_t                 ytefe : 1; /*  Event flag enable on Y rate.                                               */\n\n        uint8_t                 ztefe : 1; /*  Event flag enable on Z rate.                                               */\n\n        uint8_t                   ele : 1; /*  Event latch enable.                                                        */\n\n    } b;\n    uint8_t w;\n} FXAS21002_RT_CFG_t;\n\n\n/*\n** RT_CFG - Bit field mask definitions\n*/\n#define FXAS21002_RT_CFG_XTEFE_MASK   ((uint8_t) 0x01)\n#define FXAS21002_RT_CFG_XTEFE_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_RT_CFG_YTEFE_MASK   ((uint8_t) 0x02)\n#define FXAS21002_RT_CFG_YTEFE_SHIFT  ((uint8_t)    1)\n\n#define FXAS21002_RT_CFG_ZTEFE_MASK   ((uint8_t) 0x04)\n#define FXAS21002_RT_CFG_ZTEFE_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_RT_CFG_ELE_MASK     ((uint8_t) 0x08)\n#define FXAS21002_RT_CFG_ELE_SHIFT    ((uint8_t)    3)\n\n\n/*\n** RT_CFG - Bit field value definitions\n*/\n#define FXAS21002_RT_CFG_XTEFE_ENABLE          ((uint8_t) 0x01)  /*  X event detection enabled.                           */\n#define FXAS21002_RT_CFG_XTEFE_DISABLE         ((uint8_t) 0x00)  /*  X event detection disabled.                          */\n#define FXAS21002_RT_CFG_YTEFE_ENABLE          ((uint8_t) 0x02)  /*  Y event detection enabled.                           */\n#define FXAS21002_RT_CFG_YTEFE_DISABLE         ((uint8_t) 0x00)  /*  Y event detection disabled.                          */\n#define FXAS21002_RT_CFG_ZTEFE_ENABLE          ((uint8_t) 0x04)  /*  Z event detection enabled.                           */\n#define FXAS21002_RT_CFG_ZTEFE_DISABLE         ((uint8_t) 0x00)  /*  Z event detection disabled.                          */\n#define FXAS21002_RT_CFG_ELE_ENABLE            ((uint8_t) 0x08)  /*  Event flag latch enabled.                            */\n#define FXAS21002_RT_CFG_ELE_DISABLE           ((uint8_t) 0x00)  /*  Event flag latch disabled.                           */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_SRC\n** Enum: FXAS21002_RT_SRC\n** --\n** Offset : 0x0F - Indicates the source of the Rate Threshold event. It also clears the RT_SRC flag in the INT_SOURCE_FLAG register.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t              x_rt_pol : 1; /*  Polarity of X event.                                                       */\n\n        uint8_t                   xrt : 1; /*  X rate Event.                                                              */\n\n        uint8_t              y_rt_pol : 1; /*  Polarity of Y event.                                                       */\n\n        uint8_t                   yrt : 1; /*  Y rate event.                                                              */\n\n        uint8_t              z_rt_pol : 1; /*  Polarity of Z event.                                                       */\n\n        uint8_t                   zrt : 1; /*  Z rate event.                                                              */\n\n        uint8_t                    ea : 1; /*  Event active flag.                                                         */\n\n    } b;\n    uint8_t w;\n} FXAS21002_RT_SRC_t;\n\n\n/*\n** RT_SRC - Bit field mask definitions\n*/\n#define FXAS21002_RT_SRC_X_RT_POL_MASK   ((uint8_t) 0x01)\n#define FXAS21002_RT_SRC_X_RT_POL_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_RT_SRC_XRT_MASK        ((uint8_t) 0x02)\n#define FXAS21002_RT_SRC_XRT_SHIFT       ((uint8_t)    1)\n\n#define FXAS21002_RT_SRC_Y_RT_POL_MASK   ((uint8_t) 0x04)\n#define FXAS21002_RT_SRC_Y_RT_POL_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_RT_SRC_YRT_MASK        ((uint8_t) 0x08)\n#define FXAS21002_RT_SRC_YRT_SHIFT       ((uint8_t)    3)\n\n#define FXAS21002_RT_SRC_Z_RT_POL_MASK   ((uint8_t) 0x10)\n#define FXAS21002_RT_SRC_Z_RT_POL_SHIFT  ((uint8_t)    4)\n\n#define FXAS21002_RT_SRC_ZRT_MASK        ((uint8_t) 0x20)\n#define FXAS21002_RT_SRC_ZRT_SHIFT       ((uint8_t)    5)\n\n#define FXAS21002_RT_SRC_EA_MASK         ((uint8_t) 0x40)\n#define FXAS21002_RT_SRC_EA_SHIFT        ((uint8_t)    6)\n\n\n/*\n** RT_SRC - Bit field value definitions\n*/\n#define FXAS21002_RT_SRC_X_RT_POL_POS          ((uint8_t) 0x00)  /*  Rate Event was Positive.                             */\n#define FXAS21002_RT_SRC_X_RT_POL_NEG          ((uint8_t) 0x01)  /*  Rate Event was Negative.                             */\n#define FXAS21002_RT_SRC_XRT_LOWER             ((uint8_t) 0x00)  /*  Rate lower than RT_THS value.                        */\n#define FXAS21002_RT_SRC_XRT_GREATER           ((uint8_t) 0x02)  /*  Rate greater than RT_THS value. Event has occured.   */\n#define FXAS21002_RT_SRC_Y_RT_POL_POS          ((uint8_t) 0x00)  /*  Rate Event was Positive.                             */\n#define FXAS21002_RT_SRC_Y_RT_POL_NEG          ((uint8_t) 0x04)  /*  Rate Event was Negative.                             */\n#define FXAS21002_RT_SRC_YRT_LOWER             ((uint8_t) 0x00)  /*  Rate lower than RT_THS value.                        */\n#define FXAS21002_RT_SRC_YRT_GREATER           ((uint8_t) 0x08)  /*  Rate greater than RT_THS value. Event has occured.   */\n#define FXAS21002_RT_SRC_Z_RT_POL_POS          ((uint8_t) 0x00)  /*  Rate Event was Positive.                             */\n#define FXAS21002_RT_SRC_Z_RT_POL_NEG          ((uint8_t) 0x10)  /*  Rate Event was Negative.                             */\n#define FXAS21002_RT_SRC_ZRT_LOWER             ((uint8_t) 0x00)  /*  Rate lower than RT_THS value.                        */\n#define FXAS21002_RT_SRC_ZRT_GREATER           ((uint8_t) 0x20)  /*  Rate greater than RT_THS value. Event has occured.   */\n#define FXAS21002_RT_SRC_EA_NOEVENT            ((uint8_t) 0x00)  /*  No event flags have been asserted.                   */\n#define FXAS21002_RT_SRC_EA_EVENT              ((uint8_t) 0x40)  /*  One or more event flags have been asserted.          */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_THS\n** Enum: FXAS21002_RT_THS\n** --\n** Offset : 0x10 - The RT_THS register sets the threshold limit for the detection of the rate and the debounce counter mode.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                   ths : 7; /*  Unsigned 7-bit rate threshold value; The contents should only be modified  */\n                                           /*  when the device is in Standby mode; The internal state of the Rate         */\n                                           /*  Threshold function is reset when a transition from Standby to Active or    */\n                                           /*  Ready to Active modes occurs.                                              */\n\n        uint8_t                dbcntm : 1; /*  Debounce counter mode selection.                                           */\n\n    } b;\n    uint8_t w;\n} FXAS21002_RT_THS_t;\n\n\n/*\n** RT_THS - Bit field mask definitions\n*/\n#define FXAS21002_RT_THS_THS_MASK      ((uint8_t) 0x7F)\n#define FXAS21002_RT_THS_THS_SHIFT     ((uint8_t)    0)\n\n#define FXAS21002_RT_THS_DBCNTM_MASK   ((uint8_t) 0x80)\n#define FXAS21002_RT_THS_DBCNTM_SHIFT  ((uint8_t)    7)\n\n\n/*\n** RT_THS - Bit field value definitions\n*/\n#define FXAS21002_RT_THS_DBCNTM_CLEAR          ((uint8_t) 0x80)  /*  Clear counter when angular rate is below the         */\n                                                                 /*  threshold value.                                     */\n#define FXAS21002_RT_THS_DBCNTM_DECREMENT      ((uint8_t) 0x00)  /*  Decrement counter on every ODR cycle that the        */\n                                                                 /*  angular rate is below the threshold value.           */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_COUNT\n** Enum: FXAS21002_RT_COUNT\n** --\n** Offset : 0x11 - Sets the number of debounce counts.\n** ------------------------------*/\ntypedef uint8_t FXAS21002_RT_COUNT_t;\n\n\n\n/*--------------------------------\n** Register: TEMP\n** Enum: FXAS21002_TEMP\n** --\n** Offset : 0x12 - The TEMP register contains an 8-bit 2's complement temperature value with a range of 128 C to +127 C and a scaling of 1 C/LSB.\n** ------------------------------*/\ntypedef uint8_t FXAS21002_TEMP_t;\n\n\n\n/*--------------------------------\n** Register: CTRL_REG1\n** Enum: FXAS21002_CTRL_REG1\n** --\n** Offset : 0x13 - The CTRL_REG1 register is used to configure the device ODR, set the operating mode, soft-reset the device, and exercise the Self-Test function.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                  mode : 2; /*  Operational Mode.                                                          */\n\n        uint8_t                    dr : 3; /*  Output Data Rate selection.                                                */\n\n        uint8_t                    st : 1; /*  Self-Test Enable.                                                          */\n\n        uint8_t                   rst : 1; /*  Software Reset.                                                            */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG1_t;\n\n\n/*\n** CTRL_REG1 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG1_MODE_MASK   ((uint8_t) 0x03)\n#define FXAS21002_CTRL_REG1_MODE_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG1_DR_MASK     ((uint8_t) 0x1C)\n#define FXAS21002_CTRL_REG1_DR_SHIFT    ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG1_ST_MASK     ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG1_ST_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_CTRL_REG1_RST_MASK    ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG1_RST_SHIFT   ((uint8_t)    6)\n\n\n/*\n** CTRL_REG1 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG1_MODE_STANDBY          ((uint8_t) 0x00)  /*  Standby Mode. Register setting allowed. Lowest    */\n                                                                    /*  power.                                            */\n#define FXAS21002_CTRL_REG1_MODE_READY            ((uint8_t) 0x01)  /*  Ready Mode. The device is ready to measure        */\n                                                                    /*  angular rate but no data acquisitions are being   */\n                                                                    /*  made. Register reads only. Reduced power.         */\n#define FXAS21002_CTRL_REG1_MODE_ACTIVE           ((uint8_t) 0x02)  /*  Active Mode. The device is fully functional.      */\n                                                                    /*  Register reads only. Maximum power.               */\n#define FXAS21002_CTRL_REG1_DR_800HZ              ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG1_DR_400HZ              ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG1_DR_200HZ              ((uint8_t) 0x08)\n#define FXAS21002_CTRL_REG1_DR_100HZ              ((uint8_t) 0x0c)\n#define FXAS21002_CTRL_REG1_DR_50HZ               ((uint8_t) 0x10)\n#define FXAS21002_CTRL_REG1_DR_25HZ               ((uint8_t) 0x14)\n#define FXAS21002_CTRL_REG1_DR_12_5HZ             ((uint8_t) 0x18)\n#define FXAS21002_CTRL_REG1_ST_ENABLE             ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG1_ST_DISABLE            ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG1_RST_TRIGGER           ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG1_RST_NOTTRIGGERED      ((uint8_t) 0x00)\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: CTRL_REG2\n** Enum: FXAS21002_CTRL_REG2\n** --\n** Offset : 0x14 - This register enables and assigns the output pin(s) and logic polarities for the various interrupt sources available on the device.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                 pp_od : 1; /*  INT1 and INT2 pin output driver configuration.                             */\n\n        uint8_t                  ipol : 1; /*  Interrupt logic polarity.                                                  */\n\n        uint8_t           int_en_drdy : 1; /*  Data ready interrupt enable.                                               */\n\n        uint8_t          int_cfg_drdy : 1; /*  Data-ready interrupt pin routing.                                          */\n\n        uint8_t             int_en_rt : 1; /*  Rate threshold interrupt enable.                                           */\n\n        uint8_t            int_cfg_rt : 1; /*  Rate threshold interrupt pin routing.                                      */\n\n        uint8_t           int_en_fifo : 1; /*  FIFO Interrupt Enable.                                                     */\n\n        uint8_t          int_cfg_fifo : 1; /*  FIFO interrupt pin routing.                                                */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG2_t;\n\n\n/*\n** CTRL_REG2 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG2_PP_OD_MASK          ((uint8_t) 0x01)\n#define FXAS21002_CTRL_REG2_PP_OD_SHIFT         ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG2_IPOL_MASK           ((uint8_t) 0x02)\n#define FXAS21002_CTRL_REG2_IPOL_SHIFT          ((uint8_t)    1)\n\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_MASK    ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_SHIFT   ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_MASK   ((uint8_t) 0x08)\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_SHIFT  ((uint8_t)    3)\n\n#define FXAS21002_CTRL_REG2_INT_EN_RT_MASK      ((uint8_t) 0x10)\n#define FXAS21002_CTRL_REG2_INT_EN_RT_SHIFT     ((uint8_t)    4)\n\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_MASK     ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_MASK    ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_SHIFT   ((uint8_t)    6)\n\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_MASK   ((uint8_t) 0x80)\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_SHIFT  ((uint8_t)    7)\n\n\n/*\n** CTRL_REG2 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG2_PP_OD_PUSHPULL        ((uint8_t) 0x00)  /*  Push-pull output driver.                          */\n#define FXAS21002_CTRL_REG2_PP_OD_OPENDRAIN       ((uint8_t) 0x01)  /*  Open-drain output driver.                         */\n#define FXAS21002_CTRL_REG2_IPOL_ACTIVE_LOW       ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_IPOL_ACTIVE_HIGH      ((uint8_t) 0x02)\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_ENABLE    ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_DISABLE   ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_INT2     ((uint8_t) 0x00)  /*  Interrupt is routed to INT2 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_INT1     ((uint8_t) 0x08)  /*  Interrupt is routed to INT1 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_EN_RT_ENABLE      ((uint8_t) 0x10)\n#define FXAS21002_CTRL_REG2_INT_EN_RT_DISABLE     ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_INT2       ((uint8_t) 0x00)  /*  Interrupt is routed to INT2 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_INT1       ((uint8_t) 0x20)  /*  Interrupt is routed to INT1 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_ENABLE    ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_DISABLE   ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_INT2     ((uint8_t) 0x00)  /*  Interrupt is routed to INT2 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_INT1     ((uint8_t) 0x80)  /*  Interrupt is routed to INT1 pin.                  */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: CTRL_REG3\n** Enum: FXAS21002_CTRL_REG3\n** --\n** Offset : 0x15 - Auto-increment address configuration, external power control, Full Scale Range (FSR) expansion\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t             fs_double : 1; /*  Increases the dynamic range for each CTRL_REG0 : FS selection by a factor  */\n                                           /*  of two.                                                                    */\n\n        uint8_t _reserved_            : 1;\n        uint8_t             extctrlen : 1; /*  External power mode control input.                                         */\n\n        uint8_t             wraptoone : 1; /*  Auto-increment read address pointer roll-over behavior.                    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG3_t;\n\n\n/*\n** CTRL_REG3 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_MASK   ((uint8_t) 0x01)\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_MASK   ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG3_WRAPTOONE_MASK   ((uint8_t) 0x08)\n#define FXAS21002_CTRL_REG3_WRAPTOONE_SHIFT  ((uint8_t)    3)\n\n\n/*\n** CTRL_REG3 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_ENABLE      ((uint8_t) 0x01)  /*  Maximum full-scale range selections are doubled   */\n                                                                    /*  (4000, 2000, 1000, 500 dps).                      */\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_DISABLE     ((uint8_t) 0x00)  /*  Maximum full-scale range selections are as per    */\n                                                                    /*  selectable full-scale ranges (2000, 1000, 500,    */\n                                                                    /*  250 dps).                                         */\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_INT2        ((uint8_t) 0x00)  /*  INT2 pin is used as an interrupt output           */\n                                                                    /*  (default).                                        */\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_POWER_CONTROL ((uint8_t) 0x04)  /*  INT2 pin becomes an input pin that may be used  */\n                                                                      /*  to control the power mode.                      */\n#define FXAS21002_CTRL_REG3_WRAPTOONE_ROLL_STATUS ((uint8_t) 0x00)  /*  The auto-increment read address pointer rolls     */\n                                                                    /*  over to address 0x00 (STATUS) after the Z-axis    */\n                                                                    /*  LSB is read (default).                            */\n#define FXAS21002_CTRL_REG3_WRAPTOONE_ROLL_DATA   ((uint8_t) 0x08)  /*  The auto-increment pointer rolls over to address  */\n                                                                    /*  0x01 (X-axis MSB) in order to facilitate the      */\n                                                                    /*  faster read out of the FIFO data in a single      */\n                                                                    /*  burst read operation.                             */\n/*------------------------------*/\n\n\n#endif /* FXAS21002_H_ */\n"
              },
              "objects": {
                "fxas21002.c": "#include \"fxas21002.h\"\n\ntypedef struct {\n    ATMO_FXAS21002_Config_t config;\n    bool configured;\n} ATMO_FXAS21002_Priv_Config;\n\nstatic ATMO_FXAS21002_Priv_Config _ATMO_FXAS21002_config = {0};\n\nstatic bool _ATMO_FXAS21002_Enabled = true;\n\nstatic ATMO_I2C_Status_t ATMO_FXAS21002_ReadReg(uint8_t regId, uint8_t *data, uint8_t len)\n{\n\treturn ATMO_I2C_MasterRead(_ATMO_FXAS21002_config.config.i2cDriverInstance, _ATMO_FXAS21002_config.config.address, &regId, 1, data, len, 1000);\n}\n\nstatic ATMO_I2C_Status_t ATMO_FXAS21002_WriteReg(uint8_t regId, uint8_t data, uint8_t mask)\n{\n\tuint8_t writeByte = data;\n\n\tif(mask)\n\t{\n\t\tif(ATMO_FXAS21002_ReadReg(regId, &writeByte, 1) != ATMO_I2C_Status_Success)\n\t\t{\n\t\t\treturn ATMO_I2C_Status_Fail;\n\t\t}\n\n\t\t// Zero out mask\n\t\twriteByte = (writeByte & (~mask)) | data;\n\t}\n\n\treturn ATMO_I2C_MasterWrite(_ATMO_FXAS21002_config.config.i2cDriverInstance, _ATMO_FXAS21002_config.config.address, &regId, 1, &writeByte, 1, 1000);\n}\n\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_Init(ATMO_FXAS21002_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_FXAS21002_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_FXAS21002_config.configured = false;\n    }\n\n\treturn ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetEnabled(bool enabled)\n{\n\t_ATMO_FXAS21002_Enabled = enabled;\n\treturn ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetEnabled(bool *enabled)\n{\n\t*enabled = _ATMO_FXAS21002_Enabled;\n\treturn ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetConfiguration(const ATMO_FXAS21002_Config_t *config)\n{\n    if( config == NULL || !_ATMO_FXAS21002_Enabled)\n    {\n        return ATMO_FXAS21002_Status_Fail;\n    }\n\n    memcpy( &_ATMO_FXAS21002_config.config, config, sizeof(ATMO_FXAS21002_Config_t) );\n    _ATMO_FXAS21002_config.configured = true;\n\n    // Check the whoami register\n    uint8_t whoAmI = 0;\n\n    if(ATMO_FXAS21002_ReadReg(FXAS21002_WHO_AM_I, &whoAmI, 1) != ATMO_I2C_Status_Success || whoAmI != FXAS21002_WHO_AM_I_WHOAMI_PROD_VALUE)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n    // Put into standby mode\n    if(ATMO_FXAS21002_WriteReg(FXAS21002_CTRL_REG1, FXAS21002_CTRL_REG1_MODE_STANDBY, FXAS21002_CTRL_REG1_MODE_MASK) != ATMO_I2C_Status_Success)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n\n    // Set to 12.5hz sampling rate\n    if(ATMO_FXAS21002_WriteReg(FXAS21002_CTRL_REG1, _ATMO_FXAS21002_config.config.samplingRate, FXAS21002_CTRL_REG1_DR_MASK) != ATMO_I2C_Status_Success)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n    // Put into active mode\n    if(ATMO_FXAS21002_WriteReg(FXAS21002_CTRL_REG1, FXAS21002_CTRL_REG1_MODE_ACTIVE, FXAS21002_CTRL_REG1_MODE_MASK) != ATMO_I2C_Status_Success)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n\n    return ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetConfiguration(ATMO_FXAS21002_Config_t *config)\n{\n    if( config == NULL || !_ATMO_FXAS21002_config.configured )\n    {\n        return ATMO_FXAS21002_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_FXAS21002_config.config, sizeof(ATMO_FXAS21002_Config_t));\n\n    return ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetSensorData(ATMO_FXAS21002_SensorData_t *data)\n{\n    if( !_ATMO_FXAS21002_config.configured || !_ATMO_FXAS21002_Enabled)\n    {\n        return ATMO_FXAS21002_Status_Fail;\n    }\n\n\n\tuint8_t rawData[6] = {0};\n\n\tif(ATMO_FXAS21002_ReadReg(FXAS21002_OUT_X_MSB, rawData, 6) != ATMO_I2C_Status_Success)\n\t{\n\t\treturn ATMO_FXAS21002_Status_Fail;\n\t}\n\n\t// Get scale for conversion\n\tuint8_t fs = 0;\n\tif(ATMO_FXAS21002_ReadReg(FXAS21002_CTRL_REG0, &fs, 1) != ATMO_I2C_Status_Success)\n\t{\n\t\treturn ATMO_FXAS21002_Status_Fail;\n\t}\n\n\tfs &= FXAS21002_CTRL_REG0_FS_MASK;\n\n\t// Multiplier for dps/LSB\n\tfloat multiplier = 0.0;\n\n\tswitch(fs)\n\t{\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS2000:\n\t\t{\n\t\t\tmultiplier = .0625;\n\t\t\tbreak;\n\t\t}\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS1000:\n\t\t{\n\t\t\tmultiplier = .03125;\n\t\t\tbreak;\n\t\t}\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS500:\n\t\t{\n\t\t\tmultiplier = .015625;\n\t\t\tbreak;\n\t\t}\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS250:\n\t\t{\n\t\t\tmultiplier = .0078125;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint16_t dataCounts[3] = {0};\n\tdataCounts[0] = ((int16_t)rawData[0] << 8) | rawData[1];\n\tdataCounts[1] = ((int16_t)rawData[2] << 8) | rawData[3];\n\tdataCounts[2] = ((int16_t)rawData[4] << 8) | rawData[5];\n\n\tdata->X = multiplier * dataCounts[0];\n\tdata->Y = multiplier * dataCounts[1];\n\tdata->Z = multiplier * dataCounts[2];\n\n\treturn ATMO_FXAS21002_Status_Success;\n}\n"
              }
            }
          },
          "md5": "dca9ca0fc7bfe522d8bb69f241b1bcf1"
        }
      },
      "static": {
        "header": "",
        "footer": "",
        "functions": {
          "ATMO_Setup": {
            "returnType": "void",
            "code": "\n",
            "arguments": []
          }
        }
      }
    },
    "App View": {
      "type": "app",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {
        "appViewLayouts": {
          "360": {
            "640": true
          },
          "375": {
            "667": true
          },
          "1024": {
            "768": true
          }
        }
      },
      "elements": [
        {
          "name": "AirQualityLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 229,
                  "y": 314,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 384,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 560,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 482,
            "editorY": 700
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LightLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 384,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 314,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 460,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 478,
            "editorY": 533
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "HumidityLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 244,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 244,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 260,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 477,
            "editorY": 232
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "TemperatureLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 174,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 174,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 160,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 469,
            "editorY": 79
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AppUIImage1",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 300,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 300,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 448,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 741,
            "editorY": 407
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 370,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 370,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 548,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 738,
            "editorY": 306
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage3",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 230,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 230,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 248,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 741,
            "editorY": 88
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage4",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 160,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 160,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 148,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 731,
            "editorY": 3
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "LightColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 290,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 290,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 420,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDk8L3RpdGxlPjxjaXJjbGUgY3g9IjU1IiBjeT0iNTIuNSIgcj0iMzUuNzE0IiBzdHlsZT0iZmlsbDojNzM4NWJmIi8+PHBhdGggZD0iTTU1LDEwMi41YTUwLDUwLDAsMSwxLDUwLTUwQTUwLjA1Nyw1MC4wNTcsMCwwLDEsNTUsMTAyLjVaTTU1LDQuMjg2QTQ4LjIxNCw0OC4yMTQsMCwxLDAsMTAzLjIxNCw1Mi41LDQ4LjI2OCw0OC4yNjgsMCwwLDAsNTUsNC4yODZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTU1LDQ0YTguNSw4LjUsMCwxLDEtOC41LDguNUE4LjUxMiw4LjUxMiwwLDAsMSw1NSw0NG0wLTIuMTI2QTEwLjYyOSwxMC42MjksMCwxLDAsNjUuNjI5LDUyLjUsMTAuNjI5LDEwLjYyOSwwLDAsMCw1NSw0MS44NzFaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTU1LDM4LjY4MmExLjA2MywxLjA2MywwLDAsMS0xLjA2My0xLjA2M1YzMS4yNDFhMS4wNjMsMS4wNjMsMCwwLDEsMi4xMjYsMHY2LjM3OEExLjA2MywxLjA2MywwLDAsMSw1NSwzOC42ODJaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTQ0LjQ3OCw0My4wNDFhMS4wNiwxLjA2LDAsMCwxLS43NTItLjMxMmwtNC41MS00LjUwOWExLjA2MywxLjA2MywwLDAsMSwxLjUtMS41bDQuNTA5LDQuNTFhMS4wNjQsMS4wNjQsMCwwLDEtLjc1MSwxLjgxNVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNNDAuMTE5LDUzLjU2M0gzMy43NDFhMS4wNjMsMS4wNjMsMCwwLDEsMC0yLjEyNmg2LjM3OGExLjA2MywxLjA2MywwLDAsMSwwLDIuMTI2WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0zOS45NjgsNjguNmExLjA2MywxLjA2MywwLDAsMS0uNzUyLTEuODE0bDQuNTEtNC41MWExLjA2MywxLjA2MywwLDAsMSwxLjUsMS41bC00LjUwOSw0LjUxQTEuMDU5LDEuMDU5LDAsMCwxLDM5Ljk2OCw2OC42WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik01NSw3NC44MjFhMS4wNjIsMS4wNjIsMCwwLDEtMS4wNjMtMS4wNjNWNjcuMzgxYTEuMDYzLDEuMDYzLDAsMCwxLDIuMTI2LDB2Ni4zNzdBMS4wNjIsMS4wNjIsMCwwLDEsNTUsNzQuODIxWiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik03MC4wMzMsNjguNmExLjA1OSwxLjA1OSwwLDAsMS0uNzUyLS4zMTFsLTQuNTEtNC41MWExLjA2MywxLjA2MywwLDAsMSwxLjUtMS41bDQuNTEsNC41MWExLjA2MywxLjA2MywwLDAsMS0uNzUxLDEuODE0WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik03Ni4yNTksNTMuNTYzSDY5Ljg4MWExLjA2MywxLjA2MywwLDAsMSwwLTIuMTI2aDYuMzc4YTEuMDYzLDEuMDYzLDAsMCwxLDAsMi4xMjZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTY1LjUyMiw0My4wNDFhMS4wNjQsMS4wNjQsMCwwLDEtLjc1MS0xLjgxNWw0LjUxLTQuNTFhMS4wNjMsMS4wNjMsMCwwLDEsMS41LDEuNWwtNC41MSw0LjUwOUExLjA2LDEuMDYsMCwwLDEsNjUuNTIyLDQzLjA0MVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNMTI5LjkxMywzNy42MzFoMi40OTV2MjQuMTloLTIuNDk1WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0xMzguODQxLDM5LjE2N2ExLjgyMiwxLjgyMiwwLDAsMSwxLjgyMywxLjgyNCwxLjgyNCwxLjgyNCwwLDAsMS0zLjY0NywwQTEuODIzLDEuODIzLDAsMCwxLDEzOC44NDEsMzkuMTY3Wm0tMS4yNDgsNy42OGgyLjVWNjEuODIxaC0yLjVaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTE1OS45OTEsNjEuMTQ5YzAsNS40MDgtMi45MTEsOC4zNTItOC4xNTksOC4zNTJhOS43MzQsOS43MzQsMCwwLDEtNy4zNTktMi44NDhsMS43OTItMi4wNDhhNy4xNDYsNy4xNDYsMCwwLDAsNS41NjcsMi41OTJjNC40OCwwLDUuNjY0LTIuODgsNS42NjQtNi4wNDh2LTEuOTJoLS4wNjRhNi4xMiw2LjEyLDAsMCwxLTUuMjgsMi43ODVjLTQuNywwLTcuOTY3LTMuMjY1LTcuOTY3LTcuNjgsMC00LjksMy4yLTcuODcyLDcuOTY3LTcuODcyYTUuODc4LDUuODc4LDAsMCwxLDUuMjgsMi45NDRoLjA2NFY0Ni44NDdoMi41Wm0tNy44MzktMS40NEE1LjE3OCw1LjE3OCwwLDAsMCwxNTcuNSw1NC4yN2E1LjE4Myw1LjE4MywwLDAsMC01LjM0NC01LjUsNS40NzQsNS40NzQsMCwwLDAsMCwxMC45NDJaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTE2NC42LDM3LjYzMWgyLjV2MTEuM2guMDY0YTUuNjExLDUuNjExLDAsMCwxLDQuOC0yLjQ2NGMzLjkzNiwwLDUuNjk1LDIuNSw1LjY5NSw2LjExMnY5LjI0N2gtMi41VjUyLjgzYzAtMi41LTEuMDg4LTQuMDYzLTMuNDI0LTQuMDYzLTMuMjMyLDAtNC42NCwyLjMzNi00LjY0LDUuNzU4djcuM2gtMi41WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0xOTAuNTg0LDQ4Ljk1OGgtNC40MTZ2Ny40ODdjMCwxLjkyLjAzMiwzLjQ1NiwyLjI0LDMuNDU2YTQuODY3LDQuODY3LDAsMCwwLDIuMjA3LS41MTFsLjEsMi4yNzFhNy41OCw3LjU4LDAsMCwxLTIuOTExLjU0NGMtMy41NTIsMC00LjEyOC0xLjkyLTQuMTI4LTUuMDIzVjQ4Ljk1OGgtMy4yNjRWNDYuODQ3aDMuMjY0VjQyLjU5MWgyLjV2NC4yNTZoNC40MTZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PC9zdmc+",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 24,
            "editorY": 317
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "HumidityColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 220,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 220,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 220,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDc8L3RpdGxlPjxjaXJjbGUgY3g9IjU1IiBjeT0iNTIuNSIgcj0iMzUuNzE0IiBzdHlsZT0iZmlsbDojNzM4NWJmIi8+PHBhdGggZD0iTTEyOS42ODksMzcuNjMxaDIuNXYxMS4zaC4wNjRhNS42MTEsNS42MTEsMCwwLDEsNC44LTIuNDYzYzMuOTM1LDAsNS42OTUsMi40OTUsNS42OTUsNi4xMTF2OS4yNDdoLTIuNVY1Mi44M2MwLTIuNS0xLjA4OC00LjA2NC0zLjQyNC00LjA2NC0zLjIzMiwwLTQuNjQsMi4zMzYtNC42NCw1Ljc1OXY3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNMTYwLjUzNiw1OC4yN2MwLDEuMzc2LjEyOCwyLjU2LjEyOCwzLjU1MUgxNTguM2MwLS44LS4wNjQtMS42MzItLjA2NC0yLjQ2NGgtLjA2NGE1LjQzMyw1LjQzMywwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDZoMi41djguOTkyYzAsMi41LDEuMDg4LDQuMDYzLDMuNDI0LDQuMDYzLDMuMjMxLDAsNC42NC0yLjMzNiw0LjY0LTUuNzU5di03LjNoMi41WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0xNjUuMjczLDUwLjRjMC0xLjM3Ni0uMTI4LTIuNTYtLjEyOC0zLjU1MmgyLjM2OGMwLC44LjA2NCwxLjYzMy4wNjQsMi40NjVoLjA2NGE1LjQzNiw1LjQzNiwwLDAsMSw0Ljk5Mi0yLjg0OGMzLjIzMSwwLDQuMjU1LDEuODIzLDQuNzM1LDIuODQ4YTUuMiw1LjIsMCwwLDEsNC43MzYtMi44NDhjNC4yODgsMCw1LjY5NSwyLjQsNS42OTUsNi4yNzF2OS4wODdoLTIuNXYtOC45NmMwLTIuMDc5LS43MzYtNC4wOTUtMy42NDgtNC4wOTUtMi4xMTIsMC0zLjg3MiwxLjcyOC0zLjg3Miw0LjQxNnY4LjYzOWgtMi41VjUzLjM0MmMwLTMuMy0uODMyLTQuNTc2LTIuODgtNC41NzYtMy4yMzIsMC00LjY0LDIuMzM2LTQuNjQsNS43NTl2Ny4zaC0yLjVaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTE5NC4wMDksMzkuMTY3YTEuODIzLDEuODIzLDAsMCwxLDEuODI0LDEuODIzLDEuODI0LDEuODI0LDAsMCwxLTMuNjQ4LDBBMS44MjMsMS44MjMsMCwwLDEsMTk0LjAwOSwzOS4xNjdabS0xLjI0OCw3LjY3OWgyLjVWNjEuODIxaC0yLjVaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTIxMi42NjQsNTkuMTY2SDIxMi42YTYuNDg3LDYuNDg3LDAsMCwxLTUuNzYsMy4wMzksNy41NjgsNy41NjgsMCwwLDEtNy40ODctNy44NzEsNy41NDIsNy41NDIsMCwwLDEsNy44NzEtNy44NzEsNi45NDIsNi45NDIsMCwwLDEsNS4zNzYsMi41NTloLjA2NFYzNy42MzFoMi41djI0LjE5aC0yLjVabS01LjMxMi0xMC40YTUuMjI3LDUuMjI3LDAsMCwwLTUuMzExLDUuNTY4LDUuMzE3LDUuMzE3LDAsMSwwLDEwLjYyMywwQTUuMjI4LDUuMjI4LDAsMCwwLDIwNy4zNTIsNDguNzY2WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0yMjEuMjQsMzkuMTY3YTEuODIzLDEuODIzLDAsMCwxLDEuODI0LDEuODIzLDEuODI0LDEuODI0LDAsMSwxLTMuNjQ4LDBBMS44MjMsMS44MjMsMCwwLDEsMjIxLjI0LDM5LjE2N1ptLTEuMjQ4LDcuNjc5aDIuNVY2MS44MjFoLTIuNVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNMjM1LjYzOSw0OC45NThoLTQuNDE1djcuNDg3YzAsMS45Mi4wMzIsMy40NTYsMi4yMzksMy40NTZhNC44NjgsNC44NjgsMCwwLDAsMi4yMDgtLjUxMWwuMSwyLjI3MWE3LjU4OSw3LjU4OSwwLDAsMS0yLjkxMi41NDRjLTMuNTUxLDAtNC4xMjctMS45Mi00LjEyNy01LjAyM1Y0OC45NThoLTMuMjY0VjQ2Ljg0NmgzLjI2NFY0Mi41OTFoMi41djQuMjU1aDQuNDE1WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0yNDQuMjE1LDY1LjI0NWMtLjk5MiwyLjUyOC0xLjk4NCw0LjI1Ni00Ljk5MSw0LjI1NmE1LjQyNyw1LjQyNywwLDAsMS0yLjI0LS4zODRsLjMyLTIuMTc2YTQuODU0LDQuODU0LDAsMCwwLDEuNzU5LjI1NmMxLjYzMiwwLDIuMjQtLjk5MiwyLjc4NC0yLjQ2NWwxLjAyNC0yLjgxNC02LjIwNy0xNS4wNzJoMi45MTJsNC42MzksMTEuNzQ0aC4wNjRsNC40NDgtMTEuNzQ0aDIuNzJaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTU1LDEwMi41YTUwLDUwLDAsMSwxLDUwLTUwQTUwLjA1Nyw1MC4wNTcsMCwwLDEsNTUsMTAyLjVaTTU1LDQuMjg2QTQ4LjIxNCw0OC4yMTQsMCwxLDAsMTAzLjIxNCw1Mi41LDQ4LjI2OCw0OC4yNjgsMCwwLDAsNTUsNC4yODZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTYwLjcxNCw0Mi43NDVsLS4wNTctLjA3Ni4wNjctLjA2OGMuMTA4LS4xMTIuNTU2LS41NTcuNjg5LS42OWwuMDM3LS4wMzdjLjIwNi0uMjc0LjMxOC0uNjY4LjA4NC0uOWEuNjg2LjY4NiwwLDAsMC0xLjAyNi0uMTU4aDBzLS4wMi4wMTgtLjMzMy4yNjVjLS4xOS4xNS0uNC4zMTgtLjQ3My4zNzVsLS4wNzcuMDYyLS4wNzEtLjA2OWExMS4wMzcsMTEuMDM3LDAsMCwwLTE4LjcyOCw3LjkyOCwxMS4xMTEsMTEuMTExLDAsMCwwLDMuNjQ3LDguMTc3Ljc4OC43ODgsMCwwLDAsMS4wNS0xLjE3NCw5LjQ1Nyw5LjQ1NywwLDAsMSw2LjM1Mi0xNi40OSw5LjUsOS41LDAsMCwxLDYuNDM3LDIuNDg1bC4xLjA4OS0uMS4wODFjLTEuOTIyLDEuNTE1LTQuMDc1LDMuMTk0LTUuNTMxLDQuMzI5bC0uNTM0LjQxNi0uMDQ4LS4wMDdhMi4wMjUsMi4wMjUsMCwwLDAtLjMxNy0uMDI3QTIuMTIxLDIuMTIxLDAsMSwwLDU0LDQ5LjQ1NHYtLjA0M2wuMDMxLS4wMzFjMS4wNDItMS4wNTEsMi43OTItMi44Miw0LjQ5My00LjUzOWwxLjA0Mi0xLjA1Mi4wNzcuMTA5YTkuNTEyLDkuNTEyLDAsMCwxLDEuNzIyLDUuNDc3LDkuNCw5LjQsMCwwLDEtMy4xMzQsNywuNzg4Ljc4OCwwLDAsMCwxLjA1LDEuMTc0LDExLjExLDExLjExLDAsMCwwLDMuNjQ2LTguMTc2QTEwLjk3OCwxMC45NzgsMCwwLDAsNjAuNzE0LDQyLjc0NVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNNjcuNCw1OS4yMzFhLjc4MS43ODEsMCwwLDAtLjczMS0xLjE1aC0uMDgxYS43NzYuNzc2LDAsMCwwLS41NzcuNDM4Yy0uMDcxLjE0Mi0uMTg4LjM1Ny0uMzM2LjYyNy0uMzMyLjYwNi0uODMzLDEuNTIxLTEuMjgyLDIuNWExMS4zMiwxMS4zMiwwLDAsMC0xLjI0Niw0LjQ3M0E1LjMyMyw1LjMyMywwLDAsMCw2NC45MjQsNzBhLjc5NC43OTQsMCwwLDAsLjguMjM3Ljc4Ljc4LDAsMCwwLC4yNTctMS4zNzYsMy45MywzLjkzLDAsMCwxLTEuMjcyLTIuNzQsMTAuMzMyLDEwLjMzMiwwLDAsMSwxLjEtMy44MTNjLjQtLjg3OC44MzQtMS42NjcsMS4xOC0yLjNDNjcuMTU1LDU5LjcsNjcuMyw1OS40MzQsNjcuNCw1OS4yMzFaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTczLjA2OSw1NS4xODJjLS44MTktMS4zMjMtMS41OTQtMi40MzMtMi4yNTYtMy4zNzFsLS4wMjUtLjAzNC4wMDUtLjA0M2EyMS4zNzcsMjEuMzc3LDAsMCwwLC4xNjctMi4zNTlBMTguOTQyLDE4Ljk0MiwwLDEsMCw1OS41MzEsNjYuOTA3bC4xMzMtLjA1OS4wMjIuMTQ0YTguODg3LDguODg3LDAsMCwwLDguNzA3LDcuNzE4LDkuMDE0LDkuMDE0LDAsMCwwLDguODE3LTkuMThDNzcuMjEsNjIuMjY3LDc1LDU4LjI4Niw3My4wNjksNTUuMTgyWk02MC4zNiw2Mi44YTEwLjczMiwxMC43MzIsMCwwLDAtLjQxNCwyLjI2NWwwLC4wNjQtLjA1OC4wMjlBMTcuNTY1LDE3LjU2NSwwLDAsMSwzNC43LDQ5LjM3NWExNy41MjMsMTcuNTIzLDAsMSwxLDM1LjA0NSwwdi40NzdsLS4yLS4yNjctLjE5NC0uMjUtLjYxLS43OC0uNjA5Ljc4cy0uMTcxLjI0Ny0uMi4yNzlsLS4yLjI1N3YtLjQ5MUExNS4yNzgsMTUuMjc4LDAsMCwwLDU3LjQ3MywzNC43MzRhMTUuNzA5LDE1LjcwOSwwLDAsMC0xNS4yODUsMi44MkExNS41LDE1LjUsMCwwLDAsNjAuMiw2Mi42NzJsLjI0Mi0uMTQ0Wm01LjQ2Ni0xMy40MjNhMTQuNTMzLDE0LjUzMywwLDAsMS0uMzkzLDMuMmwtLjAxNy4wMzktLjAyNy4wMzljLS41NC43ODUtMS4xLDEuNi0xLjY3MiwyLjUyNGE0NS45NjEsNDUuOTYxLDAsMCwwLTIuNSw0LjUzNmwtLjAyNy4wMzZhMTMuOTQzLDEzLjk0MywwLDEsMSw0LjY0MS0xMC4zNzlabTIuNTY3LDIzLjc3MmE3LjQsNy40LDAsMCwxLTcuMjU1LTcuMzYyLDEuMDIzLDEuMDIzLDAsMCwwLDAtLjI0MSwxMy4wNDUsMTMuMDQ1LDAsMCwxLDEuMzc2LTQuODU5LjMuMywwLDAsMCwuMDI2LS4wNTFsLjAxMy0uMDMxLjAzMi0uMDI2YS43NzIuNzcyLDAsMCwwLC4xNDQtLjM2MWwuMDA5LS4wMzVhNDEuMjYyLDQxLjI2MiwwLDAsMSwyLjMtNC4xNjhjLjYyOS0xLjAxNywxLjE2NC0xLjgsMS42NDktMi40ODlhLjg1NS44NTUsMCwwLDAsLjIwOS0uMzM0bC4wMTUtLjAyOWMuNDkzLS42OTIuOS0xLjIwOCwxLjE5My0xLjU4NGwuMjkyLS4zNzUuMTQ4LjE4OWMuMTczLjIyMi40NTkuNTg4LjcuOWwuMDE3LjAzNWEuNzgzLjc4MywwLDAsMCwuMzQyLjQ0bC4wMzIuMDI5Yy42LjgyMywxLjI5MywxLjg3NSwyLjEyNSwzLjIxNi45MTQsMS40NzMsMy45LDYuNTEyLDMuOSw5LjUxN0E3LjM2Myw3LjM2MywwLDAsMSw2OC4zOTMsNzMuMTQ3WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjwvc3ZnPg==",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 25,
            "editorY": 155
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "TemperatureColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 150,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 150,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 120,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDY8L3RpdGxlPjxjaXJjbGUgY3g9IjU1IiBjeT0iNTIuNSIgcj0iMzUuNzE0IiBzdHlsZT0iZmlsbDojNzM4NWJmIi8+PHBhdGggZD0iTTEzNi45ODgsNDguOTU4aC00LjQxNnY3LjQ4N2MwLDEuOTIuMDMyLDMuNDU2LDIuMjQsMy40NTZhNC44NzEsNC44NzEsMCwwLDAsMi4yMDgtLjUxMWwuMSwyLjI3MWE3LjU4OSw3LjU4OSwwLDAsMS0yLjkxMi41NDRjLTMuNTUyLDAtNC4xMjctMS45Mi00LjEyNy01LjAyM1Y0OC45NThoLTMuMjY0VjQ2Ljg0NmgzLjI2NFY0Mi41OTFoMi41djQuMjU1aDQuNDE2WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xNTMuNDM1LDU5LjFhNy42ODMsNy42ODMsMCwwLDEtNi42NTUsMy4xYy00LjcsMC03LjU4NC0zLjUxOS03LjU4NC03Ljg3MWE3LjUsNy41LDAsMCwxLDcuNjc5LTcuODcxYzQuMjI1LDAsNy4xLDIuODc5LDcuMSw3LjgzOXYuOGgtMTIuMWE1LjAwNyw1LjAwNywwLDAsMCw0LjksNC44LDUuNTc4LDUuNTc4LDAsMCwwLDQuNzY3LTIuMjcyWm0tMi4xNDMtNi4xMTJhNC4xNjQsNC4xNjQsMCwwLDAtNC41MTItNC4yMjQsNC42MzQsNC42MzQsMCwwLDAtNC45LDQuMjI0WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xNTcuODUyLDUwLjRjMC0xLjM3Ni0uMTI4LTIuNTYtLjEyOC0zLjU1MmgyLjM2OGMwLC44LjA2NCwxLjYzMy4wNjQsMi40NjVoLjA2NGE1LjQzNiw1LjQzNiwwLDAsMSw0Ljk5Mi0yLjg0OGMzLjIzMSwwLDQuMjU1LDEuODIzLDQuNzM1LDIuODQ4YTUuMiw1LjIsMCwwLDEsNC43MzYtMi44NDhjNC4yODgsMCw1LjY5NSwyLjQsNS42OTUsNi4yNzF2OS4wODdoLTIuNDk1di04Ljk2YzAtMi4wNzktLjczNi00LjA5NS0zLjY0OC00LjA5NS0yLjExMiwwLTMuODcyLDEuNzI4LTMuODcyLDQuNDE2djguNjM5aC0yLjVWNTMuMzQyYzAtMy4zLS44MzItNC41NzYtMi44OC00LjU3Ni0zLjIzMiwwLTQuNjQsMi4zMzYtNC42NCw1Ljc1OXY3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTg0Ljk4OCw0Ni44NDZoMi41djIuMTc2aC4wNjRhNi45NDIsNi45NDIsMCwwLDEsNS4zNzUtMi41NTksNy41NDMsNy41NDMsMCwwLDEsNy44NzIsNy44NzEsNy41NjksNy41NjksMCwwLDEtNy40ODgsNy44NzEsNi40ODYsNi40ODYsMCwwLDEtNS43NTktMy4wMzloLS4wNjR2OS45NTFoLTIuNVpNMTkyLjgsNTkuOWE1LjIyNyw1LjIyNywwLDAsMCw1LjMxMi01LjU2Nyw1LjMxNyw1LjMxNywwLDEsMC0xMC42MjMsMEE1LjIyNiw1LjIyNiwwLDAsMCwxOTIuOCw1OS45WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMTguMDQyLDU5LjFhNy42ODEsNy42ODEsMCwwLDEtNi42NTUsMy4xYy00LjcsMC03LjU4My0zLjUxOS03LjU4My03Ljg3MWE3LjUsNy41LDAsMCwxLDcuNjc5LTcuODcxYzQuMjI0LDAsNy4xLDIuODc5LDcuMSw3LjgzOXYuOEgyMDYuNDkyYTUuMDA2LDUuMDA2LDAsMCwwLDQuOSw0LjgsNS41NzksNS41NzksMCwwLDAsNC43NjgtMi4yNzJaTTIxNS45LDUyLjk5YTQuMTYzLDQuMTYzLDAsMCwwLTQuNTEyLTQuMjI0LDQuNjMzLDQuNjMzLDAsMCwwLTQuOSw0LjIyNFoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjIyLjQ1OSw1MC40YzAtMS4zNzYtLjEyNy0yLjU2LS4xMjctMy41NTJIMjI0LjdjMCwuOC4wNjUsMS42MzMuMDY1LDIuNDY1aC4wNjRhNS40MzQsNS40MzQsMCwwLDEsNC45OTEtMi44NDgsMi45NDIsMi45NDIsMCwwLDEsMS4wMjQuMTZsLS4xNiwyLjUyN2E0LjcwNiw0LjcwNiwwLDAsMC0xLjM0NC0uMTkyYy0zLjA0LDAtNC4zODMsMi4xNDQtNC4zODMsNS41Njd2Ny4zaC0yLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIzMy41MzEsNDguNzY2YTguMzM1LDguMzM1LDAsMCwxLDUuOTUyLTIuM2M0LjQxNSwwLDYuMjcxLDIuMTExLDYuMjcxLDYuMzM1djYuNDMxYTE2LjYxNywxNi42MTcsMCwwLDAsLjIyNSwyLjU5MmgtMi40YTEwLjY0NCwxMC42NDQsMCwwLDEtLjE2MS0yLjIzOWgtLjA2NGE1LjY2LDUuNjYsMCwwLDEtNC45MjcsMi42MjNjLTMuMDQsMC01LjU2OC0xLjUzNS01LjU2OC00LjQ0NywwLTQuOTYsNS43Ni01LjI0OCw5LjQ0LTUuMjQ4aC45NnYtLjQ0N2MwLTIuMTc2LTEuMzc2LTMuMy0zLjcxMi0zLjNBNi42NDgsNi42NDgsMCwwLDAsMjM1LjEsNTAuNFptNy4yMzIsNS44NTVjLTMuMTY4LDAtNS4yMTYuODY1LTUuMjE2LDIuODgxLDAsMS44ODgsMS40MDgsMi41OTIsMy4zLDIuNTkyLDIuODgsMCw0LjM1Mi0yLjA4LDQuNDE2LTQuNTEydi0uOTYxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yNTguNTIyLDQ4Ljk1OGgtNC40MTV2Ny40ODdjMCwxLjkyLjAzMiwzLjQ1NiwyLjI0LDMuNDU2YTQuODcxLDQuODcxLDAsMCwwLDIuMjA4LS41MTFsLjA5NSwyLjI3MWE3LjU4LDcuNTgsMCwwLDEtMi45MTEuNTQ0Yy0zLjU1MiwwLTQuMTI4LTEuOTItNC4xMjgtNS4wMjNWNDguOTU4aC0zLjI2NFY0Ni44NDZoMy4yNjRWNDIuNTkxaDIuNXY0LjI1NWg0LjQxNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjc0LjY1LDU4LjI3YzAsMS4zNzYuMTI4LDIuNTYuMTI4LDMuNTUxSDI3Mi40MWMwLS44LS4wNjQtMS42MzItLjA2NC0yLjQ2NGgtLjA2NGE1LjQzNiw1LjQzNiwwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDZoMi41djguOTkyYzAsMi41LDEuMDg4LDQuMDYzLDMuNDI0LDQuMDYzLDMuMjMxLDAsNC42MzktMi4zMzYsNC42MzktNS43NTl2LTcuM2gyLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTI3OS4zODcsNTAuNGMwLTEuMzc2LS4xMjgtMi41Ni0uMTI4LTMuNTUyaDIuMzY4YzAsLjguMDY0LDEuNjMzLjA2NCwyLjQ2NWguMDY0YTUuNDM2LDUuNDM2LDAsMCwxLDQuOTkxLTIuODQ4LDIuOTUsMi45NSwwLDAsMSwxLjAyNS4xNmwtLjE2MSwyLjUyN2E0LjcsNC43LDAsMCwwLTEuMzQzLS4xOTJjLTMuMDQsMC00LjM4NCwyLjE0NC00LjM4NCw1LjU2N3Y3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMzAzLjQ1LDU5LjFhNy42ODQsNy42ODQsMCwwLDEtNi42NTYsMy4xYy00LjcsMC03LjU4My0zLjUxOS03LjU4My03Ljg3MWE3LjUsNy41LDAsMCwxLDcuNjc5LTcuODcxYzQuMjI0LDAsNy4xLDIuODc5LDcuMSw3LjgzOXYuOEgyOTEuOWE1LjAwNyw1LjAwNywwLDAsMCw0Ljg5NSw0LjgsNS41NzksNS41NzksMCwwLDAsNC43NjgtMi4yNzJabS0yLjE0NC02LjExMmE0LjE2Myw0LjE2MywwLDAsMC00LjUxMi00LjIyNEE0LjYzMyw0LjYzMywwLDAsMCwyOTEuOSw1Mi45OVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNNTUsMTAyLjVhNTAsNTAsMCwxLDEsNTAtNTBBNTAuMDU3LDUwLjA1NywwLDAsMSw1NSwxMDIuNVpNNTUsNC4yODZBNDguMjE0LDQ4LjIxNCwwLDEsMCwxMDMuMjE0LDUyLjUsNDguMjY4LDQ4LjI2OCwwLDAsMCw1NSw0LjI4NloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNNjAuMzU3LDU0Ljl2LS42MTRoMi42NzlhLjg5My44OTMsMCwxLDAsMC0xLjc4Nkg2MC4zNTdWNTAuNzE0aDIuNjc5YS44OTMuODkzLDAsMSwwLDAtMS43ODVINjAuMzU3VjQ3LjE0M2gyLjY3OWEuODkzLjg5MywwLDEsMCwwLTEuNzg2SDYwLjM1N1Y0My41NzJoMi42NzlhLjg5My44OTMsMCwxLDAsMC0xLjc4Nkg2MC4zNTdWNDBoMi42NzlhLjg5My44OTMsMCwxLDAsMC0xLjc4Nkg2MC4zNTdWMzQuNjQzYTQuMTU3LDQuMTU3LDAsMCwwLTEuNjc0LTMuNDMyLDcuMDg4LDcuMDg4LDAsMCwwLTcuMzY2LDAsNC4xNTcsNC4xNTcsMCwwLDAtMS42NzQsMy40MzJWNTQuOWExMC42NDEsMTAuNjQxLDAsMCwwLTUuMzU2LDkuNDA1LDEwLjcxNCwxMC43MTQsMCwwLDAsMjEuNDI3LS4yQTEwLjY0NCwxMC42NDQsMCwwLDAsNjAuMzU3LDU0LjlabS0xLjc4Ni40NzRhLjg5NC44OTQsMCwwLDAsLjQ3NS43ODEsOC45MjksOC45MjksMCwxLDEtOC4wOTIsMCwuODkzLjg5MywwLDAsMCwuNDc0LS43ODFWMzQuNjQzYTIuMTg5LDIuMTg5LDAsMCwxLC45NDktMS45ODEsNS4yNzcsNS4yNzcsMCwwLDEsNS4yNDYsMCwyLjE5MSwyLjE5MSwwLDAsMSwuOTQ4LDEuOTgxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjwvc3ZnPg==",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 25,
            "editorY": 76
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AirQualityColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 360,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 360,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 520,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDEwPC90aXRsZT48Y2lyY2xlIGN4PSI1NSIgY3k9IjUyLjUiIHI9IjM1LjcxNCIgc3R5bGU9ImZpbGw6IzczODViZiIvPjxwYXRoIGQ9Ik01NSwxMDIuNWE1MCw1MCwwLDEsMSw1MC01MEE1MC4wNTcsNTAuMDU3LDAsMCwxLDU1LDEwMi41Wk01NSw0LjI4NkE0OC4yMTQsNDguMjE0LDAsMSwwLDEwMy4yMTQsNTIuNSw0OC4yNjgsNDguMjY4LDAsMCwwLDU1LDQuMjg2WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik00MS45NzksMzAuMTc5YTIuNzksMi43OSwwLDAsMC0yLjc5LDIuNzl2MTAuN2EyNS45LDI1LjksMCwwLDAtNi41MS0xLjR2MS44NmEyNi44LDI2LjgsMCwwLDEsNi41MSwxLjQ4M3Y1LjQ5M2EyNS44NTMsMjUuODUzLDAsMCwwLTYuNTEtMS4zOTV2MS44NmEyNi43ODQsMjYuNzg0LDAsMCwxLDYuNTEsMS40ODJ2NS40OTNhMjUuOSwyNS45LDAsMCwwLTYuNTEtMS40djEuODZhMjYuOCwyNi44LDAsMCwxLDYuNTEsMS40ODNWNzIuMDMxYTIuNzksMi43OSwwLDAsMCwyLjc5LDIuNzlINjguMDIxYTIuNzksMi43OSwwLDAsMCwyLjc5LTIuNzlWNjMuMjgzbC0xLjg2LS41NTJ2OS4zYS45My45MywwLDAsMS0uOTMuOTNINDEuOTc5YS45My45MywwLDAsMS0uOTMtLjkzVjMyLjk2OWEuOTMuOTMsMCwwLDEsLjkzLS45M0g2OC4wMjFhLjkzLjkzLDAsMCwxLC45My45M1Y0My45ODRhMjguNDc0LDI4LjQ3NCwwLDAsMC03LjQ0MS0xLjcxNWMtMi4wNDUsMC00LjU1NSwxLjAxOC02Ljk3NSwxLjk0OC0yLjIzMS44MzUtNC40NjUsMS43NzMtNi4wNDUsMS43NzNhMjQuNTU0LDI0LjU1NCwwLDAsMS01LjU4MS0xLjIyMXYxLjU2N2EyMi4zODcsMjIuMzg3LDAsMCwwLDUuNTgxLDEuMTA1YzEuOTU0LDAsNC4yNjUtLjkzLDYuNjg0LTEuODYsMi4yMzEtLjkzMSw0LjU3MS0xLjg2MSw2LjMzNi0xLjg2MXM0LjczMS45Myw3LjYxNSwxLjg2MWMzLjE2MS45Myw2LjE1MSwxLjg2LDguMiwxLjg2VjQ1Ljk5YTMwLjAxNCwzMC4wMTQsMCwwLDEtNi41MS0xLjQ1NFYzMi45NjlhMi43OSwyLjc5LDAsMCwwLTIuNzktMi43OVpNNjEuNTEsNDkuM2MtMi4wNDUsMC00LjU1NSwxLjAxNy02Ljk3NSwxLjk0Ny0yLjIzMS44MzYtNC40NjUsMS43NzMtNi4wNDUsMS43NzNBMjQuNSwyNC41LDAsMCwxLDQyLjkwOSw1MS44djEuOTc3YTIyLjQyNCwyMi40MjQsMCwwLDAsNS41ODEsMS4xYzEuOTU0LDAsNC4yNjUtLjkzLDYuNjg0LTEuODYsMi4yMzEtLjkzLDQuNTcxLTEuODYsNi4zMzYtMS44NnM0LjczMS45Myw3LjYxNSwxLjg2YzMuMTYxLjkzLDYuMTUxLDEuODYsOC4yLDEuODZ2LTEuODZjLTEuNjc0LDAtNC43My0uOTM3LTcuNjE0LTEuNzczQzY2LjU0Niw1MC4yMjQsNjMuNTU2LDQ5LjMsNjEuNTEsNDkuM1ptMCw3LjQ0Yy0yLjA0NSwwLTQuNTU1LDEuMDE4LTYuOTc1LDEuOTQ4LTIuMjMxLjgzNS00LjQ2NSwxLjc3My02LjA0NSwxLjc3M2EyNC41NTQsMjQuNTU0LDAsMCwxLTUuNTgxLTEuMjIxdjEuOTc2YTIyLjQzMywyMi40MzMsMCwwLDAsNS41ODEsMS4xMDVjMS45NTQsMCw0LjI2NS0uOTMsNi42ODQtMS44NiwyLjIzMS0uOTMxLDQuNTcxLTEuODYxLDYuMzM2LTEuODYxLDIuMjMxLDAsNS4wMSwxLjAyNSw3LjYxNSwxLjg2MSwzLjE2MS45Myw2LjE1MSwxLjg2LDguMiwxLjg2di0xLjg2Yy0xLjY3NCwwLTQuNzMtLjkzOC03LjYxNC0xLjc3M0M2Ni41NDYsNTcuNjY0LDYzLjU1Niw1Ni43NDEsNjEuNTEsNTYuNzQxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xMjkuNSw0OC43NjdhOC4zMzMsOC4zMzMsMCwwLDEsNS45NTItMi4zYzQuNDE1LDAsNi4yNzIsMi4xMTIsNi4yNzIsNi4zMzZ2Ni40MzFhMTYuNjEzLDE2LjYxMywwLDAsMCwuMjIzLDIuNTkyaC0yLjRhMTAuNzA5LDEwLjcwOSwwLDAsMS0uMTYtMi4yNGgtLjA2NWE1LjY2MSw1LjY2MSwwLDAsMS00LjkyNywyLjYyNGMtMy4wMzksMC01LjU2OC0xLjUzNi01LjU2OC00LjQ0NywwLTQuOTYsNS43Ni01LjI0OCw5LjQ0LTUuMjQ4aC45NnYtLjQ0OGMwLTIuMTc2LTEuMzc2LTMuMjk1LTMuNzEyLTMuMjk1YTYuNjUsNi42NSwwLDAsMC00LjQ0OSwxLjYzMVptNy4yMzIsNS44NTVjLTMuMTY4LDAtNS4yMTUuODYzLTUuMjE1LDIuODgsMCwxLjg4OCwxLjQwNywyLjU5MiwzLjI5NSwyLjU5MiwyLjg3OSwwLDQuMzUxLTIuMDgsNC40MTYtNC41MTJ2LS45NloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTQ3Ljc3LDM5LjE2N2ExLjgyMywxLjgyMywwLDAsMSwxLjgyMywxLjgyNCwxLjgyNCwxLjgyNCwwLDAsMS0zLjY0OCwwQTEuODIzLDEuODIzLDAsMCwxLDE0Ny43NywzOS4xNjdabS0xLjI0OSw3LjY4aDIuNVY2MS44MjFoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTUzLjk3Nyw1MC40YzAtMS4zNzYtLjEyOC0yLjU2LS4xMjgtMy41NTFoMi4zNjhjMCwuOC4wNjQsMS42MzIuMDY0LDIuNDY0aC4wNjRhNS40MzYsNS40MzYsMCwwLDEsNC45OTEtMi44NDksMi45NjUsMi45NjUsMCwwLDEsMS4wMjQuMTZsLS4xNiwyLjUyOGE0LjcsNC43LDAsMCwwLTEuMzQ0LS4xOTJjLTMuMDQsMC00LjM4MywyLjE0NS00LjM4Myw1LjU2N3Y3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTg5LjA3OSw2OS4xMTdoLTIuNVY1OS42NDZoLS4wNjRhNi45NDUsNi45NDUsMCwwLDEtNS4zNzUsMi41NTksNy41NDMsNy41NDMsMCwwLDEtNy44NzMtNy44NzEsNy41Nyw3LjU3LDAsMCwxLDcuNDg4LTcuODcyLDYuNDg5LDYuNDg5LDAsMCwxLDUuNzYsMy4wNGguMDY0VjQ2Ljg0N2gyLjVabS03LjgwOC0yMC4zNWE1LjIyNiw1LjIyNiwwLDAsMC01LjMxLDUuNTY3LDUuMzE3LDUuMzE3LDAsMSwwLDEwLjYyMywwQTUuMjI3LDUuMjI3LDAsMCwwLDE4MS4yNzEsNDguNzY3WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMDYuNzQzLDU4LjI3YzAsMS4zNzYuMTI4LDIuNTU5LjEyOCwzLjU1MUgyMDQuNWMwLS44LS4wNjUtMS42MzItLjA2NS0yLjQ2NGgtLjA2NGE1LjQzNiw1LjQzNiwwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDdoMi41djguOTkxYzAsMi41LDEuMDg3LDQuMDYzLDMuNDIzLDQuMDYzLDMuMjMzLDAsNC42NDEtMi4zMzYsNC42NDEtNS43NTl2LTcuM2gyLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIxMS4yODgsNDguNzY3YTguMzMzLDguMzMzLDAsMCwxLDUuOTUyLTIuM2M0LjQxNSwwLDYuMjcyLDIuMTEyLDYuMjcyLDYuMzM2djYuNDMxYTE2LjYxMywxNi42MTMsMCwwLDAsLjIyMywyLjU5MmgtMi40YTEwLjcwOSwxMC43MDksMCwwLDEtLjE2LTIuMjRoLS4wNjVhNS42NjEsNS42NjEsMCwwLDEtNC45MjcsMi42MjRjLTMuMDM5LDAtNS41NjgtMS41MzYtNS41NjgtNC40NDcsMC00Ljk2LDUuNzYtNS4yNDgsOS40NC01LjI0OGguOTZ2LS40NDhjMC0yLjE3Ni0xLjM3Ni0zLjI5NS0zLjcxMi0zLjI5NWE2LjY1LDYuNjUsMCwwLDAtNC40NDksMS42MzFabTcuMjMyLDUuODU1Yy0zLjE2OCwwLTUuMjE1Ljg2My01LjIxNSwyLjg4LDAsMS44ODgsMS40MDcsMi41OTIsMy4yOTUsMi41OTIsMi44NzksMCw0LjM1MS0yLjA4LDQuNDE2LTQuNTEydi0uOTZaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIyOC4zMTMsMzcuNjMxaDIuNXYyNC4xOWgtMi41WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMzcuMjQsMzkuMTY3YTEuODIyLDEuODIyLDAsMCwxLDEuODIzLDEuODI0LDEuODI0LDEuODI0LDAsMCwxLTMuNjQ3LDBBMS44MjMsMS44MjMsMCwwLDEsMjM3LjI0LDM5LjE2N1ptLTEuMjQ4LDcuNjhoMi41VjYxLjgyMWgtMi41WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yNTEuNjM5LDQ4Ljk1OGgtNC40MTZ2Ny40ODdjMCwxLjkyLjAzMywzLjQ1NiwyLjI0LDMuNDU2YTQuODcxLDQuODcxLDAsMCwwLDIuMjA4LS41MTFsLjEsMi4yNzFhNy41OTIsNy41OTIsMCwwLDEtMi45MTIuNTQ0Yy0zLjU1MiwwLTQuMTI3LTEuOTItNC4xMjctNS4wMjNWNDguOTU4aC0zLjI2NVY0Ni44NDdoMy4yNjVWNDIuNTkxaDIuNXY0LjI1Nmg0LjQxNloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjYwLjIxNSw2NS4yNDVjLS45OTIsMi41MjctMS45ODUsNC4yNTYtNC45OTIsNC4yNTZhNS40MjksNS40MjksMCwwLDEtMi4yNC0uMzg0bC4zMi0yLjE3N2E0LjgzNyw0LjgzNywwLDAsMCwxLjc2LjI1N2MxLjYzMiwwLDIuMjQtLjk5MiwyLjc4NC0yLjQ2NGwxLjAyNC0yLjgxNi02LjIwOC0xNS4wN2gyLjkxMmw0LjY0LDExLjc0M2guMDY0bDQuNDQ4LTExLjc0M2gyLjcxOVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48L3N2Zz4=",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 26,
            "editorY": 403
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppInterval",
          "type": "AppInterval",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null,
            "time": 1000,
            "startOnInitialize": true
          },
          "meta": {
            "editorX": 117,
            "editorY": 295,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TemperatureCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "HumidityCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQualityCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AmbientLightCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "VibrationCharacteristic",
                "targetAbility": "read"
              }
            ],
            "started": [],
            "paused": []
          }
        },
        {
          "name": "AirQualityCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), ATMO_PROPERTY(AirQualityCharacteristic, readDataType), ATMO_PROPERTY(AirQualityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AirQualityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AirQualityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e75-a4ff-6f0cd50005f4",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 274,
            "editorY": 493,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "readData + \" ppb\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "AirQualityLabel",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "key": {
                    "code": "\"AirQuality\""
                  },
                  "value": {
                    "code": "Number(readData.toFixed(2))"
                  }
                },
                "targetOrder": [
                  "key",
                  "value"
                ],
                "targetElement": "Expression",
                "targetAbility": "setValue"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "AirQualityCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "TemperatureCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), ATMO_PROPERTY(TemperatureCharacteristic, readDataType), ATMO_PROPERTY(TemperatureCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(TemperatureCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(TemperatureCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e76-a4ff-6f0cd50005f1",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 272,
            "editorY": 57,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "readData.toFixed(1) + \" C\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "TemperatureLabel",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "key": {
                    "code": "\"Temperature\""
                  },
                  "value": {
                    "code": "Number(readData.toFixed(2))readData"
                  }
                },
                "targetOrder": [
                  "key",
                  "value"
                ],
                "targetElement": "Expression",
                "targetAbility": "setValue"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "TemperatureCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "HumidityCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(HumidityCharacteristic, writeDataType), ATMO_PROPERTY(HumidityCharacteristic, readDataType), ATMO_PROPERTY(HumidityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(HumidityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(HumidityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(HumidityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e77-a4ff-6f0cd50005f2",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 279,
            "editorY": 209,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "readData.toFixed(1) + \" %\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "HumidityLabel",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "key": {
                    "code": "\"Humidity\""
                  },
                  "value": {
                    "code": "Number(readData.toFixed(2))readData"
                  }
                },
                "targetOrder": [
                  "key",
                  "value"
                ],
                "targetElement": "Expression",
                "targetAbility": "setValue"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "HumidityCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "AmbientLightCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AmbientLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AmbientLightCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AmbientLightCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AmbientLightCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AmbientLightCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AmbientLightCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AmbientLightCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AmbientLightCharacteristic, writeDataType), ATMO_PROPERTY(AmbientLightCharacteristic, readDataType), ATMO_PROPERTY(AmbientLightCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AmbientLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AmbientLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AmbientLightCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\tATMO_VARIABLE(AmbientLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AmbientLightCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AmbientLightCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AmbientLightCharacteristic, instance),\n\t\tATMO_VARIABLE(AmbientLightCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AmbientLightCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e79-a4ff-6f0cd50005f3",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 277,
            "editorY": 347,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "text": {
                    "code": "readData + \" lx\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "LightLabel",
                "targetAbility": "setText"
              },
              {
                "mapping": {
                  "key": {
                    "code": "\"Light\""
                  },
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "key",
                  "value"
                ],
                "targetElement": "Expression",
                "targetAbility": "setValue"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "AmbientLightCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLEConnection",
          "type": "AppBLEConnection",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_PairingCfg_t pairingCfg;\n\tpairingCfg.pairingKey = ATMO_PROPERTY(BLEConnection, pairingKey);\n\tpairingCfg.type = ATMO_PROPERTY(BLEConnection, pairingType);\n\tATMO_BLE_GAPPairingCfg(ATMO_PROPERTY(BLEConnection, instance), &pairingCfg);\n\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_Connected, ATMO_ABILITY(BLEConnection, connected));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_Disconnected, ATMO_ABILITY(BLEConnection, disconnected));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_PairingRequested, ATMO_ABILITY(BLEConnection, pairingRequested));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_PairingSuccess, ATMO_ABILITY(BLEConnection, pairingSucceeded));\n\tATMO_BLE_RegisterEventAbilityHandle(ATMO_PROPERTY(BLEConnection, instance), ATMO_BLE_EVENT_PairingFailed, ATMO_ABILITY(BLEConnection, pairingFailed));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "disconnect": "\n\tATMO_BLE_GAPDisconnect(ATMO_PROPERTY(BLEConnection, instance));\n\treturn ATMO_Status_Success;\n\t",
              "connected": "\n\treturn ATMO_Status_Success;\n\t",
              "disconnected": "\n\treturn ATMO_Status_Success;\n\t",
              "pairingRequested": "\n\tATMO_CreateValueCopy(out, in);\n\treturn ATMO_Status_Success;\n\t",
              "pairingSucceeded": "\n\treturn ATMO_Status_Success;\n\t",
              "pairingFailed": "\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "disconnect": false,
              "connected": false,
              "disconnected": false,
              "pairingRequested": false,
              "pairingSucceeded": false,
              "pairingFailed": false
            },
            "instance": 0,
            "pairingType": "ATMO_BLE_PairingType_RandomKey",
            "pairingKey": "123456"
          },
          "meta": {
            "editorX": 271,
            "editorY": 748,
            "lastTrigger": "connected"
          },
          "triggers": {
            "triggered": [],
            "disconnected": [],
            "connected": []
          },
          "coupledElementName": "BLEConnection",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "VibrationCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\t&ATMO_VARIABLE(VibrationCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(VibrationCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(VibrationCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(VibrationCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(VibrationCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(VibrationCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(VibrationCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(VibrationCharacteristic, writeDataType), ATMO_PROPERTY(VibrationCharacteristic, readDataType), ATMO_PROPERTY(VibrationCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\t&ATMO_VARIABLE(VibrationCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(VibrationCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(VibrationCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\tATMO_VARIABLE(VibrationCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(VibrationCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(VibrationCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(VibrationCharacteristic, instance),\n\t\tATMO_VARIABLE(VibrationCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(VibrationCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "0",
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f5",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 274,
            "editorY": 646,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "key": {
                    "code": "\"Vibration\""
                  },
                  "value": {
                    "code": "Number(readData.toFixed(2))"
                  }
                },
                "targetOrder": [
                  "key",
                  "value"
                ],
                "targetElement": "Expression",
                "targetAbility": "setValue"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "VibrationCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "Expression",
          "type": "AppExpression",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null,
            "expression": "true",
            "values": {},
            "value": null
          },
          "meta": {
            "editorX": 449,
            "editorY": 340,
            "lastTrigger": "evaluated"
          },
          "triggers": {
            "triggered": [],
            "evaluated": [
              {
                "mapping": {
                  "value": {
                    "code": "values"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "CloudEvent",
                "targetAbility": "send"
              }
            ],
            "expressionTrue": [],
            "expressionFalse": []
          }
        },
        {
          "name": "CloudEvent",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 559,
            "editorY": 341,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "HouseImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 351,
                  "height": 631.609375,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 356,
                  "height": 629.609375,
                  "x": 9,
                  "y": 11,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 523,
                  "height": 699.609375,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACWAAAAlgCAMAAAA7k/xcAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAADZ1AAA2dQEIlw4vAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABp0RVh0VGl0bGUAZWNvIGdyZWVuIGhvdXNlIGljb24GvjKJAAAAGHRFWHRBdXRob3IAZG9taW5pcXVlY2hhcHBhcmSW+NHmAAAAIXRFWHRDcmVhdGlvbiBUaW1lADIwMTItMDYtMDFUMTU6NDg6MDPDARbSAAAAV3RFWHRTb3VyY2UAaHR0cHM6Ly9vcGVuY2xpcGFydC5vcmcvZGV0YWlsLzE3MDM0NC9lY28tZ3JlZW4taG91c2UtaWNvbi1ieS1jeWJlcmdlZGVvbi0xNzAzNDSHixz7AAAAWHRFWHRDb3B5cmlnaHQAQ0MwIFB1YmxpYyBEb21haW4gRGVkaWNhdGlvbiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9wdWJsaWNkb21haW4vemVyby8xLjAvxuO9+QAAAwBQTFRFAAAAAP8AgIAAVaoAQL8AM5kAVaoASbYAQJ8AOaoATbMARqIAQKoAO7EASaQARKoAQK8AS6UAR6oAQ64AQKYASaoARq4AQ6YAQKoAR60ARacAQqoAQK0ARqcARKoAQq0ASKcARqoARK0AQqgAR6oARawAQ6gAQaoARqwARKgAQ6oAQawARqgARKoAQ6wAR6gARaoARKwAQqgARqoARawAQ6gAQqoARqwARKgAQ6oAQqsARakARKoAQ6sARqkARaoARKsAQ6kARqoARasARKkAQ6oARasARKkAQ6oAQqsARakARKoAQ6sARqkARaoARKsAQ6kARaoARKsARKkAQ6oARasARKkAQ6oAQ6sARakARKoAQ6sARakARaoARKsAQ6kARaoARKsARKkAQ6oARasARKkARKoAQ6sARakARKoAQ6sARakARKoARKsAQ6kARaoARKsARKkAQ6oARasARKkARKoAQ6sARakARKoAQ6sARakARKoARKsAQ6kARaoARKsARKkAQ6oARasARKkARKoAQ6sARakARKoARKsARakARKoARKsAQ6kARaoARKsARKkAQ6oARasARKkARKoAQ6sARKkARKoARKsARakARKoARKsAQ6kARaoARKsARKkAQ6oARasARKkARKoAQ6sARKkARKoARKsARakARKoARKsARKoARaoARKoARKoAQ6oARKoARKoARKoAQ6oARKoARKoARKoARaoARKoARKoARKoARaoARKoARKoAQ6oARKoARKoARKoAQ6oARKoARKoARKoARaoARKoARKoARKoARaoARKoARKoARKoARKoARKoARKoAQ6oARKoARKoARKoARaoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoAQ6oARKoARKoARKoARaoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARKoARGE7DAAAAP90Uk5TAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+6wjZNQAAvuRJREFUeNrs3VeMnAXaNuhu3A5twJhkbMKQYwcb52xswDiSu1e/9htmtQdVezTMWZVWWg2z0krV2tVqmLNqaQ+G2ZV+dRONsckGB2zj3GGAIec8Jjpg417bDDMEu92h4lPXJX3zGYfuut+nuvrup96qt7rq1y5fful5Y84/Z1gVAADHs/+j9z96/63VL/36T6p/8d8nXbt82SQHDACgj9589NHnDvZasG74vxscJgCAfnnlf7u/57gFa1ZmtiMEANBvL6aeO3bBGv3Xmx0dAIABefh/3n2MgnXZiqsdGgCAAXr95r//+MuTfvzFTVv0KwCAAbt00/IffznkX///f/n/RjouAAADN7z5420//OpfTxHe9NgQRwUAYFAO3bLyJwXrqk2nOSQAAIP09YzufxesMzZf5oAAAAzam1M/q/rXSe7/j34F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",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 742,
            "editorY": 196,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        }
      ]
    },
    "Cloud": {
      "type": "cloud",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {},
      "elements": [
        {
          "name": "SensorData",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 321,
            "editorY": 105,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "CloudEvent",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 151,
            "editorY": 108,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "value"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "CloudEvent",
          "coupledElementPlaneName": "App View"
        }
      ],
      "layout": {
        "height": 1000,
        "width": 1000,
        "zIndexOrder": []
      }
    }
  }
}